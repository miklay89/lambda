/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@hapi/boom/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/boom/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    codes: new Map([
        [100, 'Continue'],
        [101, 'Switching Protocols'],
        [102, 'Processing'],
        [200, 'OK'],
        [201, 'Created'],
        [202, 'Accepted'],
        [203, 'Non-Authoritative Information'],
        [204, 'No Content'],
        [205, 'Reset Content'],
        [206, 'Partial Content'],
        [207, 'Multi-Status'],
        [300, 'Multiple Choices'],
        [301, 'Moved Permanently'],
        [302, 'Moved Temporarily'],
        [303, 'See Other'],
        [304, 'Not Modified'],
        [305, 'Use Proxy'],
        [307, 'Temporary Redirect'],
        [400, 'Bad Request'],
        [401, 'Unauthorized'],
        [402, 'Payment Required'],
        [403, 'Forbidden'],
        [404, 'Not Found'],
        [405, 'Method Not Allowed'],
        [406, 'Not Acceptable'],
        [407, 'Proxy Authentication Required'],
        [408, 'Request Time-out'],
        [409, 'Conflict'],
        [410, 'Gone'],
        [411, 'Length Required'],
        [412, 'Precondition Failed'],
        [413, 'Request Entity Too Large'],
        [414, 'Request-URI Too Large'],
        [415, 'Unsupported Media Type'],
        [416, 'Requested Range Not Satisfiable'],
        [417, 'Expectation Failed'],
        [418, 'I\'m a teapot'],
        [422, 'Unprocessable Entity'],
        [423, 'Locked'],
        [424, 'Failed Dependency'],
        [425, 'Too Early'],
        [426, 'Upgrade Required'],
        [428, 'Precondition Required'],
        [429, 'Too Many Requests'],
        [431, 'Request Header Fields Too Large'],
        [451, 'Unavailable For Legal Reasons'],
        [500, 'Internal Server Error'],
        [501, 'Not Implemented'],
        [502, 'Bad Gateway'],
        [503, 'Service Unavailable'],
        [504, 'Gateway Time-out'],
        [505, 'HTTP Version Not Supported'],
        [506, 'Variant Also Negotiates'],
        [507, 'Insufficient Storage'],
        [509, 'Bandwidth Limit Exceeded'],
        [510, 'Not Extended'],
        [511, 'Network Authentication Required']
    ])
};


exports.Boom = class extends Error {

    constructor(message, options = {}) {

        if (message instanceof Error) {
            return exports.boomify(Hoek.clone(message), options);
        }

        const { statusCode = 500, data = null, ctor = exports.Boom } = options;
        const error = new Error(message ? message : undefined);         // Avoids settings null message
        Error.captureStackTrace(error, ctor);                           // Filter the stack to our external API
        error.data = data;
        const boom = internals.initialize(error, statusCode);

        Object.defineProperty(boom, 'typeof', { value: ctor });

        if (options.decorate) {
            Object.assign(boom, options.decorate);
        }

        return boom;
    }

    static [Symbol.hasInstance](instance) {

        if (this === exports.Boom) {
            return exports.isBoom(instance);
        }

        // Cannot use 'instanceof' as it creates infinite recursion

        return this.prototype.isPrototypeOf(instance);
    }
};


exports.isBoom = function (err, statusCode) {

    return err instanceof Error && !!err.isBoom && (!statusCode || err.output.statusCode === statusCode);
};


exports.boomify = function (err, options) {

    Hoek.assert(err instanceof Error, 'Cannot wrap non-Error object');

    options = options || {};

    if (options.data !== undefined) {
        err.data = options.data;
    }

    if (options.decorate) {
        Object.assign(err, options.decorate);
    }

    if (!err.isBoom) {
        return internals.initialize(err, options.statusCode || 500, options.message);
    }

    if (options.override === false ||                           // Defaults to true
        !options.statusCode && !options.message) {

        return err;
    }

    return internals.initialize(err, options.statusCode || err.output.statusCode, options.message);
};


// 4xx Client Errors

exports.badRequest = function (message, data) {

    return new exports.Boom(message, { statusCode: 400, data, ctor: exports.badRequest });
};


exports.unauthorized = function (message, scheme, attributes) {          // Or (message, wwwAuthenticate[])

    const err = new exports.Boom(message, { statusCode: 401, ctor: exports.unauthorized });

    // function (message)

    if (!scheme) {
        return err;
    }

    // function (message, wwwAuthenticate[])

    if (typeof scheme !== 'string') {
        err.output.headers['WWW-Authenticate'] = scheme.join(', ');
        return err;
    }

    // function (message, scheme, attributes)

    let wwwAuthenticate = `${scheme}`;

    if (attributes ||
        message) {

        err.output.payload.attributes = {};
    }

    if (attributes) {
        if (typeof attributes === 'string') {
            wwwAuthenticate += ' ' + Hoek.escapeHeaderAttribute(attributes);
            err.output.payload.attributes = attributes;
        }
        else {
            wwwAuthenticate += ' ' + Object.keys(attributes).map((name) => {

                let value = attributes[name];
                if (value === null ||
                    value === undefined) {

                    value = '';
                }

                err.output.payload.attributes[name] = value;
                return `${name}="${Hoek.escapeHeaderAttribute(value.toString())}"`;
            })
                .join(', ');
        }
    }

    if (message) {
        if (attributes) {
            wwwAuthenticate += ',';
        }

        wwwAuthenticate += ` error="${Hoek.escapeHeaderAttribute(message)}"`;
        err.output.payload.attributes.error = message;
    }
    else {
        err.isMissing = true;
    }

    err.output.headers['WWW-Authenticate'] = wwwAuthenticate;
    return err;
};


exports.paymentRequired = function (message, data) {

    return new exports.Boom(message, { statusCode: 402, data, ctor: exports.paymentRequired });
};


exports.forbidden = function (message, data) {

    return new exports.Boom(message, { statusCode: 403, data, ctor: exports.forbidden });
};


exports.notFound = function (message, data) {

    return new exports.Boom(message, { statusCode: 404, data, ctor: exports.notFound });
};


exports.methodNotAllowed = function (message, data, allow) {

    const err = new exports.Boom(message, { statusCode: 405, data, ctor: exports.methodNotAllowed });

    if (typeof allow === 'string') {
        allow = [allow];
    }

    if (Array.isArray(allow)) {
        err.output.headers.Allow = allow.join(', ');
    }

    return err;
};


exports.notAcceptable = function (message, data) {

    return new exports.Boom(message, { statusCode: 406, data, ctor: exports.notAcceptable });
};


exports.proxyAuthRequired = function (message, data) {

    return new exports.Boom(message, { statusCode: 407, data, ctor: exports.proxyAuthRequired });
};


exports.clientTimeout = function (message, data) {

    return new exports.Boom(message, { statusCode: 408, data, ctor: exports.clientTimeout });
};


exports.conflict = function (message, data) {

    return new exports.Boom(message, { statusCode: 409, data, ctor: exports.conflict });
};


exports.resourceGone = function (message, data) {

    return new exports.Boom(message, { statusCode: 410, data, ctor: exports.resourceGone });
};


exports.lengthRequired = function (message, data) {

    return new exports.Boom(message, { statusCode: 411, data, ctor: exports.lengthRequired });
};


exports.preconditionFailed = function (message, data) {

    return new exports.Boom(message, { statusCode: 412, data, ctor: exports.preconditionFailed });
};


exports.entityTooLarge = function (message, data) {

    return new exports.Boom(message, { statusCode: 413, data, ctor: exports.entityTooLarge });
};


exports.uriTooLong = function (message, data) {

    return new exports.Boom(message, { statusCode: 414, data, ctor: exports.uriTooLong });
};


exports.unsupportedMediaType = function (message, data) {

    return new exports.Boom(message, { statusCode: 415, data, ctor: exports.unsupportedMediaType });
};


exports.rangeNotSatisfiable = function (message, data) {

    return new exports.Boom(message, { statusCode: 416, data, ctor: exports.rangeNotSatisfiable });
};


exports.expectationFailed = function (message, data) {

    return new exports.Boom(message, { statusCode: 417, data, ctor: exports.expectationFailed });
};


exports.teapot = function (message, data) {

    return new exports.Boom(message, { statusCode: 418, data, ctor: exports.teapot });
};


exports.badData = function (message, data) {

    return new exports.Boom(message, { statusCode: 422, data, ctor: exports.badData });
};


exports.locked = function (message, data) {

    return new exports.Boom(message, { statusCode: 423, data, ctor: exports.locked });
};


exports.failedDependency = function (message, data) {

    return new exports.Boom(message, { statusCode: 424, data, ctor: exports.failedDependency });
};

exports.tooEarly = function (message, data) {

    return new exports.Boom(message, { statusCode: 425, data, ctor: exports.tooEarly });
};


exports.preconditionRequired = function (message, data) {

    return new exports.Boom(message, { statusCode: 428, data, ctor: exports.preconditionRequired });
};


exports.tooManyRequests = function (message, data) {

    return new exports.Boom(message, { statusCode: 429, data, ctor: exports.tooManyRequests });
};


exports.illegal = function (message, data) {

    return new exports.Boom(message, { statusCode: 451, data, ctor: exports.illegal });
};


// 5xx Server Errors

exports.internal = function (message, data, statusCode = 500) {

    return internals.serverError(message, data, statusCode, exports.internal);
};


exports.notImplemented = function (message, data) {

    return internals.serverError(message, data, 501, exports.notImplemented);
};


exports.badGateway = function (message, data) {

    return internals.serverError(message, data, 502, exports.badGateway);
};


exports.serverUnavailable = function (message, data) {

    return internals.serverError(message, data, 503, exports.serverUnavailable);
};


exports.gatewayTimeout = function (message, data) {

    return internals.serverError(message, data, 504, exports.gatewayTimeout);
};


exports.badImplementation = function (message, data) {

    const err = internals.serverError(message, data, 500, exports.badImplementation);
    err.isDeveloperError = true;
    return err;
};


internals.initialize = function (err, statusCode, message) {

    const numberCode = parseInt(statusCode, 10);
    Hoek.assert(!isNaN(numberCode) && numberCode >= 400, 'First argument must be a number (400+):', statusCode);

    err.isBoom = true;
    err.isServer = numberCode >= 500;

    if (!err.hasOwnProperty('data')) {
        err.data = null;
    }

    err.output = {
        statusCode: numberCode,
        payload: {},
        headers: {}
    };

    Object.defineProperty(err, 'reformat', { value: internals.reformat, configurable: true });

    if (!message &&
        !err.message) {

        err.reformat();
        message = err.output.payload.error;
    }

    if (message) {
        const props = Object.getOwnPropertyDescriptor(err, 'message') || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(err), 'message');
        Hoek.assert(!props || props.configurable && !props.get, 'The error is not compatible with boom');

        err.message = message + (err.message ? ': ' + err.message : '');
        err.output.payload.message = err.message;
    }

    err.reformat();
    return err;
};


internals.reformat = function (debug = false) {

    this.output.payload.statusCode = this.output.statusCode;
    this.output.payload.error = internals.codes.get(this.output.statusCode) || 'Unknown';

    if (this.output.statusCode === 500 && debug !== true) {
        this.output.payload.message = 'An internal server error occurred';              // Hide actual error from user
    }
    else if (this.message) {
        this.output.payload.message = this.message;
    }
};


internals.serverError = function (message, data, statusCode, ctor) {

    if (data instanceof Error &&
        !data.isBoom) {

        return exports.boomify(data, { statusCode, message });
    }

    return new exports.Boom(message, { statusCode, data, ctor });
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/applyToDefaults.js":
/*!********************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/applyToDefaults.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! ./clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Merge = __webpack_require__(/*! ./merge */ "./node_modules/@hapi/hoek/lib/merge.js");
const Reach = __webpack_require__(/*! ./reach */ "./node_modules/@hapi/hoek/lib/reach.js");


const internals = {};


module.exports = function (defaults, source, options = {}) {

    Assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    Assert(!source || source === true || typeof source === 'object', 'Invalid source value: must be true, falsy or an object');
    Assert(typeof options === 'object', 'Invalid options: must be an object');

    if (!source) {                                                  // If no source, return null
        return null;
    }

    if (options.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options);
    }

    const copy = Clone(defaults);

    if (source === true) {                                          // If source is set to true, use defaults
        return copy;
    }

    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
};


internals.applyToDefaultsWithShallow = function (defaults, source, options) {

    const keys = options.shallow;
    Assert(Array.isArray(keys), 'Invalid keys');

    const seen = new Map();
    const merge = source === true ? null : new Set();

    for (let key of keys) {
        key = Array.isArray(key) ? key : key.split('.');            // Pre-split optimization

        const ref = Reach(defaults, key);
        if (ref &&
            typeof ref === 'object') {

            seen.set(ref, merge && Reach(source, key) || ref);
        }
        else if (merge) {
            merge.add(key);
        }
    }

    const copy = Clone(defaults, {}, seen);

    if (!merge) {
        return copy;
    }

    for (const key of merge) {
        internals.reachCopy(copy, source, key);
    }

    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
};


internals.reachCopy = function (dst, src, path) {

    for (const segment of path) {
        if (!(segment in src)) {
            return;
        }

        const val = src[segment];

        if (typeof val !== 'object' || val === null) {
            return;
        }

        src = val;
    }

    const value = src;
    let ref = dst;
    for (let i = 0; i < path.length - 1; ++i) {
        const segment = path[i];
        if (typeof ref[segment] !== 'object') {
            ref[segment] = {};
        }

        ref = ref[segment];
    }

    ref[path[path.length - 1]] = value;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/assert.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/assert.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const AssertError = __webpack_require__(/*! ./error */ "./node_modules/@hapi/hoek/lib/error.js");


const internals = {};


module.exports = function (condition, ...args) {

    if (condition) {
        return;
    }

    if (args.length === 1 &&
        args[0] instanceof Error) {

        throw args[0];
    }

    throw new AssertError(args);
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/bench.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/bench.js ***!
  \**********************************************/
/***/ ((module) => {



const internals = {};


module.exports = internals.Bench = class {

    constructor() {

        this.ts = 0;
        this.reset();
    }

    reset() {

        this.ts = internals.Bench.now();
    }

    elapsed() {

        return internals.Bench.now() - this.ts;
    }

    static now() {

        const ts = process.hrtime();
        return (ts[0] * 1e3) + (ts[1] / 1e6);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/block.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/block.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Ignore = __webpack_require__(/*! ./ignore */ "./node_modules/@hapi/hoek/lib/ignore.js");


const internals = {};


module.exports = function () {

    return new Promise(Ignore);
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/clone.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/clone.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Reach = __webpack_require__(/*! ./reach */ "./node_modules/@hapi/hoek/lib/reach.js");
const Types = __webpack_require__(/*! ./types */ "./node_modules/@hapi/hoek/lib/types.js");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/@hapi/hoek/lib/utils.js");


const internals = {
    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
};


module.exports = internals.clone = function (obj, options = {}, _seen = null) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    let clone = internals.clone;
    let seen = _seen;

    if (options.shallow) {
        if (options.shallow !== true) {
            return internals.cloneWithShallow(obj, options);
        }

        clone = (value) => value;
    }
    else if (seen) {
        const lookup = seen.get(obj);
        if (lookup) {
            return lookup;
        }
    }
    else {
        seen = new Map();
    }

    // Built-in object types

    const baseProto = Types.getInternalProto(obj);
    if (baseProto === Types.buffer) {
        return Buffer && Buffer.from(obj);              // $lab:coverage:ignore$
    }

    if (baseProto === Types.date) {
        return new Date(obj.getTime());
    }

    if (baseProto === Types.regex) {
        return new RegExp(obj);
    }

    // Generic objects

    const newObj = internals.base(obj, baseProto, options);
    if (newObj === obj) {
        return obj;
    }

    if (seen) {
        seen.set(obj, newObj);                              // Set seen, since obj could recurse
    }

    if (baseProto === Types.set) {
        for (const value of obj) {
            newObj.add(clone(value, options, seen));
        }
    }
    else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
            newObj.set(key, clone(value, options, seen));
        }
    }

    const keys = Utils.keys(obj, options);
    for (const key of keys) {
        if (key === '__proto__') {
            continue;
        }

        if (baseProto === Types.array &&
            key === 'length') {

            newObj.length = obj.length;
            continue;
        }

        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
            if (descriptor.get ||
                descriptor.set) {

                Object.defineProperty(newObj, key, descriptor);
            }
            else if (descriptor.enumerable) {
                newObj[key] = clone(obj[key], options, seen);
            }
            else {
                Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
            }
        }
        else {
            Object.defineProperty(newObj, key, {
                enumerable: true,
                writable: true,
                configurable: true,
                value: clone(obj[key], options, seen)
            });
        }
    }

    return newObj;
};


internals.cloneWithShallow = function (source, options) {

    const keys = options.shallow;
    options = Object.assign({}, options);
    options.shallow = false;

    const seen = new Map();

    for (const key of keys) {
        const ref = Reach(source, key);
        if (typeof ref === 'object' ||
            typeof ref === 'function') {

            seen.set(ref, ref);
        }
    }

    return internals.clone(source, options, seen);
};


internals.base = function (obj, baseProto, options) {

    if (options.prototype === false) {                  // Defaults to true
        if (internals.needsProtoHack.has(baseProto)) {
            return new baseProto.constructor();
        }

        return baseProto === Types.array ? [] : {};
    }

    const proto = Object.getPrototypeOf(obj);
    if (proto &&
        proto.isImmutable) {

        return obj;
    }

    if (baseProto === Types.array) {
        const newObj = [];
        if (proto !== baseProto) {
            Object.setPrototypeOf(newObj, proto);
        }

        return newObj;
    }

    if (internals.needsProtoHack.has(baseProto)) {
        const newObj = new proto.constructor();
        if (proto !== baseProto) {
            Object.setPrototypeOf(newObj, proto);
        }

        return newObj;
    }

    return Object.create(proto);
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/contain.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/contain.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const DeepEqual = __webpack_require__(/*! ./deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const EscapeRegex = __webpack_require__(/*! ./escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/@hapi/hoek/lib/utils.js");


const internals = {};


module.exports = function (ref, values, options = {}) {        // options: { deep, once, only, part, symbols }

    /*
        string -> string(s)
        array -> item(s)
        object -> key(s)
        object -> object (key:value)
    */

    if (typeof values !== 'object') {
        values = [values];
    }

    Assert(!Array.isArray(values) || values.length, 'Values array cannot be empty');

    // String

    if (typeof ref === 'string') {
        return internals.string(ref, values, options);
    }

    // Array

    if (Array.isArray(ref)) {
        return internals.array(ref, values, options);
    }

    // Object

    Assert(typeof ref === 'object', 'Reference must be string or an object');
    return internals.object(ref, values, options);
};


internals.array = function (ref, values, options) {

    if (!Array.isArray(values)) {
        values = [values];
    }

    if (!ref.length) {
        return false;
    }

    if (options.only &&
        options.once &&
        ref.length !== values.length) {

        return false;
    }

    let compare;

    // Map values

    const map = new Map();
    for (const value of values) {
        if (!options.deep ||
            !value ||
            typeof value !== 'object') {

            const existing = map.get(value);
            if (existing) {
                ++existing.allowed;
            }
            else {
                map.set(value, { allowed: 1, hits: 0 });
            }
        }
        else {
            compare = compare || internals.compare(options);

            let found = false;
            for (const [key, existing] of map.entries()) {
                if (compare(key, value)) {
                    ++existing.allowed;
                    found = true;
                    break;
                }
            }

            if (!found) {
                map.set(value, { allowed: 1, hits: 0 });
            }
        }
    }

    // Lookup values

    let hits = 0;
    for (const item of ref) {
        let match;
        if (!options.deep ||
            !item ||
            typeof item !== 'object') {

            match = map.get(item);
        }
        else {
            compare = compare || internals.compare(options);

            for (const [key, existing] of map.entries()) {
                if (compare(key, item)) {
                    match = existing;
                    break;
                }
            }
        }

        if (match) {
            ++match.hits;
            ++hits;

            if (options.once &&
                match.hits > match.allowed) {

                return false;
            }
        }
    }

    // Validate results

    if (options.only &&
        hits !== ref.length) {

        return false;
    }

    for (const match of map.values()) {
        if (match.hits === match.allowed) {
            continue;
        }

        if (match.hits < match.allowed &&
            !options.part) {

            return false;
        }
    }

    return !!hits;
};


internals.object = function (ref, values, options) {

    Assert(options.once === undefined, 'Cannot use option once with object');

    const keys = Utils.keys(ref, options);
    if (!keys.length) {
        return false;
    }

    // Keys list

    if (Array.isArray(values)) {
        return internals.array(keys, values, options);
    }

    // Key value pairs

    const symbols = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));
    const targets = [...Object.keys(values), ...symbols];

    const compare = internals.compare(options);
    const set = new Set(targets);

    for (const key of keys) {
        if (!set.has(key)) {
            if (options.only) {
                return false;
            }

            continue;
        }

        if (!compare(values[key], ref[key])) {
            return false;
        }

        set.delete(key);
    }

    if (set.size) {
        return options.part ? set.size < targets.length : false;
    }

    return true;
};


internals.string = function (ref, values, options) {

    // Empty string

    if (ref === '') {
        return values.length === 1 && values[0] === '' ||               // '' contains ''
            !options.once && !values.some((v) => v !== '');             // '' contains multiple '' if !once
    }

    // Map values

    const map = new Map();
    const patterns = [];

    for (const value of values) {
        Assert(typeof value === 'string', 'Cannot compare string reference to non-string value');

        if (value) {
            const existing = map.get(value);
            if (existing) {
                ++existing.allowed;
            }
            else {
                map.set(value, { allowed: 1, hits: 0 });
                patterns.push(EscapeRegex(value));
            }
        }
        else if (options.once ||
            options.only) {

            return false;
        }
    }

    if (!patterns.length) {                     // Non-empty string contains unlimited empty string
        return true;
    }

    // Match patterns

    const regex = new RegExp(`(${patterns.join('|')})`, 'g');
    const leftovers = ref.replace(regex, ($0, $1) => {

        ++map.get($1).hits;
        return '';                              // Remove from string
    });

    // Validate results

    if (options.only &&
        leftovers) {

        return false;
    }

    let any = false;
    for (const match of map.values()) {
        if (match.hits) {
            any = true;
        }

        if (match.hits === match.allowed) {
            continue;
        }

        if (match.hits < match.allowed &&
            !options.part) {

            return false;
        }

        // match.hits > match.allowed

        if (options.once) {
            return false;
        }
    }

    return !!any;
};


internals.compare = function (options) {

    if (!options.deep) {
        return internals.shallow;
    }

    const hasOnly = options.only !== undefined;
    const hasPart = options.part !== undefined;

    const flags = {
        prototype: hasOnly ? options.only : hasPart ? !options.part : false,
        part: hasOnly ? !options.only : hasPart ? options.part : false
    };

    return (a, b) => DeepEqual(a, b, flags);
};


internals.shallow = function (a, b) {

    return a === b;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/deepEqual.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/deepEqual.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Types = __webpack_require__(/*! ./types */ "./node_modules/@hapi/hoek/lib/types.js");


const internals = {
    mismatched: null
};


module.exports = function (obj, ref, options) {

    options = Object.assign({ prototype: true }, options);

    return !!internals.isDeepEqual(obj, ref, options, []);
};


internals.isDeepEqual = function (obj, ref, options, seen) {

    if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
        return obj !== 0 || 1 / obj === 1 / ref;
    }

    const type = typeof obj;

    if (type !== typeof ref) {
        return false;
    }

    if (obj === null ||
        ref === null) {

        return false;
    }

    if (type === 'function') {
        if (!options.deepFunction ||
            obj.toString() !== ref.toString()) {

            return false;
        }

        // Continue as object
    }
    else if (type !== 'object') {
        return obj !== obj && ref !== ref;                                  // NaN
    }

    const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
    switch (instanceType) {
        case Types.buffer:
            return Buffer && Buffer.prototype.equals.call(obj, ref);        // $lab:coverage:ignore$
        case Types.promise:
            return obj === ref;
        case Types.regex:
            return obj.toString() === ref.toString();
        case internals.mismatched:
            return false;
    }

    for (let i = seen.length - 1; i >= 0; --i) {
        if (seen[i].isSame(obj, ref)) {
            return true;                                                    // If previous comparison failed, it would have stopped execution
        }
    }

    seen.push(new internals.SeenEntry(obj, ref));

    try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
    }
    finally {
        seen.pop();
    }
};


internals.getSharedType = function (obj, ref, checkPrototype) {

    if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
            return internals.mismatched;
        }

        return Types.getInternalProto(obj);
    }

    const type = Types.getInternalProto(obj);
    if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
    }

    return type;
};


internals.valueOf = function (obj) {

    const objValueOf = obj.valueOf;
    if (objValueOf === undefined) {
        return obj;
    }

    try {
        return objValueOf.call(obj);
    }
    catch (err) {
        return err;
    }
};


internals.hasOwnEnumerableProperty = function (obj, key) {

    return Object.prototype.propertyIsEnumerable.call(obj, key);
};


internals.isSetSimpleEqual = function (obj, ref) {

    for (const entry of Set.prototype.values.call(obj)) {
        if (!Set.prototype.has.call(ref, entry)) {
            return false;
        }
    }

    return true;
};


internals.isDeepEqualObj = function (instanceType, obj, ref, options, seen) {

    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
    const { keys, getOwnPropertySymbols } = Object;

    if (instanceType === Types.array) {
        if (options.part) {

            // Check if any index match any other index

            for (const objValue of obj) {
                for (const refValue of ref) {
                    if (isDeepEqual(objValue, refValue, options, seen)) {
                        return true;
                    }
                }
            }
        }
        else {
            if (obj.length !== ref.length) {
                return false;
            }

            for (let i = 0; i < obj.length; ++i) {
                if (!isDeepEqual(obj[i], ref[i], options, seen)) {
                    return false;
                }
            }

            return true;
        }
    }
    else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
            return false;
        }

        if (!internals.isSetSimpleEqual(obj, ref)) {

            // Check for deep equality

            const ref2 = new Set(Set.prototype.values.call(ref));
            for (const objEntry of Set.prototype.values.call(obj)) {
                if (ref2.delete(objEntry)) {
                    continue;
                }

                let found = false;
                for (const refEntry of ref2) {
                    if (isDeepEqual(objEntry, refEntry, options, seen)) {
                        ref2.delete(refEntry);
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    return false;
                }
            }
        }
    }
    else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
            return false;
        }

        for (const [key, value] of Map.prototype.entries.call(obj)) {
            if (value === undefined && !Map.prototype.has.call(ref, key)) {
                return false;
            }

            if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options, seen)) {
                return false;
            }
        }
    }
    else if (instanceType === Types.error) {

        // Always check name and message

        if (obj.name !== ref.name ||
            obj.message !== ref.message) {

            return false;
        }
    }

    // Check .valueOf()

    const valueOfObj = valueOf(obj);
    const valueOfRef = valueOf(ref);
    if ((obj !== valueOfObj || ref !== valueOfRef) &&
        !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {

        return false;
    }

    // Check properties

    const objKeys = keys(obj);
    if (!options.part &&
        objKeys.length !== keys(ref).length &&
        !options.skip) {

        return false;
    }

    let skipped = 0;
    for (const key of objKeys) {
        if (options.skip &&
            options.skip.includes(key)) {

            if (ref[key] === undefined) {
                ++skipped;
            }

            continue;
        }

        if (!hasOwnEnumerableProperty(ref, key)) {
            return false;
        }

        if (!isDeepEqual(obj[key], ref[key], options, seen)) {
            return false;
        }
    }

    if (!options.part &&
        objKeys.length - skipped !== keys(ref).length) {

        return false;
    }

    // Check symbols

    if (options.symbols !== false) {                                // Defaults to true
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));

        for (const key of objSymbols) {
            if (!options.skip ||
                !options.skip.includes(key)) {

                if (hasOwnEnumerableProperty(obj, key)) {
                    if (!hasOwnEnumerableProperty(ref, key)) {
                        return false;
                    }

                    if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                        return false;
                    }
                }
                else if (hasOwnEnumerableProperty(ref, key)) {
                    return false;
                }
            }

            refSymbols.delete(key);
        }

        for (const key of refSymbols) {
            if (hasOwnEnumerableProperty(ref, key)) {
                return false;
            }
        }
    }

    return true;
};


internals.SeenEntry = class {

    constructor(obj, ref) {

        this.obj = obj;
        this.ref = ref;
    }

    isSame(obj, ref) {

        return this.obj === obj && this.ref === ref;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/error.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/error.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {



const Stringify = __webpack_require__(/*! ./stringify */ "./node_modules/@hapi/hoek/lib/stringify.js");


const internals = {};


module.exports = class extends Error {

    constructor(args) {

        const msgs = args
            .filter((arg) => arg !== '')
            .map((arg) => {

                return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : Stringify(arg);
            });

        super(msgs.join(' ') || 'Unknown error');

        if (typeof Error.captureStackTrace === 'function') {            // $lab:coverage:ignore$
            Error.captureStackTrace(this, exports.assert);
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js":
/*!**************************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");


const internals = {};


module.exports = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    Assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeHtml.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeHtml.js ***!
  \***************************************************/
/***/ ((module) => {



const internals = {};


module.exports = function (input) {

    if (!input) {
        return '';
    }

    let escaped = '';

    for (let i = 0; i < input.length; ++i) {

        const charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeHtmlChar = function (charCode) {

    const namedEscape = internals.namedHtml.get(charCode);
    if (namedEscape) {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    const hexValue = charCode.toString(16).padStart(2, '0');
    return `&#x${hexValue};`;
};


internals.isSafe = function (charCode) {

    return internals.safeCharCodes.has(charCode);
};


internals.namedHtml = new Map([
    [38, '&amp;'],
    [60, '&lt;'],
    [62, '&gt;'],
    [34, '&quot;'],
    [160, '&nbsp;'],
    [162, '&cent;'],
    [163, '&pound;'],
    [164, '&curren;'],
    [169, '&copy;'],
    [174, '&reg;']
]);


internals.safeCharCodes = (function () {

    const safe = new Set();

    for (let i = 32; i < 123; ++i) {

        if ((i >= 97) ||                    // a-z
            (i >= 65 && i <= 90) ||         // A-Z
            (i >= 48 && i <= 57) ||         // 0-9
            i === 32 ||                     // space
            i === 46 ||                     // .
            i === 44 ||                     // ,
            i === 45 ||                     // -
            i === 58 ||                     // :
            i === 95) {                     // _

            safe.add(i);
        }
    }

    return safe;
}());


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeJson.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeJson.js ***!
  \***************************************************/
/***/ ((module) => {



const internals = {};


module.exports = function (input) {

    if (!input) {
        return '';
    }

    return input.replace(/[<>&\u2028\u2029]/g, internals.escape);
};


internals.escape = function (char) {

    return internals.replacements.get(char);
};


internals.replacements = new Map([
    ['<', '\\u003c'],
    ['>', '\\u003e'],
    ['&', '\\u0026'],
    ['\u2028', '\\u2028'],
    ['\u2029', '\\u2029']
]);


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeRegex.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeRegex.js ***!
  \****************************************************/
/***/ ((module) => {



const internals = {};


module.exports = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},

    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/flatten.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/flatten.js ***!
  \************************************************/
/***/ ((module) => {



const internals = {};


module.exports = internals.flatten = function (array, target) {

    const result = target || [];

    for (const entry of array) {
        if (Array.isArray(entry)) {
            internals.flatten(entry, result);
        }
        else {
            result.push(entry);
        }
    }

    return result;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/ignore.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/ignore.js ***!
  \***********************************************/
/***/ ((module) => {



const internals = {};


module.exports = function () { };


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.applyToDefaults = __webpack_require__(/*! ./applyToDefaults */ "./node_modules/@hapi/hoek/lib/applyToDefaults.js");

exports.assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");

exports.Bench = __webpack_require__(/*! ./bench */ "./node_modules/@hapi/hoek/lib/bench.js");

exports.block = __webpack_require__(/*! ./block */ "./node_modules/@hapi/hoek/lib/block.js");

exports.clone = __webpack_require__(/*! ./clone */ "./node_modules/@hapi/hoek/lib/clone.js");

exports.contain = __webpack_require__(/*! ./contain */ "./node_modules/@hapi/hoek/lib/contain.js");

exports.deepEqual = __webpack_require__(/*! ./deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");

exports.Error = __webpack_require__(/*! ./error */ "./node_modules/@hapi/hoek/lib/error.js");

exports.escapeHeaderAttribute = __webpack_require__(/*! ./escapeHeaderAttribute */ "./node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js");

exports.escapeHtml = __webpack_require__(/*! ./escapeHtml */ "./node_modules/@hapi/hoek/lib/escapeHtml.js");

exports.escapeJson = __webpack_require__(/*! ./escapeJson */ "./node_modules/@hapi/hoek/lib/escapeJson.js");

exports.escapeRegex = __webpack_require__(/*! ./escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js");

exports.flatten = __webpack_require__(/*! ./flatten */ "./node_modules/@hapi/hoek/lib/flatten.js");

exports.ignore = __webpack_require__(/*! ./ignore */ "./node_modules/@hapi/hoek/lib/ignore.js");

exports.intersect = __webpack_require__(/*! ./intersect */ "./node_modules/@hapi/hoek/lib/intersect.js");

exports.isPromise = __webpack_require__(/*! ./isPromise */ "./node_modules/@hapi/hoek/lib/isPromise.js");

exports.merge = __webpack_require__(/*! ./merge */ "./node_modules/@hapi/hoek/lib/merge.js");

exports.once = __webpack_require__(/*! ./once */ "./node_modules/@hapi/hoek/lib/once.js");

exports.reach = __webpack_require__(/*! ./reach */ "./node_modules/@hapi/hoek/lib/reach.js");

exports.reachTemplate = __webpack_require__(/*! ./reachTemplate */ "./node_modules/@hapi/hoek/lib/reachTemplate.js");

exports.stringify = __webpack_require__(/*! ./stringify */ "./node_modules/@hapi/hoek/lib/stringify.js");

exports.wait = __webpack_require__(/*! ./wait */ "./node_modules/@hapi/hoek/lib/wait.js");


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/intersect.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/intersect.js ***!
  \**************************************************/
/***/ ((module) => {



const internals = {};


module.exports = function (array1, array2, options = {}) {

    if (!array1 ||
        !array2) {

        return (options.first ? null : []);
    }

    const common = [];
    const hash = (Array.isArray(array1) ? new Set(array1) : array1);
    const found = new Set();
    for (const value of array2) {
        if (internals.has(hash, value) &&
            !found.has(value)) {

            if (options.first) {
                return value;
            }

            common.push(value);
            found.add(value);
        }
    }

    return (options.first ? null : common);
};


internals.has = function (ref, key) {

    if (typeof ref.has === 'function') {
        return ref.has(key);
    }

    return ref[key] !== undefined;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/isPromise.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/isPromise.js ***!
  \**************************************************/
/***/ ((module) => {



const internals = {};


module.exports = function (promise) {

    return !!promise && typeof promise.then === 'function';
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/merge.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/merge.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! ./clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/@hapi/hoek/lib/utils.js");


const internals = {};


module.exports = internals.merge = function (target, source, options) {

    Assert(target && typeof target === 'object', 'Invalid target value: must be an object');
    Assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    options = Object.assign({ nullOverride: true, mergeArrays: true }, options);

    if (Array.isArray(source)) {
        Assert(Array.isArray(target), 'Cannot merge array onto an object');
        if (!options.mergeArrays) {
            target.length = 0;                                                          // Must not change target assignment
        }

        for (let i = 0; i < source.length; ++i) {
            target.push(Clone(source[i], { symbols: options.symbols }));
        }

        return target;
    }

    const keys = Utils.keys(source, options);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === '__proto__' ||
            !Object.prototype.propertyIsEnumerable.call(source, key)) {

            continue;
        }

        const value = source[key];
        if (value &&
            typeof value === 'object') {

            if (target[key] === value) {
                continue;                                           // Can occur for shallow merges
            }

            if (!target[key] ||
                typeof target[key] !== 'object' ||
                (Array.isArray(target[key]) !== Array.isArray(value)) ||
                value instanceof Date ||
                (Buffer && Buffer.isBuffer(value)) ||               // $lab:coverage:ignore$
                value instanceof RegExp) {

                target[key] = Clone(value, { symbols: options.symbols });
            }
            else {
                internals.merge(target[key], value, options);
            }
        }
        else {
            if (value !== null &&
                value !== undefined) {                              // Explicit to preserve empty strings

                target[key] = value;
            }
            else if (options.nullOverride) {
                target[key] = value;
            }
        }
    }

    return target;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/once.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/once.js ***!
  \*********************************************/
/***/ ((module) => {



const internals = {
    wrapped: Symbol('wrapped')
};


module.exports = function (method) {

    if (method[internals.wrapped]) {
        return method;
    }

    let once = false;
    const wrappedFn = function (...args) {

        if (!once) {
            once = true;
            method(...args);
        }
    };

    wrappedFn[internals.wrapped] = true;
    return wrappedFn;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/reach.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/reach.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");


const internals = {};


module.exports = function (obj, chain, options) {

    if (chain === false ||
        chain === null ||
        chain === undefined) {

        return obj;
    }

    options = options || {};
    if (typeof options === 'string') {
        options = { separator: options };
    }

    const isChainArray = Array.isArray(chain);

    Assert(!isChainArray || !options.separator, 'Separator option is not valid for array-based chain');

    const path = isChainArray ? chain : chain.split(options.separator || '.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        const type = options.iterables && internals.iterables(ref);

        if (Array.isArray(ref) ||
            type === 'set') {

            const number = Number(key);
            if (Number.isInteger(number)) {
                key = number < 0 ? ref.length + number : number;
            }
        }

        if (!ref ||
            typeof ref === 'function' && options.functions === false ||         // Defaults to true
            !type && ref[key] === undefined) {

            Assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);
            Assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
            ref = options.default;
            break;
        }

        if (!type) {
            ref = ref[key];
        }
        else if (type === 'set') {
            ref = [...ref][key];
        }
        else {  // type === 'map'
            ref = ref.get(key);
        }
    }

    return ref;
};


internals.iterables = function (ref) {

    if (ref instanceof Set) {
        return 'set';
    }

    if (ref instanceof Map) {
        return 'map';
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/reachTemplate.js":
/*!******************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/reachTemplate.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Reach = __webpack_require__(/*! ./reach */ "./node_modules/@hapi/hoek/lib/reach.js");


const internals = {};


module.exports = function (obj, template, options) {

    return template.replace(/{([^{}]+)}/g, ($0, chain) => {

        const value = Reach(obj, chain, options);
        return (value === undefined || value === null ? '' : value);
    });
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/stringify.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/stringify.js ***!
  \**************************************************/
/***/ ((module) => {



const internals = {};


module.exports = function (...args) {

    try {
        return JSON.stringify(...args);
    }
    catch (err) {
        return '[Cannot display object: ' + err.message + ']';
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/types.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/types.js ***!
  \**********************************************/
/***/ ((module, exports) => {



const internals = {};


exports = module.exports = {
    array: Array.prototype,
    buffer: Buffer && Buffer.prototype,             // $lab:coverage:ignore$
    date: Date.prototype,
    error: Error.prototype,
    generic: Object.prototype,
    map: Map.prototype,
    promise: Promise.prototype,
    regex: RegExp.prototype,
    set: Set.prototype,
    weakMap: WeakMap.prototype,
    weakSet: WeakSet.prototype
};


internals.typeMap = new Map([
    ['[object Error]', exports.error],
    ['[object Map]', exports.map],
    ['[object Promise]', exports.promise],
    ['[object Set]', exports.set],
    ['[object WeakMap]', exports.weakMap],
    ['[object WeakSet]', exports.weakSet]
]);


exports.getInternalProto = function (obj) {

    if (Array.isArray(obj)) {
        return exports.array;
    }

    if (Buffer && obj instanceof Buffer) {          // $lab:coverage:ignore$
        return exports.buffer;
    }

    if (obj instanceof Date) {
        return exports.date;
    }

    if (obj instanceof RegExp) {
        return exports.regex;
    }

    if (obj instanceof Error) {
        return exports.error;
    }

    const objName = Object.prototype.toString.call(obj);
    return internals.typeMap.get(objName) || exports.generic;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {



const internals = {};


exports.keys = function (obj, options = {}) {

    return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);  // Defaults to true
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/wait.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/wait.js ***!
  \*********************************************/
/***/ ((module) => {



const internals = {
    maxTimer: 2 ** 31 - 1              // ~25 days
};


module.exports = function (timeout, returnValue, options) {

    if (typeof timeout === 'bigint') {
        timeout = Number(timeout);
    }

    if (timeout >= Number.MAX_SAFE_INTEGER) {         // Thousands of years
        timeout = Infinity;
    }

    if (typeof timeout !== 'number' && timeout !== undefined) {
        throw new TypeError('Timeout must be a number or bigint');
    }

    return new Promise((resolve) => {

        const _setTimeout = options ? options.setTimeout : setTimeout;

        const activate = () => {

            const time = Math.min(timeout, internals.maxTimer);
            timeout -= time;
            _setTimeout(() => (timeout > 0 ? activate() : resolve(returnValue)), time);
        };

        if (timeout !== Infinity) {
            activate();
        }
    });
};


/***/ }),

/***/ "./node_modules/@hapi/topo/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/topo/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");


const internals = {};


exports.Sorter = class {

    constructor() {

        this._items = [];
        this.nodes = [];
    }

    add(nodes, options) {

        options = options || {};

        // Validate rules

        const before = [].concat(options.before || []);
        const after = [].concat(options.after || []);
        const group = options.group || '?';
        const sort = options.sort || 0;                   // Used for merging only

        Assert(!before.includes(group), `Item cannot come before itself: ${group}`);
        Assert(!before.includes('?'), 'Item cannot come before unassociated items');
        Assert(!after.includes(group), `Item cannot come after itself: ${group}`);
        Assert(!after.includes('?'), 'Item cannot come after unassociated items');

        if (!Array.isArray(nodes)) {
            nodes = [nodes];
        }

        for (const node of nodes) {
            const item = {
                seq: this._items.length,
                sort,
                before,
                after,
                group,
                node
            };

            this._items.push(item);
        }

        // Insert event

        if (!options.manual) {
            const valid = this._sort();
            Assert(valid, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');
        }

        return this.nodes;
    }

    merge(others) {

        if (!Array.isArray(others)) {
            others = [others];
        }

        for (const other of others) {
            if (other) {
                for (const item of other._items) {
                    this._items.push(Object.assign({}, item));      // Shallow cloned
                }
            }
        }

        // Sort items

        this._items.sort(internals.mergeSort);
        for (let i = 0; i < this._items.length; ++i) {
            this._items[i].seq = i;
        }

        const valid = this._sort();
        Assert(valid, 'merge created a dependencies error');

        return this.nodes;
    }

    sort() {

        const valid = this._sort();
        Assert(valid, 'sort created a dependencies error');

        return this.nodes;
    }

    _sort() {

        // Construct graph

        const graph = {};
        const graphAfters = Object.create(null);            // A prototype can bungle lookups w/ false positives
        const groups = Object.create(null);

        for (const item of this._items) {
            const seq = item.seq;                           // Unique across all items
            const group = item.group;

            // Determine Groups

            groups[group] = groups[group] || [];
            groups[group].push(seq);

            // Build intermediary graph using 'before'

            graph[seq] = item.before;

            // Build second intermediary graph with 'after'

            for (const after of item.after) {
                graphAfters[after] = graphAfters[after] || [];
                graphAfters[after].push(seq);
            }
        }

        // Expand intermediary graph

        for (const node in graph) {
            const expandedGroups = [];

            for (const graphNodeItem in graph[node]) {
                const group = graph[node][graphNodeItem];
                groups[group] = groups[group] || [];
                expandedGroups.push(...groups[group]);
            }

            graph[node] = expandedGroups;
        }

        // Merge intermediary graph using graphAfters into final graph

        for (const group in graphAfters) {
            if (groups[group]) {
                for (const node of groups[group]) {
                    graph[node].push(...graphAfters[group]);
                }
            }
        }

        // Compile ancestors

        const ancestors = {};
        for (const node in graph) {
            const children = graph[node];
            for (const child of children) {
                ancestors[child] = ancestors[child] || [];
                ancestors[child].push(node);
            }
        }

        // Topo sort

        const visited = {};
        const sorted = [];

        for (let i = 0; i < this._items.length; ++i) {          // Looping through item.seq values out of order
            let next = i;

            if (ancestors[i]) {
                next = null;
                for (let j = 0; j < this._items.length; ++j) {  // As above, these are item.seq values
                    if (visited[j] === true) {
                        continue;
                    }

                    if (!ancestors[j]) {
                        ancestors[j] = [];
                    }

                    const shouldSeeCount = ancestors[j].length;
                    let seenCount = 0;
                    for (let k = 0; k < shouldSeeCount; ++k) {
                        if (visited[ancestors[j][k]]) {
                            ++seenCount;
                        }
                    }

                    if (seenCount === shouldSeeCount) {
                        next = j;
                        break;
                    }
                }
            }

            if (next !== null) {
                visited[next] = true;
                sorted.push(next);
            }
        }

        if (sorted.length !== this._items.length) {
            return false;
        }

        const seqIndex = {};
        for (const item of this._items) {
            seqIndex[item.seq] = item;
        }

        this._items = [];
        this.nodes = [];

        for (const value of sorted) {
            const sortedItem = seqIndex[value];
            this.nodes.push(sortedItem.node);
            this._items.push(sortedItem);
        }

        return true;
    }
};


internals.mergeSort = (a, b) => {

    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);
};


/***/ }),

/***/ "./node_modules/@sideway/address/lib/domain.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sideway/address/lib/domain.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Url = __webpack_require__(/*! url */ "url");

const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@sideway/address/lib/errors.js");


const internals = {
    minDomainSegments: 2,
    nonAsciiRx: /[^\x00-\x7f]/,
    domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,                          // Control + space + separators
    tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
    domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
    URL: Url.URL || URL                                                                 // $lab:coverage:ignore$
};


exports.analyze = function (domain, options = {}) {

    if (!domain) {                                                                      // Catch null / undefined
        return Errors.code('DOMAIN_NON_EMPTY_STRING');
    }

    if (typeof domain !== 'string') {
        throw new Error('Invalid input: domain must be a string');
    }

    if (domain.length > 256) {
        return Errors.code('DOMAIN_TOO_LONG');
    }

    const ascii = !internals.nonAsciiRx.test(domain);
    if (!ascii) {
        if (options.allowUnicode === false) {                                           // Defaults to true
            return Errors.code('DOMAIN_INVALID_UNICODE_CHARS');
        }

        domain = domain.normalize('NFC');
    }

    if (internals.domainControlRx.test(domain)) {
        return Errors.code('DOMAIN_INVALID_CHARS');
    }

    domain = internals.punycode(domain);

    // https://tools.ietf.org/html/rfc1035 section 2.3.1

    if (options.allowFullyQualified &&
        domain[domain.length - 1] === '.') {

        domain = domain.slice(0, -1);
    }

    const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;

    const segments = domain.split('.');
    if (segments.length < minDomainSegments) {
        return Errors.code('DOMAIN_SEGMENTS_COUNT');
    }

    if (options.maxDomainSegments) {
        if (segments.length > options.maxDomainSegments) {
            return Errors.code('DOMAIN_SEGMENTS_COUNT_MAX');
        }
    }

    const tlds = options.tlds;
    if (tlds) {
        const tld = segments[segments.length - 1].toLowerCase();
        if (tlds.deny && tlds.deny.has(tld) ||
            tlds.allow && !tlds.allow.has(tld)) {

            return Errors.code('DOMAIN_FORBIDDEN_TLDS');
        }
    }

    for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];

        if (!segment.length) {
            return Errors.code('DOMAIN_EMPTY_SEGMENT');
        }

        if (segment.length > 63) {
            return Errors.code('DOMAIN_LONG_SEGMENT');
        }

        if (i < segments.length - 1) {
            if (!internals.domainSegmentRx.test(segment)) {
                return Errors.code('DOMAIN_INVALID_CHARS');
            }
        }
        else {
            if (!internals.tldSegmentRx.test(segment)) {
                return Errors.code('DOMAIN_INVALID_TLDS_CHARS');
            }
        }
    }

    return null;
};


exports.isValid = function (domain, options) {

    return !exports.analyze(domain, options);
};


internals.punycode = function (domain) {

    if (domain.includes('%')) {
        domain = domain.replace(/%/g, '%25');
    }

    try {
        return new internals.URL(`http://${domain}`).host;
    }
    catch (err) {
        return domain;
    }
};


/***/ }),

/***/ "./node_modules/@sideway/address/lib/email.js":
/*!****************************************************!*\
  !*** ./node_modules/@sideway/address/lib/email.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Util = __webpack_require__(/*! util */ "util");

const Domain = __webpack_require__(/*! ./domain */ "./node_modules/@sideway/address/lib/domain.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@sideway/address/lib/errors.js");


const internals = {
    nonAsciiRx: /[^\x00-\x7f]/,
    encoder: new (Util.TextEncoder || TextEncoder)()                                            // $lab:coverage:ignore$
};


exports.analyze = function (email, options) {

    return internals.email(email, options);
};


exports.isValid = function (email, options) {

    return !internals.email(email, options);
};


internals.email = function (email, options = {}) {

    if (typeof email !== 'string') {
        throw new Error('Invalid input: email must be a string');
    }

    if (!email) {
        return Errors.code('EMPTY_STRING');
    }

    // Unicode

    const ascii = !internals.nonAsciiRx.test(email);
    if (!ascii) {
        if (options.allowUnicode === false) {                                                   // Defaults to true
            return Errors.code('FORBIDDEN_UNICODE');
        }

        email = email.normalize('NFC');
    }

    // Basic structure

    const parts = email.split('@');
    if (parts.length !== 2) {
        return parts.length > 2 ? Errors.code('MULTIPLE_AT_CHAR') : Errors.code('MISSING_AT_CHAR');
    }

    const [local, domain] = parts;

    if (!local) {
        return Errors.code('EMPTY_LOCAL');
    }

    if (!options.ignoreLength) {
        if (email.length > 254) {                                           // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3
            return Errors.code('ADDRESS_TOO_LONG');
        }

        if (internals.encoder.encode(local).length > 64) {                  // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1
            return Errors.code('LOCAL_TOO_LONG');
        }
    }

    // Validate parts

    return internals.local(local, ascii) || Domain.analyze(domain, options);
};


internals.local = function (local, ascii) {

    const segments = local.split('.');
    for (const segment of segments) {
        if (!segment.length) {
            return Errors.code('EMPTY_LOCAL_SEGMENT');
        }

        if (ascii) {
            if (!internals.atextRx.test(segment)) {
                return Errors.code('INVALID_LOCAL_CHARS');
            }

            continue;
        }

        for (const char of segment) {
            if (internals.atextRx.test(char)) {
                continue;
            }

            const binary = internals.binary(char);
            if (!internals.atomRx.test(binary)) {
                return Errors.code('INVALID_LOCAL_CHARS');
            }
        }
    }
};


internals.binary = function (char) {

    return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join('');
};


/*
    From RFC 5321:

        Mailbox         =   Local-part "@" ( Domain / address-literal )

        Local-part      =   Dot-string / Quoted-string
        Dot-string      =   Atom *("."  Atom)
        Atom            =   1*atext
        atext           =   ALPHA / DIGIT / "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "/" / "=" / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~"

        Domain          =   sub-domain *("." sub-domain)
        sub-domain      =   Let-dig [Ldh-str]
        Let-dig         =   ALPHA / DIGIT
        Ldh-str         =   *( ALPHA / DIGIT / "-" ) Let-dig

        ALPHA           =   %x41-5A / %x61-7A        ; a-z, A-Z
        DIGIT           =   %x30-39                  ; 0-9

    From RFC 6531:

        sub-domain      =/  U-label
        atext           =/  UTF8-non-ascii

        UTF8-non-ascii  =   UTF8-2 / UTF8-3 / UTF8-4

        UTF8-2          =   %xC2-DF UTF8-tail
        UTF8-3          =   %xE0 %xA0-BF UTF8-tail /
                            %xE1-EC 2( UTF8-tail ) /
                            %xED %x80-9F UTF8-tail /
                            %xEE-EF 2( UTF8-tail )
        UTF8-4          =   %xF0 %x90-BF 2( UTF8-tail ) /
                            %xF1-F3 3( UTF8-tail ) /
                            %xF4 %x80-8F 2( UTF8-tail )

        UTF8-tail       =   %x80-BF

    Note: The following are not supported:

        RFC 5321: address-literal, Quoted-string
        RFC 5322: obs-*, CFWS
*/


internals.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;               // _ included in \w


internals.atomRx = new RegExp([

    //  %xC2-DF UTF8-tail
    '(?:[\\xc2-\\xdf][\\x80-\\xbf])',

    //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )
    '(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})',

    //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )
    '(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})'

].join('|'));


/***/ }),

/***/ "./node_modules/@sideway/address/lib/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sideway/address/lib/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {



exports.codes = {
    EMPTY_STRING: 'Address must be a non-empty string',
    FORBIDDEN_UNICODE: 'Address contains forbidden Unicode characters',
    MULTIPLE_AT_CHAR: 'Address cannot contain more than one @ character',
    MISSING_AT_CHAR: 'Address must contain one @ character',
    EMPTY_LOCAL: 'Address local part cannot be empty',
    ADDRESS_TOO_LONG: 'Address too long',
    LOCAL_TOO_LONG: 'Address local part too long',
    EMPTY_LOCAL_SEGMENT: 'Address local part contains empty dot-separated segment',
    INVALID_LOCAL_CHARS: 'Address local part contains invalid character',
    DOMAIN_NON_EMPTY_STRING: 'Domain must be a non-empty string',
    DOMAIN_TOO_LONG: 'Domain too long',
    DOMAIN_INVALID_UNICODE_CHARS: 'Domain contains forbidden Unicode characters',
    DOMAIN_INVALID_CHARS: 'Domain contains invalid character',
    DOMAIN_INVALID_TLDS_CHARS: 'Domain contains invalid tld character',
    DOMAIN_SEGMENTS_COUNT: 'Domain lacks the minimum required number of segments',
    DOMAIN_SEGMENTS_COUNT_MAX: 'Domain contains too many segments',
    DOMAIN_FORBIDDEN_TLDS: 'Domain uses forbidden TLD',
    DOMAIN_EMPTY_SEGMENT: 'Domain contains empty dot-separated segment',
    DOMAIN_LONG_SEGMENT: 'Domain contains dot-separated segment that is too long'
};


exports.code = function (code) {

    return { code, error: exports.codes[code] };
};


/***/ }),

/***/ "./node_modules/@sideway/address/lib/ip.js":
/*!*************************************************!*\
  !*** ./node_modules/@sideway/address/lib/ip.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Uri = __webpack_require__(/*! ./uri */ "./node_modules/@sideway/address/lib/uri.js");


const internals = {};


exports.regex = function (options = {}) {

    // CIDR

    Assert(options.cidr === undefined || typeof options.cidr === 'string', 'options.cidr must be a string');
    const cidr = options.cidr ? options.cidr.toLowerCase() : 'optional';
    Assert(['required', 'optional', 'forbidden'].includes(cidr), 'options.cidr must be one of required, optional, forbidden');

    // Versions

    Assert(options.version === undefined || typeof options.version === 'string' || Array.isArray(options.version), 'options.version must be a string or an array of string');
    let versions = options.version || ['ipv4', 'ipv6', 'ipvfuture'];
    if (!Array.isArray(versions)) {
        versions = [versions];
    }

    Assert(versions.length >= 1, 'options.version must have at least 1 version specified');

    for (let i = 0; i < versions.length; ++i) {
        Assert(typeof versions[i] === 'string', 'options.version must only contain strings');
        versions[i] = versions[i].toLowerCase();
        Assert(['ipv4', 'ipv6', 'ipvfuture'].includes(versions[i]), 'options.version contains unknown version ' + versions[i] + ' - must be one of ipv4, ipv6, ipvfuture');
    }

    versions = Array.from(new Set(versions));

    // Regex

    const parts = versions.map((version) => {

        // Forbidden

        if (cidr === 'forbidden') {
            return Uri.ip[version];
        }

        // Required

        const cidrpart = `\\/${version === 'ipv4' ? Uri.ip.v4Cidr : Uri.ip.v6Cidr}`;

        if (cidr === 'required') {
            return `${Uri.ip[version]}${cidrpart}`;
        }

        // Optional

        return `${Uri.ip[version]}(?:${cidrpart})?`;
    });

    const raw = `(?:${parts.join('|')})`;
    const regex = new RegExp(`^${raw}$`);
    return { cidr, versions, regex, raw };
};


/***/ }),

/***/ "./node_modules/@sideway/address/lib/tlds.js":
/*!***************************************************!*\
  !*** ./node_modules/@sideway/address/lib/tlds.js ***!
  \***************************************************/
/***/ ((module) => {



const internals = {};


// http://data.iana.org/TLD/tlds-alpha-by-domain.txt
// # Version 2022032102, Last Updated Tue Mar 22 07:07:01 2022 UTC


internals.tlds = [
    'AAA',
    'AARP',
    'ABARTH',
    'ABB',
    'ABBOTT',
    'ABBVIE',
    'ABC',
    'ABLE',
    'ABOGADO',
    'ABUDHABI',
    'AC',
    'ACADEMY',
    'ACCENTURE',
    'ACCOUNTANT',
    'ACCOUNTANTS',
    'ACO',
    'ACTOR',
    'AD',
    'ADAC',
    'ADS',
    'ADULT',
    'AE',
    'AEG',
    'AERO',
    'AETNA',
    'AF',
    'AFL',
    'AFRICA',
    'AG',
    'AGAKHAN',
    'AGENCY',
    'AI',
    'AIG',
    'AIRBUS',
    'AIRFORCE',
    'AIRTEL',
    'AKDN',
    'AL',
    'ALFAROMEO',
    'ALIBABA',
    'ALIPAY',
    'ALLFINANZ',
    'ALLSTATE',
    'ALLY',
    'ALSACE',
    'ALSTOM',
    'AM',
    'AMAZON',
    'AMERICANEXPRESS',
    'AMERICANFAMILY',
    'AMEX',
    'AMFAM',
    'AMICA',
    'AMSTERDAM',
    'ANALYTICS',
    'ANDROID',
    'ANQUAN',
    'ANZ',
    'AO',
    'AOL',
    'APARTMENTS',
    'APP',
    'APPLE',
    'AQ',
    'AQUARELLE',
    'AR',
    'ARAB',
    'ARAMCO',
    'ARCHI',
    'ARMY',
    'ARPA',
    'ART',
    'ARTE',
    'AS',
    'ASDA',
    'ASIA',
    'ASSOCIATES',
    'AT',
    'ATHLETA',
    'ATTORNEY',
    'AU',
    'AUCTION',
    'AUDI',
    'AUDIBLE',
    'AUDIO',
    'AUSPOST',
    'AUTHOR',
    'AUTO',
    'AUTOS',
    'AVIANCA',
    'AW',
    'AWS',
    'AX',
    'AXA',
    'AZ',
    'AZURE',
    'BA',
    'BABY',
    'BAIDU',
    'BANAMEX',
    'BANANAREPUBLIC',
    'BAND',
    'BANK',
    'BAR',
    'BARCELONA',
    'BARCLAYCARD',
    'BARCLAYS',
    'BAREFOOT',
    'BARGAINS',
    'BASEBALL',
    'BASKETBALL',
    'BAUHAUS',
    'BAYERN',
    'BB',
    'BBC',
    'BBT',
    'BBVA',
    'BCG',
    'BCN',
    'BD',
    'BE',
    'BEATS',
    'BEAUTY',
    'BEER',
    'BENTLEY',
    'BERLIN',
    'BEST',
    'BESTBUY',
    'BET',
    'BF',
    'BG',
    'BH',
    'BHARTI',
    'BI',
    'BIBLE',
    'BID',
    'BIKE',
    'BING',
    'BINGO',
    'BIO',
    'BIZ',
    'BJ',
    'BLACK',
    'BLACKFRIDAY',
    'BLOCKBUSTER',
    'BLOG',
    'BLOOMBERG',
    'BLUE',
    'BM',
    'BMS',
    'BMW',
    'BN',
    'BNPPARIBAS',
    'BO',
    'BOATS',
    'BOEHRINGER',
    'BOFA',
    'BOM',
    'BOND',
    'BOO',
    'BOOK',
    'BOOKING',
    'BOSCH',
    'BOSTIK',
    'BOSTON',
    'BOT',
    'BOUTIQUE',
    'BOX',
    'BR',
    'BRADESCO',
    'BRIDGESTONE',
    'BROADWAY',
    'BROKER',
    'BROTHER',
    'BRUSSELS',
    'BS',
    'BT',
    'BUGATTI',
    'BUILD',
    'BUILDERS',
    'BUSINESS',
    'BUY',
    'BUZZ',
    'BV',
    'BW',
    'BY',
    'BZ',
    'BZH',
    'CA',
    'CAB',
    'CAFE',
    'CAL',
    'CALL',
    'CALVINKLEIN',
    'CAM',
    'CAMERA',
    'CAMP',
    'CANCERRESEARCH',
    'CANON',
    'CAPETOWN',
    'CAPITAL',
    'CAPITALONE',
    'CAR',
    'CARAVAN',
    'CARDS',
    'CARE',
    'CAREER',
    'CAREERS',
    'CARS',
    'CASA',
    'CASE',
    'CASH',
    'CASINO',
    'CAT',
    'CATERING',
    'CATHOLIC',
    'CBA',
    'CBN',
    'CBRE',
    'CBS',
    'CC',
    'CD',
    'CENTER',
    'CEO',
    'CERN',
    'CF',
    'CFA',
    'CFD',
    'CG',
    'CH',
    'CHANEL',
    'CHANNEL',
    'CHARITY',
    'CHASE',
    'CHAT',
    'CHEAP',
    'CHINTAI',
    'CHRISTMAS',
    'CHROME',
    'CHURCH',
    'CI',
    'CIPRIANI',
    'CIRCLE',
    'CISCO',
    'CITADEL',
    'CITI',
    'CITIC',
    'CITY',
    'CITYEATS',
    'CK',
    'CL',
    'CLAIMS',
    'CLEANING',
    'CLICK',
    'CLINIC',
    'CLINIQUE',
    'CLOTHING',
    'CLOUD',
    'CLUB',
    'CLUBMED',
    'CM',
    'CN',
    'CO',
    'COACH',
    'CODES',
    'COFFEE',
    'COLLEGE',
    'COLOGNE',
    'COM',
    'COMCAST',
    'COMMBANK',
    'COMMUNITY',
    'COMPANY',
    'COMPARE',
    'COMPUTER',
    'COMSEC',
    'CONDOS',
    'CONSTRUCTION',
    'CONSULTING',
    'CONTACT',
    'CONTRACTORS',
    'COOKING',
    'COOKINGCHANNEL',
    'COOL',
    'COOP',
    'CORSICA',
    'COUNTRY',
    'COUPON',
    'COUPONS',
    'COURSES',
    'CPA',
    'CR',
    'CREDIT',
    'CREDITCARD',
    'CREDITUNION',
    'CRICKET',
    'CROWN',
    'CRS',
    'CRUISE',
    'CRUISES',
    'CU',
    'CUISINELLA',
    'CV',
    'CW',
    'CX',
    'CY',
    'CYMRU',
    'CYOU',
    'CZ',
    'DABUR',
    'DAD',
    'DANCE',
    'DATA',
    'DATE',
    'DATING',
    'DATSUN',
    'DAY',
    'DCLK',
    'DDS',
    'DE',
    'DEAL',
    'DEALER',
    'DEALS',
    'DEGREE',
    'DELIVERY',
    'DELL',
    'DELOITTE',
    'DELTA',
    'DEMOCRAT',
    'DENTAL',
    'DENTIST',
    'DESI',
    'DESIGN',
    'DEV',
    'DHL',
    'DIAMONDS',
    'DIET',
    'DIGITAL',
    'DIRECT',
    'DIRECTORY',
    'DISCOUNT',
    'DISCOVER',
    'DISH',
    'DIY',
    'DJ',
    'DK',
    'DM',
    'DNP',
    'DO',
    'DOCS',
    'DOCTOR',
    'DOG',
    'DOMAINS',
    'DOT',
    'DOWNLOAD',
    'DRIVE',
    'DTV',
    'DUBAI',
    'DUNLOP',
    'DUPONT',
    'DURBAN',
    'DVAG',
    'DVR',
    'DZ',
    'EARTH',
    'EAT',
    'EC',
    'ECO',
    'EDEKA',
    'EDU',
    'EDUCATION',
    'EE',
    'EG',
    'EMAIL',
    'EMERCK',
    'ENERGY',
    'ENGINEER',
    'ENGINEERING',
    'ENTERPRISES',
    'EPSON',
    'EQUIPMENT',
    'ER',
    'ERICSSON',
    'ERNI',
    'ES',
    'ESQ',
    'ESTATE',
    'ET',
    'ETISALAT',
    'EU',
    'EUROVISION',
    'EUS',
    'EVENTS',
    'EXCHANGE',
    'EXPERT',
    'EXPOSED',
    'EXPRESS',
    'EXTRASPACE',
    'FAGE',
    'FAIL',
    'FAIRWINDS',
    'FAITH',
    'FAMILY',
    'FAN',
    'FANS',
    'FARM',
    'FARMERS',
    'FASHION',
    'FAST',
    'FEDEX',
    'FEEDBACK',
    'FERRARI',
    'FERRERO',
    'FI',
    'FIAT',
    'FIDELITY',
    'FIDO',
    'FILM',
    'FINAL',
    'FINANCE',
    'FINANCIAL',
    'FIRE',
    'FIRESTONE',
    'FIRMDALE',
    'FISH',
    'FISHING',
    'FIT',
    'FITNESS',
    'FJ',
    'FK',
    'FLICKR',
    'FLIGHTS',
    'FLIR',
    'FLORIST',
    'FLOWERS',
    'FLY',
    'FM',
    'FO',
    'FOO',
    'FOOD',
    'FOODNETWORK',
    'FOOTBALL',
    'FORD',
    'FOREX',
    'FORSALE',
    'FORUM',
    'FOUNDATION',
    'FOX',
    'FR',
    'FREE',
    'FRESENIUS',
    'FRL',
    'FROGANS',
    'FRONTDOOR',
    'FRONTIER',
    'FTR',
    'FUJITSU',
    'FUN',
    'FUND',
    'FURNITURE',
    'FUTBOL',
    'FYI',
    'GA',
    'GAL',
    'GALLERY',
    'GALLO',
    'GALLUP',
    'GAME',
    'GAMES',
    'GAP',
    'GARDEN',
    'GAY',
    'GB',
    'GBIZ',
    'GD',
    'GDN',
    'GE',
    'GEA',
    'GENT',
    'GENTING',
    'GEORGE',
    'GF',
    'GG',
    'GGEE',
    'GH',
    'GI',
    'GIFT',
    'GIFTS',
    'GIVES',
    'GIVING',
    'GL',
    'GLASS',
    'GLE',
    'GLOBAL',
    'GLOBO',
    'GM',
    'GMAIL',
    'GMBH',
    'GMO',
    'GMX',
    'GN',
    'GODADDY',
    'GOLD',
    'GOLDPOINT',
    'GOLF',
    'GOO',
    'GOODYEAR',
    'GOOG',
    'GOOGLE',
    'GOP',
    'GOT',
    'GOV',
    'GP',
    'GQ',
    'GR',
    'GRAINGER',
    'GRAPHICS',
    'GRATIS',
    'GREEN',
    'GRIPE',
    'GROCERY',
    'GROUP',
    'GS',
    'GT',
    'GU',
    'GUARDIAN',
    'GUCCI',
    'GUGE',
    'GUIDE',
    'GUITARS',
    'GURU',
    'GW',
    'GY',
    'HAIR',
    'HAMBURG',
    'HANGOUT',
    'HAUS',
    'HBO',
    'HDFC',
    'HDFCBANK',
    'HEALTH',
    'HEALTHCARE',
    'HELP',
    'HELSINKI',
    'HERE',
    'HERMES',
    'HGTV',
    'HIPHOP',
    'HISAMITSU',
    'HITACHI',
    'HIV',
    'HK',
    'HKT',
    'HM',
    'HN',
    'HOCKEY',
    'HOLDINGS',
    'HOLIDAY',
    'HOMEDEPOT',
    'HOMEGOODS',
    'HOMES',
    'HOMESENSE',
    'HONDA',
    'HORSE',
    'HOSPITAL',
    'HOST',
    'HOSTING',
    'HOT',
    'HOTELES',
    'HOTELS',
    'HOTMAIL',
    'HOUSE',
    'HOW',
    'HR',
    'HSBC',
    'HT',
    'HU',
    'HUGHES',
    'HYATT',
    'HYUNDAI',
    'IBM',
    'ICBC',
    'ICE',
    'ICU',
    'ID',
    'IE',
    'IEEE',
    'IFM',
    'IKANO',
    'IL',
    'IM',
    'IMAMAT',
    'IMDB',
    'IMMO',
    'IMMOBILIEN',
    'IN',
    'INC',
    'INDUSTRIES',
    'INFINITI',
    'INFO',
    'ING',
    'INK',
    'INSTITUTE',
    'INSURANCE',
    'INSURE',
    'INT',
    'INTERNATIONAL',
    'INTUIT',
    'INVESTMENTS',
    'IO',
    'IPIRANGA',
    'IQ',
    'IR',
    'IRISH',
    'IS',
    'ISMAILI',
    'IST',
    'ISTANBUL',
    'IT',
    'ITAU',
    'ITV',
    'JAGUAR',
    'JAVA',
    'JCB',
    'JE',
    'JEEP',
    'JETZT',
    'JEWELRY',
    'JIO',
    'JLL',
    'JM',
    'JMP',
    'JNJ',
    'JO',
    'JOBS',
    'JOBURG',
    'JOT',
    'JOY',
    'JP',
    'JPMORGAN',
    'JPRS',
    'JUEGOS',
    'JUNIPER',
    'KAUFEN',
    'KDDI',
    'KE',
    'KERRYHOTELS',
    'KERRYLOGISTICS',
    'KERRYPROPERTIES',
    'KFH',
    'KG',
    'KH',
    'KI',
    'KIA',
    'KIM',
    'KINDER',
    'KINDLE',
    'KITCHEN',
    'KIWI',
    'KM',
    'KN',
    'KOELN',
    'KOMATSU',
    'KOSHER',
    'KP',
    'KPMG',
    'KPN',
    'KR',
    'KRD',
    'KRED',
    'KUOKGROUP',
    'KW',
    'KY',
    'KYOTO',
    'KZ',
    'LA',
    'LACAIXA',
    'LAMBORGHINI',
    'LAMER',
    'LANCASTER',
    'LANCIA',
    'LAND',
    'LANDROVER',
    'LANXESS',
    'LASALLE',
    'LAT',
    'LATINO',
    'LATROBE',
    'LAW',
    'LAWYER',
    'LB',
    'LC',
    'LDS',
    'LEASE',
    'LECLERC',
    'LEFRAK',
    'LEGAL',
    'LEGO',
    'LEXUS',
    'LGBT',
    'LI',
    'LIDL',
    'LIFE',
    'LIFEINSURANCE',
    'LIFESTYLE',
    'LIGHTING',
    'LIKE',
    'LILLY',
    'LIMITED',
    'LIMO',
    'LINCOLN',
    'LINDE',
    'LINK',
    'LIPSY',
    'LIVE',
    'LIVING',
    'LK',
    'LLC',
    'LLP',
    'LOAN',
    'LOANS',
    'LOCKER',
    'LOCUS',
    'LOFT',
    'LOL',
    'LONDON',
    'LOTTE',
    'LOTTO',
    'LOVE',
    'LPL',
    'LPLFINANCIAL',
    'LR',
    'LS',
    'LT',
    'LTD',
    'LTDA',
    'LU',
    'LUNDBECK',
    'LUXE',
    'LUXURY',
    'LV',
    'LY',
    'MA',
    'MACYS',
    'MADRID',
    'MAIF',
    'MAISON',
    'MAKEUP',
    'MAN',
    'MANAGEMENT',
    'MANGO',
    'MAP',
    'MARKET',
    'MARKETING',
    'MARKETS',
    'MARRIOTT',
    'MARSHALLS',
    'MASERATI',
    'MATTEL',
    'MBA',
    'MC',
    'MCKINSEY',
    'MD',
    'ME',
    'MED',
    'MEDIA',
    'MEET',
    'MELBOURNE',
    'MEME',
    'MEMORIAL',
    'MEN',
    'MENU',
    'MERCKMSD',
    'MG',
    'MH',
    'MIAMI',
    'MICROSOFT',
    'MIL',
    'MINI',
    'MINT',
    'MIT',
    'MITSUBISHI',
    'MK',
    'ML',
    'MLB',
    'MLS',
    'MM',
    'MMA',
    'MN',
    'MO',
    'MOBI',
    'MOBILE',
    'MODA',
    'MOE',
    'MOI',
    'MOM',
    'MONASH',
    'MONEY',
    'MONSTER',
    'MORMON',
    'MORTGAGE',
    'MOSCOW',
    'MOTO',
    'MOTORCYCLES',
    'MOV',
    'MOVIE',
    'MP',
    'MQ',
    'MR',
    'MS',
    'MSD',
    'MT',
    'MTN',
    'MTR',
    'MU',
    'MUSEUM',
    'MUSIC',
    'MUTUAL',
    'MV',
    'MW',
    'MX',
    'MY',
    'MZ',
    'NA',
    'NAB',
    'NAGOYA',
    'NAME',
    'NATURA',
    'NAVY',
    'NBA',
    'NC',
    'NE',
    'NEC',
    'NET',
    'NETBANK',
    'NETFLIX',
    'NETWORK',
    'NEUSTAR',
    'NEW',
    'NEWS',
    'NEXT',
    'NEXTDIRECT',
    'NEXUS',
    'NF',
    'NFL',
    'NG',
    'NGO',
    'NHK',
    'NI',
    'NICO',
    'NIKE',
    'NIKON',
    'NINJA',
    'NISSAN',
    'NISSAY',
    'NL',
    'NO',
    'NOKIA',
    'NORTHWESTERNMUTUAL',
    'NORTON',
    'NOW',
    'NOWRUZ',
    'NOWTV',
    'NP',
    'NR',
    'NRA',
    'NRW',
    'NTT',
    'NU',
    'NYC',
    'NZ',
    'OBI',
    'OBSERVER',
    'OFFICE',
    'OKINAWA',
    'OLAYAN',
    'OLAYANGROUP',
    'OLDNAVY',
    'OLLO',
    'OM',
    'OMEGA',
    'ONE',
    'ONG',
    'ONL',
    'ONLINE',
    'OOO',
    'OPEN',
    'ORACLE',
    'ORANGE',
    'ORG',
    'ORGANIC',
    'ORIGINS',
    'OSAKA',
    'OTSUKA',
    'OTT',
    'OVH',
    'PA',
    'PAGE',
    'PANASONIC',
    'PARIS',
    'PARS',
    'PARTNERS',
    'PARTS',
    'PARTY',
    'PASSAGENS',
    'PAY',
    'PCCW',
    'PE',
    'PET',
    'PF',
    'PFIZER',
    'PG',
    'PH',
    'PHARMACY',
    'PHD',
    'PHILIPS',
    'PHONE',
    'PHOTO',
    'PHOTOGRAPHY',
    'PHOTOS',
    'PHYSIO',
    'PICS',
    'PICTET',
    'PICTURES',
    'PID',
    'PIN',
    'PING',
    'PINK',
    'PIONEER',
    'PIZZA',
    'PK',
    'PL',
    'PLACE',
    'PLAY',
    'PLAYSTATION',
    'PLUMBING',
    'PLUS',
    'PM',
    'PN',
    'PNC',
    'POHL',
    'POKER',
    'POLITIE',
    'PORN',
    'POST',
    'PR',
    'PRAMERICA',
    'PRAXI',
    'PRESS',
    'PRIME',
    'PRO',
    'PROD',
    'PRODUCTIONS',
    'PROF',
    'PROGRESSIVE',
    'PROMO',
    'PROPERTIES',
    'PROPERTY',
    'PROTECTION',
    'PRU',
    'PRUDENTIAL',
    'PS',
    'PT',
    'PUB',
    'PW',
    'PWC',
    'PY',
    'QA',
    'QPON',
    'QUEBEC',
    'QUEST',
    'RACING',
    'RADIO',
    'RE',
    'READ',
    'REALESTATE',
    'REALTOR',
    'REALTY',
    'RECIPES',
    'RED',
    'REDSTONE',
    'REDUMBRELLA',
    'REHAB',
    'REISE',
    'REISEN',
    'REIT',
    'RELIANCE',
    'REN',
    'RENT',
    'RENTALS',
    'REPAIR',
    'REPORT',
    'REPUBLICAN',
    'REST',
    'RESTAURANT',
    'REVIEW',
    'REVIEWS',
    'REXROTH',
    'RICH',
    'RICHARDLI',
    'RICOH',
    'RIL',
    'RIO',
    'RIP',
    'RO',
    'ROCHER',
    'ROCKS',
    'RODEO',
    'ROGERS',
    'ROOM',
    'RS',
    'RSVP',
    'RU',
    'RUGBY',
    'RUHR',
    'RUN',
    'RW',
    'RWE',
    'RYUKYU',
    'SA',
    'SAARLAND',
    'SAFE',
    'SAFETY',
    'SAKURA',
    'SALE',
    'SALON',
    'SAMSCLUB',
    'SAMSUNG',
    'SANDVIK',
    'SANDVIKCOROMANT',
    'SANOFI',
    'SAP',
    'SARL',
    'SAS',
    'SAVE',
    'SAXO',
    'SB',
    'SBI',
    'SBS',
    'SC',
    'SCA',
    'SCB',
    'SCHAEFFLER',
    'SCHMIDT',
    'SCHOLARSHIPS',
    'SCHOOL',
    'SCHULE',
    'SCHWARZ',
    'SCIENCE',
    'SCOT',
    'SD',
    'SE',
    'SEARCH',
    'SEAT',
    'SECURE',
    'SECURITY',
    'SEEK',
    'SELECT',
    'SENER',
    'SERVICES',
    'SES',
    'SEVEN',
    'SEW',
    'SEX',
    'SEXY',
    'SFR',
    'SG',
    'SH',
    'SHANGRILA',
    'SHARP',
    'SHAW',
    'SHELL',
    'SHIA',
    'SHIKSHA',
    'SHOES',
    'SHOP',
    'SHOPPING',
    'SHOUJI',
    'SHOW',
    'SHOWTIME',
    'SI',
    'SILK',
    'SINA',
    'SINGLES',
    'SITE',
    'SJ',
    'SK',
    'SKI',
    'SKIN',
    'SKY',
    'SKYPE',
    'SL',
    'SLING',
    'SM',
    'SMART',
    'SMILE',
    'SN',
    'SNCF',
    'SO',
    'SOCCER',
    'SOCIAL',
    'SOFTBANK',
    'SOFTWARE',
    'SOHU',
    'SOLAR',
    'SOLUTIONS',
    'SONG',
    'SONY',
    'SOY',
    'SPA',
    'SPACE',
    'SPORT',
    'SPOT',
    'SR',
    'SRL',
    'SS',
    'ST',
    'STADA',
    'STAPLES',
    'STAR',
    'STATEBANK',
    'STATEFARM',
    'STC',
    'STCGROUP',
    'STOCKHOLM',
    'STORAGE',
    'STORE',
    'STREAM',
    'STUDIO',
    'STUDY',
    'STYLE',
    'SU',
    'SUCKS',
    'SUPPLIES',
    'SUPPLY',
    'SUPPORT',
    'SURF',
    'SURGERY',
    'SUZUKI',
    'SV',
    'SWATCH',
    'SWISS',
    'SX',
    'SY',
    'SYDNEY',
    'SYSTEMS',
    'SZ',
    'TAB',
    'TAIPEI',
    'TALK',
    'TAOBAO',
    'TARGET',
    'TATAMOTORS',
    'TATAR',
    'TATTOO',
    'TAX',
    'TAXI',
    'TC',
    'TCI',
    'TD',
    'TDK',
    'TEAM',
    'TECH',
    'TECHNOLOGY',
    'TEL',
    'TEMASEK',
    'TENNIS',
    'TEVA',
    'TF',
    'TG',
    'TH',
    'THD',
    'THEATER',
    'THEATRE',
    'TIAA',
    'TICKETS',
    'TIENDA',
    'TIFFANY',
    'TIPS',
    'TIRES',
    'TIROL',
    'TJ',
    'TJMAXX',
    'TJX',
    'TK',
    'TKMAXX',
    'TL',
    'TM',
    'TMALL',
    'TN',
    'TO',
    'TODAY',
    'TOKYO',
    'TOOLS',
    'TOP',
    'TORAY',
    'TOSHIBA',
    'TOTAL',
    'TOURS',
    'TOWN',
    'TOYOTA',
    'TOYS',
    'TR',
    'TRADE',
    'TRADING',
    'TRAINING',
    'TRAVEL',
    'TRAVELCHANNEL',
    'TRAVELERS',
    'TRAVELERSINSURANCE',
    'TRUST',
    'TRV',
    'TT',
    'TUBE',
    'TUI',
    'TUNES',
    'TUSHU',
    'TV',
    'TVS',
    'TW',
    'TZ',
    'UA',
    'UBANK',
    'UBS',
    'UG',
    'UK',
    'UNICOM',
    'UNIVERSITY',
    'UNO',
    'UOL',
    'UPS',
    'US',
    'UY',
    'UZ',
    'VA',
    'VACATIONS',
    'VANA',
    'VANGUARD',
    'VC',
    'VE',
    'VEGAS',
    'VENTURES',
    'VERISIGN',
    'VERSICHERUNG',
    'VET',
    'VG',
    'VI',
    'VIAJES',
    'VIDEO',
    'VIG',
    'VIKING',
    'VILLAS',
    'VIN',
    'VIP',
    'VIRGIN',
    'VISA',
    'VISION',
    'VIVA',
    'VIVO',
    'VLAANDEREN',
    'VN',
    'VODKA',
    'VOLKSWAGEN',
    'VOLVO',
    'VOTE',
    'VOTING',
    'VOTO',
    'VOYAGE',
    'VU',
    'VUELOS',
    'WALES',
    'WALMART',
    'WALTER',
    'WANG',
    'WANGGOU',
    'WATCH',
    'WATCHES',
    'WEATHER',
    'WEATHERCHANNEL',
    'WEBCAM',
    'WEBER',
    'WEBSITE',
    'WED',
    'WEDDING',
    'WEIBO',
    'WEIR',
    'WF',
    'WHOSWHO',
    'WIEN',
    'WIKI',
    'WILLIAMHILL',
    'WIN',
    'WINDOWS',
    'WINE',
    'WINNERS',
    'WME',
    'WOLTERSKLUWER',
    'WOODSIDE',
    'WORK',
    'WORKS',
    'WORLD',
    'WOW',
    'WS',
    'WTC',
    'WTF',
    'XBOX',
    'XEROX',
    'XFINITY',
    'XIHUAN',
    'XIN',
    'XN--11B4C3D',
    'XN--1CK2E1B',
    'XN--1QQW23A',
    'XN--2SCRJ9C',
    'XN--30RR7Y',
    'XN--3BST00M',
    'XN--3DS443G',
    'XN--3E0B707E',
    'XN--3HCRJ9C',
    'XN--3PXU8K',
    'XN--42C2D9A',
    'XN--45BR5CYL',
    'XN--45BRJ9C',
    'XN--45Q11C',
    'XN--4DBRK0CE',
    'XN--4GBRIM',
    'XN--54B7FTA0CC',
    'XN--55QW42G',
    'XN--55QX5D',
    'XN--5SU34J936BGSG',
    'XN--5TZM5G',
    'XN--6FRZ82G',
    'XN--6QQ986B3XL',
    'XN--80ADXHKS',
    'XN--80AO21A',
    'XN--80AQECDR1A',
    'XN--80ASEHDB',
    'XN--80ASWG',
    'XN--8Y0A063A',
    'XN--90A3AC',
    'XN--90AE',
    'XN--90AIS',
    'XN--9DBQ2A',
    'XN--9ET52U',
    'XN--9KRT00A',
    'XN--B4W605FERD',
    'XN--BCK1B9A5DRE4C',
    'XN--C1AVG',
    'XN--C2BR7G',
    'XN--CCK2B3B',
    'XN--CCKWCXETD',
    'XN--CG4BKI',
    'XN--CLCHC0EA0B2G2A9GCD',
    'XN--CZR694B',
    'XN--CZRS0T',
    'XN--CZRU2D',
    'XN--D1ACJ3B',
    'XN--D1ALF',
    'XN--E1A4C',
    'XN--ECKVDTC9D',
    'XN--EFVY88H',
    'XN--FCT429K',
    'XN--FHBEI',
    'XN--FIQ228C5HS',
    'XN--FIQ64B',
    'XN--FIQS8S',
    'XN--FIQZ9S',
    'XN--FJQ720A',
    'XN--FLW351E',
    'XN--FPCRJ9C3D',
    'XN--FZC2C9E2C',
    'XN--FZYS8D69UVGM',
    'XN--G2XX48C',
    'XN--GCKR3F0F',
    'XN--GECRJ9C',
    'XN--GK3AT1E',
    'XN--H2BREG3EVE',
    'XN--H2BRJ9C',
    'XN--H2BRJ9C8C',
    'XN--HXT814E',
    'XN--I1B6B1A6A2E',
    'XN--IMR513N',
    'XN--IO0A7I',
    'XN--J1AEF',
    'XN--J1AMH',
    'XN--J6W193G',
    'XN--JLQ480N2RG',
    'XN--JLQ61U9W7B',
    'XN--JVR189M',
    'XN--KCRX77D1X4A',
    'XN--KPRW13D',
    'XN--KPRY57D',
    'XN--KPUT3I',
    'XN--L1ACC',
    'XN--LGBBAT1AD8J',
    'XN--MGB9AWBF',
    'XN--MGBA3A3EJT',
    'XN--MGBA3A4F16A',
    'XN--MGBA7C0BBN0A',
    'XN--MGBAAKC7DVF',
    'XN--MGBAAM7A8H',
    'XN--MGBAB2BD',
    'XN--MGBAH1A3HJKRD',
    'XN--MGBAI9AZGQP6J',
    'XN--MGBAYH7GPA',
    'XN--MGBBH1A',
    'XN--MGBBH1A71E',
    'XN--MGBC0A9AZCG',
    'XN--MGBCA7DZDO',
    'XN--MGBCPQ6GPA1A',
    'XN--MGBERP4A5D4AR',
    'XN--MGBGU82A',
    'XN--MGBI4ECEXP',
    'XN--MGBPL2FH',
    'XN--MGBT3DHD',
    'XN--MGBTX2B',
    'XN--MGBX4CD0AB',
    'XN--MIX891F',
    'XN--MK1BU44C',
    'XN--MXTQ1M',
    'XN--NGBC5AZD',
    'XN--NGBE9E0A',
    'XN--NGBRX',
    'XN--NODE',
    'XN--NQV7F',
    'XN--NQV7FS00EMA',
    'XN--NYQY26A',
    'XN--O3CW4H',
    'XN--OGBPF8FL',
    'XN--OTU796D',
    'XN--P1ACF',
    'XN--P1AI',
    'XN--PGBS0DH',
    'XN--PSSY2U',
    'XN--Q7CE6A',
    'XN--Q9JYB4C',
    'XN--QCKA1PMC',
    'XN--QXA6A',
    'XN--QXAM',
    'XN--RHQV96G',
    'XN--ROVU88B',
    'XN--RVC1E0AM3E',
    'XN--S9BRJ9C',
    'XN--SES554G',
    'XN--T60B56A',
    'XN--TCKWE',
    'XN--TIQ49XQYJ',
    'XN--UNUP4Y',
    'XN--VERMGENSBERATER-CTB',
    'XN--VERMGENSBERATUNG-PWB',
    'XN--VHQUV',
    'XN--VUQ861B',
    'XN--W4R85EL8FHU5DNRA',
    'XN--W4RS40L',
    'XN--WGBH1C',
    'XN--WGBL6A',
    'XN--XHQ521B',
    'XN--XKC2AL3HYE2A',
    'XN--XKC2DL3A5EE0H',
    'XN--Y9A3AQ',
    'XN--YFRO4I67O',
    'XN--YGBI2AMMX',
    'XN--ZFR164B',
    'XXX',
    'XYZ',
    'YACHTS',
    'YAHOO',
    'YAMAXUN',
    'YANDEX',
    'YE',
    'YODOBASHI',
    'YOGA',
    'YOKOHAMA',
    'YOU',
    'YOUTUBE',
    'YT',
    'YUN',
    'ZA',
    'ZAPPOS',
    'ZARA',
    'ZERO',
    'ZIP',
    'ZM',
    'ZONE',
    'ZUERICH',
    'ZW'
];


// Keep as upper-case to make updating from source easier

module.exports = new Set(internals.tlds.map((tld) => tld.toLowerCase()));


/***/ }),

/***/ "./node_modules/@sideway/address/lib/uri.js":
/*!**************************************************!*\
  !*** ./node_modules/@sideway/address/lib/uri.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const EscapeRegex = __webpack_require__(/*! @hapi/hoek/lib/escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js");


const internals = {};


internals.generate = function () {

    const rfc3986 = {};

    const hexDigit = '\\dA-Fa-f';                                               // HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
    const hexDigitOnly = '[' + hexDigit + ']';

    const unreserved = '\\w-\\.~';                                              // unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
    const subDelims = '!\\$&\'\\(\\)\\*\\+,;=';                                 // sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
    const pctEncoded = '%' + hexDigit;                                          // pct-encoded = "%" HEXDIG HEXDIG
    const pchar = unreserved + pctEncoded + subDelims + ':@';                   // pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
    const pcharOnly = '[' + pchar + ']';
    const decOctect = '(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])';     // dec-octet = DIGIT / %x31-39 DIGIT / "1" 2DIGIT / "2" %x30-34 DIGIT / "25" %x30-35  ; 0-9 / 10-99 / 100-199 / 200-249 / 250-255

    rfc3986.ipv4address = '(?:' + decOctect + '\\.){3}' + decOctect;            // IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet

    /*
        h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
        ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
        IPv6address =                            6( h16 ":" ) ls32
                    /                       "::" 5( h16 ":" ) ls32
                    / [               h16 ] "::" 4( h16 ":" ) ls32
                    / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                    / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                    / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                    / [ *4( h16 ":" ) h16 ] "::"              ls32
                    / [ *5( h16 ":" ) h16 ] "::"              h16
                    / [ *6( h16 ":" ) h16 ] "::"
    */

    const h16 = hexDigitOnly + '{1,4}';
    const ls32 = '(?:' + h16 + ':' + h16 + '|' + rfc3986.ipv4address + ')';
    const IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
    const IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
    const IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;
    const IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;
    const IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;
    const IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;
    const IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;
    const IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;
    const IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';

    rfc3986.ipv4Cidr = '(?:\\d|[1-2]\\d|3[0-2])';                                           // IPv4 cidr = DIGIT / %x31-32 DIGIT / "3" %x30-32  ; 0-9 / 10-29 / 30-32
    rfc3986.ipv6Cidr = '(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])';                         // IPv6 cidr = DIGIT / %x31-39 DIGIT / "1" %x0-1 DIGIT / "12" %x0-8;   0-9 / 10-99 / 100-119 / 120-128
    rfc3986.ipv6address = '(?:' + IPv6SixHex + '|' + IPv6FiveHex + '|' + IPv6FourHex + '|' + IPv6ThreeHex + '|' + IPv6TwoHex + '|' + IPv6OneHex + '|' + IPv6NoneHex + '|' + IPv6NoneHex2 + '|' + IPv6NoneHex3 + ')';
    rfc3986.ipvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+';      // IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

    rfc3986.scheme = '[a-zA-Z][a-zA-Z\\d+-\\.]*';                                           // scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    rfc3986.schemeRegex = new RegExp(rfc3986.scheme);

    const userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';                     // userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
    const IPLiteral = '\\[(?:' + rfc3986.ipv6address + '|' + rfc3986.ipvFuture + ')\\]';    // IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
    const regName = '[' + unreserved + pctEncoded + subDelims + ']{1,255}';                 // reg-name = *( unreserved / pct-encoded / sub-delims )
    const host = '(?:' + IPLiteral + '|' + rfc3986.ipv4address + '|' + regName + ')';       // host = IP-literal / IPv4address / reg-name
    const port = '\\d*';                                                                    // port = *DIGIT
    const authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';               // authority   = [ userinfo "@" ] host [ ":" port ]
    const authorityCapture = '(?:' + userinfo + '@)?(' + host + ')(?::' + port + ')?';

    /*
        segment       = *pchar
        segment-nz    = 1*pchar
        path          = path-abempty    ; begins with "/" '|' is empty
                    / path-absolute   ; begins with "/" but not "//"
                    / path-noscheme   ; begins with a non-colon segment
                    / path-rootless   ; begins with a segment
                    / path-empty      ; zero characters
        path-abempty  = *( "/" segment )
        path-absolute = "/" [ segment-nz *( "/" segment ) ]
        path-rootless = segment-nz *( "/" segment )
    */

    const segment = pcharOnly + '*';
    const segmentNz = pcharOnly + '+';
    const segmentNzNc = '[' + unreserved + pctEncoded + subDelims + '@' + ']+';
    const pathEmpty = '';
    const pathAbEmpty = '(?:\\/' + segment + ')*';
    const pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
    const pathRootless = segmentNz + pathAbEmpty;
    const pathNoScheme = segmentNzNc + pathAbEmpty;
    const pathAbNoAuthority = '(?:\\/\\/\\/' + segment + pathAbEmpty + ')';     // Used by file:///

    // hier-part = "//" authority path

    rfc3986.hierPart = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + '|' + pathAbsolute + '|' + pathRootless + '|' + pathAbNoAuthority + ')';
    rfc3986.hierPartCapture = '(?:' + '(?:\\/\\/' + authorityCapture + pathAbEmpty + ')' + '|' + pathAbsolute + '|' + pathRootless + ')';

    // relative-part = "//" authority path-abempty / path-absolute / path-noscheme / path-empty

    rfc3986.relativeRef = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + '|' + pathAbsolute + '|' + pathNoScheme + '|' + pathEmpty + ')';
    rfc3986.relativeRefCapture = '(?:' + '(?:\\/\\/' + authorityCapture + pathAbEmpty + ')' + '|' + pathAbsolute + '|' + pathNoScheme + '|' + pathEmpty + ')';

    // query = *( pchar / "/" / "?" )
    // query = *( pchar / "[" / "]" / "/" / "?" )

    rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)';                            //Finish matching either at the fragment part '|' end of the line.
    rfc3986.queryWithSquareBrackets = '[' + pchar + '\\[\\]\\/\\?]*(?=#|$)';

    // fragment = *( pchar / "/" / "?" )

    rfc3986.fragment = '[' + pchar + '\\/\\?]*';

    return rfc3986;
};

internals.rfc3986 = internals.generate();


exports.ip = {
    v4Cidr: internals.rfc3986.ipv4Cidr,
    v6Cidr: internals.rfc3986.ipv6Cidr,
    ipv4: internals.rfc3986.ipv4address,
    ipv6: internals.rfc3986.ipv6address,
    ipvfuture: internals.rfc3986.ipvFuture
};


internals.createRegex = function (options) {

    const rfc = internals.rfc3986;

    // Construct expression

    const query = options.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
    const suffix = '(?:\\?' + query + ')?' + '(?:#' + rfc.fragment + ')?';

    // relative-ref = relative-part [ "?" query ] [ "#" fragment ]

    const relative = options.domain ? rfc.relativeRefCapture : rfc.relativeRef;

    if (options.relativeOnly) {
        return internals.wrap(relative + suffix);
    }

    // Custom schemes

    let customScheme = '';
    if (options.scheme) {
        Assert(options.scheme instanceof RegExp || typeof options.scheme === 'string' || Array.isArray(options.scheme), 'scheme must be a RegExp, String, or Array');

        const schemes = [].concat(options.scheme);
        Assert(schemes.length >= 1, 'scheme must have at least 1 scheme specified');

        // Flatten the array into a string to be used to match the schemes

        const selections = [];
        for (let i = 0; i < schemes.length; ++i) {
            const scheme = schemes[i];
            Assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');

            if (scheme instanceof RegExp) {
                selections.push(scheme.source.toString());
            }
            else {
                Assert(rfc.schemeRegex.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
                selections.push(EscapeRegex(scheme));
            }
        }

        customScheme = selections.join('|');
    }

    // URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

    const scheme = customScheme ? '(?:' + customScheme + ')' : rfc.scheme;
    const absolute = '(?:' + scheme + ':' + (options.domain ? rfc.hierPartCapture : rfc.hierPart) + ')';
    const prefix = options.allowRelative ? '(?:' + absolute + '|' + relative + ')' : absolute;
    return internals.wrap(prefix + suffix, customScheme);
};


internals.wrap = function (raw, scheme) {

    raw = `(?=.)(?!https?\:/(?:$|[^/]))(?!https?\:///)(?!https?\:[^/])${raw}`;     // Require at least one character and explicitly forbid 'http:/' or HTTP with empty domain

    return {
        raw,
        regex: new RegExp(`^${raw}$`),
        scheme
    };
};


internals.uriRegex = internals.createRegex({});


exports.regex = function (options = {}) {

    if (options.scheme ||
        options.allowRelative ||
        options.relativeOnly ||
        options.allowQuerySquareBrackets ||
        options.domain) {

        return internals.createRegex(options);
    }

    return internals.uriRegex;
};


/***/ }),

/***/ "./node_modules/@sideway/formula/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@sideway/formula/lib/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {



const internals = {
    operators: ['!', '^', '*', '/', '%', '+', '-', '<', '<=', '>', '>=', '==', '!=', '&&', '||', '??'],
    operatorCharacters: ['!', '^', '*', '/', '%', '+', '-', '<', '=', '>', '&', '|', '?'],
    operatorsOrder: [['^'], ['*', '/', '%'], ['+', '-'], ['<', '<=', '>', '>='], ['==', '!='], ['&&'], ['||', '??']],
    operatorsPrefix: ['!', 'n'],

    literals: {
        '"': '"',
        '`': '`',
        '\'': '\'',
        '[': ']'
    },

    numberRx: /^(?:[0-9]*\.?[0-9]*){1}$/,
    tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,

    symbol: Symbol('formula'),
    settings: Symbol('settings')
};


exports.Parser = class {

    constructor(string, options = {}) {

        if (!options[internals.settings] &&
            options.constants) {

            for (const constant in options.constants) {
                const value = options.constants[constant];
                if (value !== null &&
                    !['boolean', 'number', 'string'].includes(typeof value)) {

                    throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
                }
            }
        }

        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);
        this.single = null;

        this._parts = null;
        this._parse(string);
    }

    _parse(string) {

        let parts = [];
        let current = '';
        let parenthesis = 0;
        let literal = false;

        const flush = (inner) => {

            if (parenthesis) {
                throw new Error('Formula missing closing parenthesis');
            }

            const last = parts.length ? parts[parts.length - 1] : null;

            if (!literal &&
                !current &&
                !inner) {

                return;
            }

            if (last &&
                last.type === 'reference' &&
                inner === ')') {                                                                // Function

                last.type = 'function';
                last.value = this._subFormula(current, last.value);
                current = '';
                return;
            }

            if (inner === ')') {                                                                // Segment
                const sub = new exports.Parser(current, this.settings);
                parts.push({ type: 'segment', value: sub });
            }
            else if (literal) {
                if (literal === ']') {                                                          // Reference
                    parts.push({ type: 'reference', value: current });
                    current = '';
                    return;
                }

                parts.push({ type: 'literal', value: current });                                // Literal
            }
            else if (internals.operatorCharacters.includes(current)) {                          // Operator
                if (last &&
                    last.type === 'operator' &&
                    internals.operators.includes(last.value + current)) {                       // 2 characters operator

                    last.value += current;
                }
                else {
                    parts.push({ type: 'operator', value: current });
                }
            }
            else if (current.match(internals.numberRx)) {                                       // Number
                parts.push({ type: 'constant', value: parseFloat(current) });
            }
            else if (this.settings.constants[current] !== undefined) {                          // Constant
                parts.push({ type: 'constant', value: this.settings.constants[current] });
            }
            else {                                                                              // Reference
                if (!current.match(internals.tokenRx)) {
                    throw new Error(`Formula contains invalid token: ${current}`);
                }

                parts.push({ type: 'reference', value: current });
            }

            current = '';
        };

        for (const c of string) {
            if (literal) {
                if (c === literal) {
                    flush();
                    literal = false;
                }
                else {
                    current += c;
                }
            }
            else if (parenthesis) {
                if (c === '(') {
                    current += c;
                    ++parenthesis;
                }
                else if (c === ')') {
                    --parenthesis;
                    if (!parenthesis) {
                        flush(c);
                    }
                    else {
                        current += c;
                    }
                }
                else {
                    current += c;
                }
            }
            else if (c in internals.literals) {
                literal = internals.literals[c];
            }
            else if (c === '(') {
                flush();
                ++parenthesis;
            }
            else if (internals.operatorCharacters.includes(c)) {
                flush();
                current = c;
                flush();
            }
            else if (c !== ' ') {
                current += c;
            }
            else {
                flush();
            }
        }

        flush();

        // Replace prefix - to internal negative operator

        parts = parts.map((part, i) => {

            if (part.type !== 'operator' ||
                part.value !== '-' ||
                i && parts[i - 1].type !== 'operator') {

                return part;
            }

            return { type: 'operator', value: 'n' };
        });

        // Validate tokens order

        let operator = false;
        for (const part of parts) {
            if (part.type === 'operator') {
                if (internals.operatorsPrefix.includes(part.value)) {
                    continue;
                }

                if (!operator) {
                    throw new Error('Formula contains an operator in invalid position');
                }

                if (!internals.operators.includes(part.value)) {
                    throw new Error(`Formula contains an unknown operator ${part.value}`);
                }
            }
            else if (operator) {
                throw new Error('Formula missing expected operator');
            }

            operator = !operator;
        }

        if (!operator) {
            throw new Error('Formula contains invalid trailing operator');
        }

        // Identify single part

        if (parts.length === 1 &&
            ['reference', 'literal', 'constant'].includes(parts[0].type)) {

            this.single = { type: parts[0].type === 'reference' ? 'reference' : 'value', value: parts[0].value };
        }

        // Process parts

        this._parts = parts.map((part) => {

            // Operators

            if (part.type === 'operator') {
                return internals.operatorsPrefix.includes(part.value) ? part : part.value;
            }

            // Literals, constants, segments

            if (part.type !== 'reference') {
                return part.value;
            }

            // References

            if (this.settings.tokenRx &&
                !this.settings.tokenRx.test(part.value)) {

                throw new Error(`Formula contains invalid reference ${part.value}`);
            }

            if (this.settings.reference) {
                return this.settings.reference(part.value);
            }

            return internals.reference(part.value);
        });
    }

    _subFormula(string, name) {

        const method = this.settings.functions[name];
        if (typeof method !== 'function') {
            throw new Error(`Formula contains unknown function ${name}`);
        }

        let args = [];
        if (string) {
            let current = '';
            let parenthesis = 0;
            let literal = false;

            const flush = () => {

                if (!current) {
                    throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);
                }

                args.push(current);
                current = '';
            };

            for (let i = 0; i < string.length; ++i) {
                const c = string[i];
                if (literal) {
                    current += c;
                    if (c === literal) {
                        literal = false;
                    }
                }
                else if (c in internals.literals &&
                    !parenthesis) {

                    current += c;
                    literal = internals.literals[c];
                }
                else if (c === ',' &&
                    !parenthesis) {

                    flush();
                }
                else {
                    current += c;
                    if (c === '(') {
                        ++parenthesis;
                    }
                    else if (c === ')') {
                        --parenthesis;
                    }
                }
            }

            flush();
        }

        args = args.map((arg) => new exports.Parser(arg, this.settings));

        return function (context) {

            const innerValues = [];
            for (const arg of args) {
                innerValues.push(arg.evaluate(context));
            }

            return method.call(context, ...innerValues);
        };
    }

    evaluate(context) {

        const parts = this._parts.slice();

        // Prefix operators

        for (let i = parts.length - 2; i >= 0; --i) {
            const part = parts[i];
            if (part &&
                part.type === 'operator') {

                const current = parts[i + 1];
                parts.splice(i + 1, 1);
                const value = internals.evaluate(current, context);
                parts[i] = internals.single(part.value, value);
            }
        }

        // Left-right operators

        internals.operatorsOrder.forEach((set) => {

            for (let i = 1; i < parts.length - 1;) {
                if (set.includes(parts[i])) {
                    const operator = parts[i];
                    const left = internals.evaluate(parts[i - 1], context);
                    const right = internals.evaluate(parts[i + 1], context);

                    parts.splice(i, 2);
                    const result = internals.calculate(operator, left, right);
                    parts[i - 1] = result === 0 ? 0 : result;                               // Convert -0
                }
                else {
                    i += 2;
                }
            }
        });

        return internals.evaluate(parts[0], context);
    }
};


exports.Parser.prototype[internals.symbol] = true;


internals.reference = function (name) {

    return function (context) {

        return context && context[name] !== undefined ? context[name] : null;
    };
};


internals.evaluate = function (part, context) {

    if (part === null) {
        return null;
    }

    if (typeof part === 'function') {
        return part(context);
    }

    if (part[internals.symbol]) {
        return part.evaluate(context);
    }

    return part;
};


internals.single = function (operator, value) {

    if (operator === '!') {
        return value ? false : true;
    }

    // operator === 'n'

    const negative = -value;
    if (negative === 0) {       // Override -0
        return 0;
    }

    return negative;
};


internals.calculate = function (operator, left, right) {

    if (operator === '??') {
        return internals.exists(left) ? left : right;
    }

    if (typeof left === 'string' ||
        typeof right === 'string') {

        if (operator === '+') {
            left = internals.exists(left) ? left : '';
            right = internals.exists(right) ? right : '';
            return left + right;
        }
    }
    else {
        switch (operator) {
            case '^': return Math.pow(left, right);
            case '*': return left * right;
            case '/': return left / right;
            case '%': return left % right;
            case '+': return left + right;
            case '-': return left - right;
        }
    }

    switch (operator) {
        case '<': return left < right;
        case '<=': return left <= right;
        case '>': return left > right;
        case '>=': return left >= right;
        case '==': return left === right;
        case '!=': return left !== right;
        case '&&': return left && right;
        case '||': return left || right;
    }

    return null;
};


internals.exists = function (value) {

    return value !== null && value !== undefined;
};


/***/ }),

/***/ "./node_modules/@sideway/pinpoint/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sideway/pinpoint/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {



const internals = {};


exports.location = function (depth = 0) {

    const orig = Error.prepareStackTrace;
    Error.prepareStackTrace = (ignore, stack) => stack;

    const capture = {};
    Error.captureStackTrace(capture, this);
    const line = capture.stack[depth + 1];

    Error.prepareStackTrace = orig;

    return {
        filename: line.getFileName(),
        line: line.getLineNumber()
    };
};


/***/ }),

/***/ "./node_modules/joi/lib/annotate.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/annotate.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");


const internals = {
    annotations: Symbol('annotations')
};


exports.error = function (stripColorCodes) {

    if (!this._original ||
        typeof this._original !== 'object') {

        return this.details[0].message;
    }

    const redFgEscape = stripColorCodes ? '' : '\u001b[31m';
    const redBgEscape = stripColorCodes ? '' : '\u001b[41m';
    const endColor = stripColorCodes ? '' : '\u001b[0m';

    const obj = Clone(this._original);

    for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first
        const pos = i + 1;
        const error = this.details[i];
        const path = error.path;
        let node = obj;
        for (let j = 0; ; ++j) {
            const seg = path[j];

            if (Common.isSchema(node)) {
                node = node.clone();                              // joi schemas are not cloned by hoek, we have to take this extra step
            }

            if (j + 1 < path.length &&
                typeof node[seg] !== 'string') {

                node = node[seg];
            }
            else {
                const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
                node[internals.annotations] = refAnnotations;

                const cacheKey = seg || error.context.key;

                if (node[seg] !== undefined) {
                    refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
                    refAnnotations.errors[cacheKey].push(pos);
                }
                else {
                    refAnnotations.missing[cacheKey] = pos;
                }

                break;
            }
        }
    }

    const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
    };

    let message = internals.safeStringify(obj, 2)
        .replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`)
        .replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`)
        .replace(replacers.arrayIndex, ($0, $1, $2) => `\n${$2} ${redFgEscape}[${$1}]${endColor}`)
        .replace(replacers.specials, ($0, $1) => $1);

    message = `${message}\n${redFgEscape}`;

    for (let i = 0; i < this.details.length; ++i) {
        const pos = i + 1;
        message = `${message}\n[${pos}] ${this.details[i].message}`;
    }

    message = message + endColor;

    return message;
};


// Inspired by json-stringify-safe

internals.safeStringify = function (obj, spaces) {

    return JSON.stringify(obj, internals.serializer(), spaces);
};


internals.serializer = function () {

    const keys = [];
    const stack = [];

    const cycleReplacer = (key, value) => {

        if (stack[0] === value) {
            return '[Circular ~]';
        }

        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
    };

    return function (key, value) {

        if (stack.length > 0) {
            const thisPos = stack.indexOf(this);
            if (~thisPos) {
                stack.length = thisPos + 1;
                keys.length = thisPos + 1;
                keys[thisPos] = key;
            }
            else {
                stack.push(this);
                keys.push(key);
            }

            if (~stack.indexOf(value)) {
                value = cycleReplacer.call(this, key, value);
            }
        }
        else {
            stack.push(value);
        }

        if (value) {
            const annotations = value[internals.annotations];
            if (annotations) {
                if (Array.isArray(value)) {
                    const annotated = [];

                    for (let i = 0; i < value.length; ++i) {
                        if (annotations.errors[i]) {
                            annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);
                        }

                        annotated.push(value[i]);
                    }

                    value = annotated;
                }
                else {
                    for (const errorKey in annotations.errors) {
                        value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];
                        value[errorKey] = undefined;
                    }

                    for (const missingKey in annotations.missing) {
                        value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';
                    }
                }

                return value;
            }
        }

        if (value === Infinity ||
            value === -Infinity ||
            Number.isNaN(value) ||
            typeof value === 'function' ||
            typeof value === 'symbol') {

            return '[' + value.toString() + ']';
        }

        return value;
    };
};


/***/ }),

/***/ "./node_modules/joi/lib/base.js":
/*!**************************************!*\
  !*** ./node_modules/joi/lib/base.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const Merge = __webpack_require__(/*! @hapi/hoek/lib/merge */ "./node_modules/@hapi/hoek/lib/merge.js");

const Cache = __webpack_require__(/*! ./cache */ "./node_modules/joi/lib/cache.js");
const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");
const Compile = __webpack_require__(/*! ./compile */ "./node_modules/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/joi/lib/errors.js");
const Extend = __webpack_require__(/*! ./extend */ "./node_modules/joi/lib/extend.js");
const Manifest = __webpack_require__(/*! ./manifest */ "./node_modules/joi/lib/manifest.js");
const Messages = __webpack_require__(/*! ./messages */ "./node_modules/joi/lib/messages.js");
const Modify = __webpack_require__(/*! ./modify */ "./node_modules/joi/lib/modify.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/joi/lib/ref.js");
const Trace = __webpack_require__(/*! ./trace */ "./node_modules/joi/lib/trace.js");
const Validator = __webpack_require__(/*! ./validator */ "./node_modules/joi/lib/validator.js");
const Values = __webpack_require__(/*! ./values */ "./node_modules/joi/lib/values.js");


const internals = {};


internals.Base = class {

    constructor(type) {

        // Naming: public, _private, $_extension, $_mutate{action}

        this.type = type;

        this.$_root = null;
        this._definition = {};
        this._reset();
    }

    _reset() {

        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;

        this._valids = null;
        this._invalids = null;

        this._flags = {};
        this._rules = [];
        this._singleRules = new Map();              // The rule options passed for non-multi rules

        this.$_terms = {};                          // Hash of arrays of immutable objects (extended by other types)

        this.$_temp = {                             // Runtime state (not cloned)
            ruleset: null,                          // null: use last, false: error, number: start position
            whens: {}                               // Runtime cache of generated whens
        };
    }

    // Manifest

    describe() {

        Assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');
        return Manifest.describe(this);
    }

    // Rules

    allow(...values) {

        Common.verifyFlat(values, 'allow');
        return this._values(values, '_valids');
    }

    alter(targets) {

        Assert(targets && typeof targets === 'object' && !Array.isArray(targets), 'Invalid targets argument');
        Assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');

        const obj = this.clone();
        obj.$_terms.alterations = obj.$_terms.alterations || [];
        for (const target in targets) {
            const adjuster = targets[target];
            Assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');
            obj.$_terms.alterations.push({ target, adjuster });
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    artifact(id) {

        Assert(id !== undefined, 'Artifact cannot be undefined');
        Assert(!this._cache, 'Cannot set an artifact with a rule cache');

        return this.$_setFlag('artifact', id);
    }

    cast(to) {

        Assert(to === false || typeof to === 'string', 'Invalid to value');
        Assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);

        return this.$_setFlag('cast', to === false ? undefined : to);
    }

    default(value, options) {

        return this._default('default', value, options);
    }

    description(desc) {

        Assert(desc && typeof desc === 'string', 'Description must be a non-empty string');

        return this.$_setFlag('description', desc);
    }

    empty(schema) {

        const obj = this.clone();

        if (schema !== undefined) {
            schema = obj.$_compile(schema, { override: false });
        }

        return obj.$_setFlag('empty', schema, { clone: false });
    }

    error(err) {

        Assert(err, 'Missing error');
        Assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');

        return this.$_setFlag('error', err);
    }

    example(example, options = {}) {

        Assert(example !== undefined, 'Missing example');
        Common.assertOptions(options, ['override']);

        return this._inner('examples', example, { single: true, override: options.override });
    }

    external(method, description) {

        if (typeof method === 'object') {
            Assert(!description, 'Cannot combine options with description');
            description = method.description;
            method = method.method;
        }

        Assert(typeof method === 'function', 'Method must be a function');
        Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');

        return this._inner('externals', { method, description }, { single: true });
    }

    failover(value, options) {

        return this._default('failover', value, options);
    }

    forbidden() {

        return this.presence('forbidden');
    }

    id(id) {

        if (!id) {
            return this.$_setFlag('id', undefined);
        }

        Assert(typeof id === 'string', 'id must be a non-empty string');
        Assert(/^[^\.]+$/.test(id), 'id cannot contain period character');

        return this.$_setFlag('id', id);
    }

    invalid(...values) {

        return this._values(values, '_invalids');
    }

    label(name) {

        Assert(name && typeof name === 'string', 'Label name must be a non-empty string');

        return this.$_setFlag('label', name);
    }

    meta(meta) {

        Assert(meta !== undefined, 'Meta cannot be undefined');

        return this._inner('metas', meta, { single: true });
    }

    note(...notes) {

        Assert(notes.length, 'Missing notes');
        for (const note of notes) {
            Assert(note && typeof note === 'string', 'Notes must be non-empty strings');
        }

        return this._inner('notes', notes);
    }

    only(mode = true) {

        Assert(typeof mode === 'boolean', 'Invalid mode:', mode);

        return this.$_setFlag('only', mode);
    }

    optional() {

        return this.presence('optional');
    }

    prefs(prefs) {

        Assert(prefs, 'Missing preferences');
        Assert(prefs.context === undefined, 'Cannot override context');
        Assert(prefs.externals === undefined, 'Cannot override externals');
        Assert(prefs.warnings === undefined, 'Cannot override warnings');
        Assert(prefs.debug === undefined, 'Cannot override debug');

        Common.checkPreferences(prefs);

        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
    }

    presence(mode) {

        Assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);

        return this.$_setFlag('presence', mode);
    }

    raw(enabled = true) {

        return this.$_setFlag('result', enabled ? 'raw' : undefined);
    }

    result(mode) {

        Assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);

        return this.$_setFlag('result', mode);
    }

    required() {

        return this.presence('required');
    }

    strict(enabled) {

        const obj = this.clone();

        const convert = enabled === undefined ? false : !enabled;
        obj._preferences = Common.preferences(obj._preferences, { convert });
        return obj;
    }

    strip(enabled = true) {

        return this.$_setFlag('result', enabled ? 'strip' : undefined);
    }

    tag(...tags) {

        Assert(tags.length, 'Missing tags');
        for (const tag of tags) {
            Assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');
        }

        return this._inner('tags', tags);
    }

    unit(name) {

        Assert(name && typeof name === 'string', 'Unit name must be a non-empty string');

        return this.$_setFlag('unit', name);
    }

    valid(...values) {

        Common.verifyFlat(values, 'valid');

        const obj = this.allow(...values);
        obj.$_setFlag('only', !!obj._valids, { clone: false });
        return obj;
    }

    when(condition, options) {

        const obj = this.clone();

        if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
        }

        const when = Compile.when(obj, condition, options);
        if (!['any', 'link'].includes(obj.type)) {
            const conditions = when.is ? [when] : when.switch;
            for (const item of conditions) {
                Assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);
                Assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);

            }
        }

        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
    }

    // Helpers

    cache(cache) {

        Assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');
        Assert(!this._cache, 'Cannot override schema cache');
        Assert(this._flags.artifact === undefined, 'Cannot cache a rule with an artifact');

        const obj = this.clone();
        obj._cache = cache || Cache.provider.provision();
        obj.$_temp.ruleset = false;
        return obj;
    }

    clone() {

        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
    }

    concat(source) {

        Assert(Common.isSchema(source), 'Invalid schema object');
        Assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);
        Assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');
        Assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');

        let obj = this.clone();

        if (this.type === 'any' &&
            source.type !== 'any') {

            // Change obj to match source type

            const tmpObj = source.clone();
            for (const key of Object.keys(obj)) {
                if (key !== 'type') {
                    tmpObj[key] = obj[key];
                }
            }

            obj = tmpObj;
        }

        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);

        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);

        // Remove unique rules present in source

        for (const name of source._singleRules.keys()) {
            if (obj._singleRules.has(name)) {
                obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
                obj._singleRules.delete(name);
            }
        }

        // Rules

        for (const test of source._rules) {
            if (!source._definition.rules[test.method].multi) {
                obj._singleRules.set(test.name, test);
            }

            obj._rules.push(test);
        }

        // Flags

        if (obj._flags.empty &&
            source._flags.empty) {

            obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
            const flags = Object.assign({}, source._flags);
            delete flags.empty;
            Merge(obj._flags, flags);
        }
        else if (source._flags.empty) {
            obj._flags.empty = source._flags.empty;
            const flags = Object.assign({}, source._flags);
            delete flags.empty;
            Merge(obj._flags, flags);
        }
        else {
            Merge(obj._flags, source._flags);
        }

        // Terms

        for (const key in source.$_terms) {
            const terms = source.$_terms[key];
            if (!terms) {
                if (!obj.$_terms[key]) {
                    obj.$_terms[key] = terms;
                }

                continue;
            }

            if (!obj.$_terms[key]) {
                obj.$_terms[key] = terms.slice();
                continue;
            }

            obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }

        // Tracing

        if (this.$_root._tracer) {
            this.$_root._tracer._combine(obj, [this, source]);
        }

        // Rebuild

        return obj.$_mutateRebuild();
    }

    extend(options) {

        Assert(!options.base, 'Cannot extend type with another base');

        return Extend.type(this, options);
    }

    extract(path) {

        path = Array.isArray(path) ? path : path.split('.');
        return this._ids.reach(path);
    }

    fork(paths, adjuster) {

        Assert(!this._inRuleset(), 'Cannot fork inside a ruleset');

        let obj = this;                                             // eslint-disable-line consistent-this
        for (let path of [].concat(paths)) {
            path = Array.isArray(path) ? path : path.split('.');
            obj = obj._ids.fork(path, adjuster, obj);
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    rule(options) {

        const def = this._definition;
        Common.assertOptions(options, Object.keys(def.modifiers));

        Assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');
        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
        Assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');

        const obj = this.clone();

        for (let i = start; i < obj._rules.length; ++i) {
            const original = obj._rules[i];
            const rule = Clone(original);

            for (const name in options) {
                def.modifiers[name](rule, options[name]);
                Assert(rule.name === original.name, 'Cannot change rule name');
            }

            obj._rules[i] = rule;

            if (obj._singleRules.get(rule.name) === original) {
                obj._singleRules.set(rule.name, rule);
            }
        }

        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
    }

    get ruleset() {

        Assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');

        const obj = this.clone();
        obj.$_temp.ruleset = obj._rules.length;
        return obj;
    }

    get $() {

        return this.ruleset;
    }

    tailor(targets) {

        targets = [].concat(targets);

        Assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');

        let obj = this;                                                     // eslint-disable-line consistent-this

        if (this.$_terms.alterations) {
            for (const { target, adjuster } of this.$_terms.alterations) {
                if (targets.includes(target)) {
                    obj = adjuster(obj);
                    Assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');
                }
            }
        }

        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
    }

    tracer() {

        return Trace.location ? Trace.location(this) : this;                // $lab:coverage:ignore$
    }

    validate(value, options) {

        return Validator.entry(value, this, options);
    }

    validateAsync(value, options) {

        return Validator.entryAsync(value, this, options);
    }

    // Extensions

    $_addRule(options) {

        // Normalize rule

        if (typeof options === 'string') {
            options = { name: options };
        }

        Assert(options && typeof options === 'object', 'Invalid options');
        Assert(options.name && typeof options.name === 'string', 'Invalid rule name');

        for (const key in options) {
            Assert(key[0] !== '_', 'Cannot set private rule properties');
        }

        const rule = Object.assign({}, options);        // Shallow cloned
        rule._resolve = [];
        rule.method = rule.method || rule.name;

        const definition = this._definition.rules[rule.method];
        const args = rule.args;

        Assert(definition, 'Unknown rule', rule.method);

        // Args

        const obj = this.clone();

        if (args) {
            Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);

            for (const key in args) {
                let arg = args[key];
                if (arg === undefined) {
                    delete args[key];
                    continue;
                }

                if (definition.argsByName) {
                    const resolver = definition.argsByName.get(key);

                    if (resolver.ref &&
                        Common.isResolvable(arg)) {

                        rule._resolve.push(key);
                        obj.$_mutateRegister(arg);
                    }
                    else {
                        if (resolver.normalize) {
                            arg = resolver.normalize(arg);
                            args[key] = arg;
                        }

                        if (resolver.assert) {
                            const error = Common.validateArg(arg, key, resolver);
                            Assert(!error, error, 'or reference');
                        }
                    }
                }

                args[key] = arg;
            }
        }

        // Unique rules

        if (!definition.multi) {
            obj._ruleRemove(rule.name, { clone: false });
            obj._singleRules.set(rule.name, rule);
        }

        if (obj.$_temp.ruleset === false) {
            obj.$_temp.ruleset = null;
        }

        if (definition.priority) {
            obj._rules.unshift(rule);
        }
        else {
            obj._rules.push(rule);
        }

        return obj;
    }

    $_compile(schema, options) {

        return Compile.schema(this.$_root, schema, options);
    }

    $_createError(code, value, local, state, prefs, options = {}) {

        const flags = options.flags !== false ? this._flags : {};
        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
        return new Errors.Report(code, value, local, flags, messages, state, prefs);
    }

    $_getFlag(name) {

        return this._flags[name];
    }

    $_getRule(name) {

        return this._singleRules.get(name);
    }

    $_mapLabels(path) {

        path = Array.isArray(path) ? path : path.split('.');
        return this._ids.labels(path);
    }

    $_match(value, state, prefs, overrides) {

        prefs = Object.assign({}, prefs);       // Shallow cloned
        prefs.abortEarly = true;
        prefs._externals = false;

        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();

        return result;
    }

    $_modify(options) {

        Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);
        return Modify.schema(this, options) || this;
    }

    $_mutateRebuild() {

        Assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');

        this._refs.reset();
        this._ids.reset();

        const each = (item, { source, name, path, key }) => {

            const family = this._definition[source][name] && this._definition[source][name].register;
            if (family !== false) {
                this.$_mutateRegister(item, { family, key });
            }
        };

        this.$_modify({ each });

        if (this._definition.rebuild) {
            this._definition.rebuild(this);
        }

        this.$_temp.ruleset = false;
        return this;
    }

    $_mutateRegister(schema, { family, key } = {}) {

        this._refs.register(schema, family);
        this._ids.register(schema, { key });
    }

    $_property(name) {

        return this._definition.properties[name];
    }

    $_reach(path) {

        return this._ids.reach(path);
    }

    $_rootReferences() {

        return this._refs.roots();
    }

    $_setFlag(name, value, options = {}) {

        Assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');

        const flag = this._definition.flags[name] || {};
        if (DeepEqual(value, flag.default)) {
            value = undefined;
        }

        if (DeepEqual(value, this._flags[name])) {
            return this;
        }

        const obj = options.clone !== false ? this.clone() : this;

        if (value !== undefined) {
            obj._flags[name] = value;
            obj.$_mutateRegister(value);
        }
        else {
            delete obj._flags[name];
        }

        if (name[0] !== '_') {
            obj.$_temp.ruleset = false;
        }

        return obj;
    }

    $_parent(method, ...args) {

        return this[method][Common.symbols.parent].call(this, ...args);
    }

    $_validate(value, state, prefs) {

        return Validator.validate(value, this, state, prefs);
    }

    // Internals

    _assign(target) {

        target.type = this.type;

        target.$_root = this.$_root;

        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};

        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids && this._valids.clone();
        target._invalids = this._invalids && this._invalids.clone();
        target._rules = this._rules.slice();
        target._singleRules = Clone(this._singleRules, { shallow: true });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;

        target.$_terms = {};
        for (const key in this.$_terms) {
            target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }

        // Backwards compatibility

        target.$_super = {};
        for (const override in this.$_super) {
            target.$_super[override] = this._super[override].bind(target);
        }

        return target;
    }

    _bare() {

        const obj = this.clone();
        obj._reset();

        const terms = obj._definition.terms;
        for (const name in terms) {
            const term = terms[name];
            obj.$_terms[name] = term.init;
        }

        return obj.$_mutateRebuild();
    }

    _default(flag, value, options = {}) {

        Common.assertOptions(options, 'literal');

        Assert(value !== undefined, 'Missing', flag, 'value');
        Assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');

        if (typeof value === 'function' &&
            options.literal) {

            value = {
                [Common.symbols.literal]: true,
                literal: value
            };
        }

        const obj = this.$_setFlag(flag, value);
        return obj;
    }

    _generate(value, state, prefs) {

        if (!this.$_terms.whens) {
            return { schema: this };
        }

        // Collect matching whens

        const whens = [];
        const ids = [];
        for (let i = 0; i < this.$_terms.whens.length; ++i) {
            const when = this.$_terms.whens[i];

            if (when.concat) {
                whens.push(when.concat);
                ids.push(`${i}.concat`);
                continue;
            }

            const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
            const tests = when.is ? [when] : when.switch;
            const before = ids.length;

            for (let j = 0; j < tests.length; ++j) {
                const { is, then, otherwise } = tests[j];

                const baseId = `${i}${when.switch ? '.' + j : ''}`;
                if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
                    if (then) {
                        const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
                        const { schema: generated, id } = then._generate(value, localState, prefs);
                        whens.push(generated);
                        ids.push(`${baseId}.then${id ? `(${id})` : ''}`);
                        break;
                    }
                }
                else if (otherwise) {
                    const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
                    const { schema: generated, id } = otherwise._generate(value, localState, prefs);
                    whens.push(generated);
                    ids.push(`${baseId}.otherwise${id ? `(${id})` : ''}`);
                    break;
                }
            }

            if (when.break &&
                ids.length > before) {          // Something matched

                break;
            }
        }

        // Check cache

        const id = ids.join(', ');
        state.mainstay.tracer.debug(state, 'rule', 'when', id);

        if (!id) {
            return { schema: this };
        }

        if (!state.mainstay.tracer.active &&
            this.$_temp.whens[id]) {

            return { schema: this.$_temp.whens[id], id };
        }

        // Generate dynamic schema

        let obj = this;                                             // eslint-disable-line consistent-this
        if (this._definition.generate) {
            obj = this._definition.generate(this, value, state, prefs);
        }

        // Apply whens

        for (const when of whens) {
            obj = obj.concat(when);
        }

        // Tracing

        if (this.$_root._tracer) {
            this.$_root._tracer._combine(obj, [this, ...whens]);
        }

        // Cache result

        this.$_temp.whens[id] = obj;
        return { schema: obj, id };
    }

    _inner(type, values, options = {}) {

        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);

        const obj = this.clone();
        if (!obj.$_terms[type] ||
            options.override) {

            obj.$_terms[type] = [];
        }

        if (options.single) {
            obj.$_terms[type].push(values);
        }
        else {
            obj.$_terms[type].push(...values);
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    _inRuleset() {

        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
    }

    _ruleRemove(name, options = {}) {

        if (!this._singleRules.has(name)) {
            return this;
        }

        const obj = options.clone !== false ? this.clone() : this;

        obj._singleRules.delete(name);

        const filtered = [];
        for (let i = 0; i < obj._rules.length; ++i) {
            const test = obj._rules[i];
            if (test.name === name &&
                !test.keep) {

                if (obj._inRuleset() &&
                    i < obj.$_temp.ruleset) {

                    --obj.$_temp.ruleset;
                }

                continue;
            }

            filtered.push(test);
        }

        obj._rules = filtered;
        return obj;
    }

    _values(values, key) {

        Common.verifyFlat(values, key.slice(1, -1));

        const obj = this.clone();

        const override = values[0] === Common.symbols.override;
        if (override) {
            values = values.slice(1);
        }

        if (!obj[key] &&
            values.length) {

            obj[key] = new Values();
        }
        else if (override) {
            obj[key] = values.length ? new Values() : null;
            obj.$_mutateRebuild();
        }

        if (!obj[key]) {
            return obj;
        }

        if (override) {
            obj[key].override();
        }

        for (const value of values) {
            Assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
            Assert(value !== Common.symbols.override, 'Override must be the first value');

            const other = key === '_invalids' ? '_valids' : '_invalids';
            if (obj[other]) {
                obj[other].remove(value);
                if (!obj[other].length) {
                    Assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');
                    obj[other] = null;
                }
            }

            obj[key].add(value, obj._refs);
        }

        return obj;
    }
};


internals.Base.prototype[Common.symbols.any] = {
    version: Common.version,
    compile: Compile.compile,
    root: '$_root'
};


internals.Base.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects (must be on prototype)


// Aliases

internals.Base.prototype.deny = internals.Base.prototype.invalid;
internals.Base.prototype.disallow = internals.Base.prototype.invalid;
internals.Base.prototype.equal = internals.Base.prototype.valid;
internals.Base.prototype.exist = internals.Base.prototype.required;
internals.Base.prototype.not = internals.Base.prototype.invalid;
internals.Base.prototype.options = internals.Base.prototype.prefs;
internals.Base.prototype.preferences = internals.Base.prototype.prefs;


module.exports = new internals.Base();


/***/ }),

/***/ "./node_modules/joi/lib/cache.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/cache.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");


const internals = {
    max: 1000,
    supported: new Set(['undefined', 'boolean', 'number', 'string'])
};


exports.provider = {

    provision(options) {

        return new internals.Cache(options);
    }
};


// Least Recently Used (LRU) Cache

internals.Cache = class {

    constructor(options = {}) {

        Common.assertOptions(options, ['max']);
        Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), 'Invalid max cache size');

        this._max = options.max || internals.max;

        this._map = new Map();                          // Map of nodes by key
        this._list = new internals.List();              // List of nodes (most recently used in head)
    }

    get length() {

        return this._map.size;
    }

    set(key, value) {

        if (key !== null &&
            !internals.supported.has(typeof key)) {

            return;
        }

        let node = this._map.get(key);
        if (node) {
            node.value = value;
            this._list.first(node);
            return;
        }

        node = this._list.unshift({ key, value });
        this._map.set(key, node);
        this._compact();
    }

    get(key) {

        const node = this._map.get(key);
        if (node) {
            this._list.first(node);
            return Clone(node.value);
        }
    }

    _compact() {

        if (this._map.size > this._max) {
            const node = this._list.pop();
            this._map.delete(node.key);
        }
    }
};


internals.List = class {

    constructor() {

        this.tail = null;
        this.head = null;
    }

    unshift(node) {

        node.next = null;
        node.prev = this.head;

        if (this.head) {
            this.head.next = node;
        }

        this.head = node;

        if (!this.tail) {
            this.tail = node;
        }

        return node;
    }

    first(node) {

        if (node === this.head) {
            return;
        }

        this._remove(node);
        this.unshift(node);
    }

    pop() {

        return this._remove(this.tail);
    }

    _remove(node) {

        const { next, prev } = node;

        next.prev = prev;

        if (prev) {
            prev.next = next;
        }

        if (node === this.tail) {
            this.tail = next;
        }

        node.prev = null;
        node.next = null;

        return node;
    }
};


/***/ }),

/***/ "./node_modules/joi/lib/common.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/common.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const AssertError = __webpack_require__(/*! @hapi/hoek/lib/error */ "./node_modules/@hapi/hoek/lib/error.js");

const Pkg = __webpack_require__(/*! ../package.json */ "./node_modules/joi/package.json");

let Messages;
let Schemas;


const internals = {
    isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
};


exports.version = Pkg.version;


exports.defaults = {
    abortEarly: true,
    allowUnknown: false,
    artifacts: false,
    cache: true,
    context: null,
    convert: true,
    dateFormat: 'iso',
    errors: {
        escapeHtml: false,
        label: 'path',
        language: null,
        render: true,
        stack: false,
        wrap: {
            label: '"',
            array: '[]'
        }
    },
    externals: true,
    messages: {},
    nonEnumerables: false,
    noDefaults: false,
    presence: 'optional',
    skipFunctions: false,
    stripUnknown: false,
    warnings: false
};


exports.symbols = {
    any: Symbol.for('@hapi/joi/schema'),            // Used to internally identify any-based types (shared with other joi versions)
    arraySingle: Symbol('arraySingle'),
    deepDefault: Symbol('deepDefault'),
    errors: Symbol('errors'),
    literal: Symbol('literal'),
    override: Symbol('override'),
    parent: Symbol('parent'),
    prefs: Symbol('prefs'),
    ref: Symbol('ref'),
    template: Symbol('template'),
    values: Symbol('values')
};


exports.assertOptions = function (options, keys, name = 'Options') {

    Assert(options && typeof options === 'object' && !Array.isArray(options), 'Options must be of type object');
    const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
    Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
};


exports.checkPreferences = function (prefs) {

    Schemas = Schemas || __webpack_require__(/*! ./schemas */ "./node_modules/joi/lib/schemas.js");

    const result = Schemas.preferences.validate(prefs);

    if (result.error) {
        throw new AssertError([result.error.details[0].message]);
    }
};


exports.compare = function (a, b, operator) {

    switch (operator) {
        case '=': return a === b;
        case '>': return a > b;
        case '<': return a < b;
        case '>=': return a >= b;
        case '<=': return a <= b;
    }
};


exports["default"] = function (value, defaultValue) {

    return value === undefined ? defaultValue : value;
};


exports.isIsoDate = function (date) {

    return internals.isoDate.test(date);
};


exports.isNumber = function (value) {

    return typeof value === 'number' && !isNaN(value);
};


exports.isResolvable = function (obj) {

    if (!obj) {
        return false;
    }

    return obj[exports.symbols.ref] || obj[exports.symbols.template];
};


exports.isSchema = function (schema, options = {}) {

    const any = schema && schema[exports.symbols.any];
    if (!any) {
        return false;
    }

    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');
    return true;
};


exports.isValues = function (obj) {

    return obj[exports.symbols.values];
};


exports.limit = function (value) {

    return Number.isSafeInteger(value) && value >= 0;
};


exports.preferences = function (target, source) {

    Messages = Messages || __webpack_require__(/*! ./messages */ "./node_modules/joi/lib/messages.js");

    target = target || {};
    source = source || {};

    const merged = Object.assign({}, target, source);
    if (source.errors &&
        target.errors) {

        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
    }

    if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
    }

    delete merged[exports.symbols.prefs];
    return merged;
};


exports.tryWithPath = function (fn, key, options = {}) {

    try {
        return fn();
    }
    catch (err) {
        if (err.path !== undefined) {
            err.path = key + '.' + err.path;
        }
        else {
            err.path = key;
        }

        if (options.append) {
            err.message = `${err.message} (${err.path})`;
        }

        throw err;
    }
};


exports.validateArg = function (value, label, { assert, message }) {

    if (exports.isSchema(assert)) {
        const result = assert.validate(value);
        if (!result.error) {
            return;
        }

        return result.error.message;
    }
    else if (!assert(value)) {
        return label ? `${label} ${message}` : message;
    }
};


exports.verifyFlat = function (args, method) {

    for (const arg of args) {
        Assert(!Array.isArray(arg), 'Method no longer accepts array arguments:', method);
    }
};


/***/ }),

/***/ "./node_modules/joi/lib/compile.js":
/*!*****************************************!*\
  !*** ./node_modules/joi/lib/compile.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/joi/lib/ref.js");


const internals = {};


exports.schema = function (Joi, config, options = {}) {

    Common.assertOptions(options, ['appendPath', 'override']);

    try {
        return internals.schema(Joi, config, options);
    }
    catch (err) {
        if (options.appendPath &&
            err.path !== undefined) {

            err.message = `${err.message} (${err.path})`;
        }

        throw err;
    }
};


internals.schema = function (Joi, config, options) {

    Assert(config !== undefined, 'Invalid undefined schema');

    if (Array.isArray(config)) {
        Assert(config.length, 'Invalid empty array schema');

        if (config.length === 1) {
            config = config[0];
        }
    }

    const valid = (base, ...values) => {

        if (options.override !== false) {
            return base.valid(Joi.override, ...values);
        }

        return base.valid(...values);
    };

    if (internals.simple(config)) {
        return valid(Joi, config);
    }

    if (typeof config === 'function') {
        return Joi.custom(config);
    }

    Assert(typeof config === 'object', 'Invalid schema content:', typeof config);

    if (Common.isResolvable(config)) {
        return valid(Joi, config);
    }

    if (Common.isSchema(config)) {
        return config;
    }

    if (Array.isArray(config)) {
        for (const item of config) {
            if (!internals.simple(item)) {
                return Joi.alternatives().try(...config);
            }
        }

        return valid(Joi, ...config);
    }

    if (config instanceof RegExp) {
        return Joi.string().regex(config);
    }

    if (config instanceof Date) {
        return valid(Joi.date(), config);
    }

    Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');

    return Joi.object().keys(config);
};


exports.ref = function (id, options) {

    return Ref.isRef(id) ? id : Ref.create(id, options);
};


exports.compile = function (root, schema, options = {}) {

    Common.assertOptions(options, ['legacy']);

    // Compiled by any supported version

    const any = schema && schema[Common.symbols.any];
    if (any) {
        Assert(options.legacy || any.version === Common.version, 'Cannot mix different versions of joi schemas:', any.version, Common.version);
        return schema;
    }

    // Uncompiled root

    if (typeof schema !== 'object' ||
        !options.legacy) {

        return exports.schema(root, schema, { appendPath: true });          // Will error if schema contains other versions
    }

    // Scan schema for compiled parts

    const compiler = internals.walk(schema);
    if (!compiler) {
        return exports.schema(root, schema, { appendPath: true });
    }

    return compiler.compile(compiler.root, schema);
};


internals.walk = function (schema) {

    if (typeof schema !== 'object') {
        return null;
    }

    if (Array.isArray(schema)) {
        for (const item of schema) {
            const compiler = internals.walk(item);
            if (compiler) {
                return compiler;
            }
        }

        return null;
    }

    const any = schema[Common.symbols.any];
    if (any) {
        return { root: schema[any.root], compile: any.compile };
    }

    Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');

    for (const key in schema) {
        const compiler = internals.walk(schema[key]);
        if (compiler) {
            return compiler;
        }
    }

    return null;
};


internals.simple = function (value) {

    return value === null || ['boolean', 'string', 'number'].includes(typeof value);
};


exports.when = function (schema, condition, options) {

    if (options === undefined) {
        Assert(condition && typeof condition === 'object', 'Missing options');

        options = condition;
        condition = Ref.create('.');
    }

    if (Array.isArray(options)) {
        options = { switch: options };
    }

    Common.assertOptions(options, ['is', 'not', 'then', 'otherwise', 'switch', 'break']);

    // Schema condition

    if (Common.isSchema(condition)) {
        Assert(options.is === undefined, '"is" can not be used with a schema condition');
        Assert(options.not === undefined, '"not" can not be used with a schema condition');
        Assert(options.switch === undefined, '"switch" can not be used with a schema condition');

        return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
    }

    // Single condition

    Assert(Ref.isRef(condition) || typeof condition === 'string', 'Invalid condition:', condition);
    Assert(options.not === undefined || options.is === undefined, 'Cannot combine "is" with "not"');

    if (options.switch === undefined) {
        let rule = options;
        if (options.not !== undefined) {
            rule = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
        }

        let is = rule.is !== undefined ? schema.$_compile(rule.is) : schema.$_root.invalid(null, false, 0, '').required();
        Assert(rule.then !== undefined || rule.otherwise !== undefined, 'options must have at least one of "then", "otherwise", or "switch"');
        Assert(rule.break === undefined || rule.then === undefined || rule.otherwise === undefined, 'Cannot specify then, otherwise, and break all together');

        if (options.is !== undefined &&
            !Ref.isRef(options.is) &&
            !Common.isSchema(options.is)) {

            is = is.required();                     // Only apply required if this wasn't already a schema or a ref
        }

        return internals.condition(schema, { ref: exports.ref(condition), is, then: rule.then, otherwise: rule.otherwise, break: rule.break });
    }

    // Switch statement

    Assert(Array.isArray(options.switch), '"switch" must be an array');
    Assert(options.is === undefined, 'Cannot combine "switch" with "is"');
    Assert(options.not === undefined, 'Cannot combine "switch" with "not"');
    Assert(options.then === undefined, 'Cannot combine "switch" with "then"');

    const rule = {
        ref: exports.ref(condition),
        switch: [],
        break: options.break
    };

    for (let i = 0; i < options.switch.length; ++i) {
        const test = options.switch[i];
        const last = i === options.switch.length - 1;

        Common.assertOptions(test, last ? ['is', 'then', 'otherwise'] : ['is', 'then']);

        Assert(test.is !== undefined, 'Switch statement missing "is"');
        Assert(test.then !== undefined, 'Switch statement missing "then"');

        const item = {
            is: schema.$_compile(test.is),
            then: schema.$_compile(test.then)
        };

        if (!Ref.isRef(test.is) &&
            !Common.isSchema(test.is)) {

            item.is = item.is.required();           // Only apply required if this wasn't already a schema or a ref
        }

        if (last) {
            Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify "otherwise" inside and outside a "switch"');
            const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;
            if (otherwise !== undefined) {
                Assert(rule.break === undefined, 'Cannot specify both otherwise and break');
                item.otherwise = schema.$_compile(otherwise);
            }
        }

        rule.switch.push(item);
    }

    return rule;
};


internals.condition = function (schema, condition) {

    for (const key of ['then', 'otherwise']) {
        if (condition[key] === undefined) {
            delete condition[key];
        }
        else {
            condition[key] = schema.$_compile(condition[key]);
        }
    }

    return condition;
};


/***/ }),

/***/ "./node_modules/joi/lib/errors.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/errors.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Annotate = __webpack_require__(/*! ./annotate */ "./node_modules/joi/lib/annotate.js");
const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");
const Template = __webpack_require__(/*! ./template */ "./node_modules/joi/lib/template.js");


const internals = {};


exports.Report = class {

    constructor(code, value, local, flags, messages, state, prefs) {

        this.code = code;
        this.flags = flags;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;

        this.message = null;
        this.template = null;

        this.local = local || {};
        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);

        if (this.value !== undefined &&
            !this.local.hasOwnProperty('value')) {

            this.local.value = this.value;
        }

        if (this.path.length) {
            const key = this.path[this.path.length - 1];
            if (typeof key !== 'object') {
                this.local.key = key;
            }
        }
    }

    _setTemplate(template) {

        this.template = template;

        if (!this.flags.label &&
            this.path.length === 0) {

            const localized = this._template(this.template, 'root');
            if (localized) {
                this.local.label = localized;
            }
        }
    }

    toString() {

        if (this.message) {
            return this.message;
        }

        const code = this.code;

        if (!this.prefs.errors.render) {
            return this.code;
        }

        const template = this._template(this.template) ||
            this._template(this.prefs.messages) ||
            this._template(this.messages);

        if (template === undefined) {
            return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
        }

        // Render and cache result

        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
            this.message = this.message.replace(/^"" /, '').trim();
        }

        return this.message;
    }

    _template(messages, code) {

        return exports.template(this.value, messages, code || this.code, this.state, this.prefs);
    }
};


exports.path = function (path) {

    let label = '';
    for (const segment of path) {
        if (typeof segment === 'object') {          // Exclude array single path segment
            continue;
        }

        if (typeof segment === 'string') {
            if (label) {
                label += '.';
            }

            label += segment;
        }
        else {
            label += `[${segment}]`;
        }
    }

    return label;
};


exports.template = function (value, messages, code, state, prefs) {

    if (!messages) {
        return;
    }

    if (Template.isTemplate(messages)) {
        return code !== 'root' ? messages : null;
    }

    let lang = prefs.errors.language;
    if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
    }

    if (lang &&
        messages[lang]) {

        if (messages[lang][code] !== undefined) {
            return messages[lang][code];
        }

        if (messages[lang]['*'] !== undefined) {
            return messages[lang]['*'];
        }
    }

    if (!messages[code]) {
        return messages['*'];
    }

    return messages[code];
};


exports.label = function (flags, state, prefs, messages) {

    if (flags.label) {
        return flags.label;
    }

    if (!prefs.errors.label) {
        return '';
    }

    let path = state.path;
    if (prefs.errors.label === 'key' &&
        state.path.length > 1) {

        path = state.path.slice(-1);
    }

    const normalized = exports.path(path);
    if (normalized) {
        return normalized;
    }

    return exports.template(null, prefs.messages, 'root', state, prefs) ||
        messages && exports.template(null, messages, 'root', state, prefs) ||
        'value';
};


exports.process = function (errors, original, prefs) {

    if (!errors) {
        return null;
    }

    const { override, message, details } = exports.details(errors);
    if (override) {
        return override;
    }

    if (prefs.errors.stack) {
        return new exports.ValidationError(message, details, original);
    }

    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const validationError = new exports.ValidationError(message, details, original);
    Error.stackTraceLimit = limit;
    return validationError;
};


exports.details = function (errors, options = {}) {

    let messages = [];
    const details = [];

    for (const item of errors) {

        // Override

        if (item instanceof Error) {
            if (options.override !== false) {
                return { override: item };
            }

            const message = item.toString();
            messages.push(message);

            details.push({
                message,
                type: 'override',
                context: { error: item }
            });

            continue;
        }

        // Report

        const message = item.toString();
        messages.push(message);

        details.push({
            message,
            path: item.path.filter((v) => typeof v !== 'object'),
            type: item.code,
            context: item.local
        });
    }

    if (messages.length > 1) {
        messages = [...new Set(messages)];
    }

    return { message: messages.join('. '), details };
};


exports.ValidationError = class extends Error {

    constructor(message, details, original) {

        super(message);
        this._original = original;
        this.details = details;
    }

    static isError(err) {

        return err instanceof exports.ValidationError;
    }
};


exports.ValidationError.prototype.isJoi = true;

exports.ValidationError.prototype.name = 'ValidationError';

exports.ValidationError.prototype.annotate = Annotate.error;


/***/ }),

/***/ "./node_modules/joi/lib/extend.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/extend.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");
const Messages = __webpack_require__(/*! ./messages */ "./node_modules/joi/lib/messages.js");


const internals = {};


exports.type = function (from, options) {

    const base = Object.getPrototypeOf(from);
    const prototype = Clone(base);
    const schema = from._assign(Object.create(prototype));
    const def = Object.assign({}, options);                                 // Shallow cloned
    delete def.base;

    prototype._definition = def;

    const parent = base._definition || {};
    def.messages = Messages.merge(parent.messages, def.messages);
    def.properties = Object.assign({}, parent.properties, def.properties);

    // Type

    schema.type = def.type;

    // Flags

    def.flags = Object.assign({}, parent.flags, def.flags);

    // Terms

    const terms = Object.assign({}, parent.terms);
    if (def.terms) {
        for (const name in def.terms) {                                     // Only apply own terms
            const term = def.terms[name];
            Assert(schema.$_terms[name] === undefined, 'Invalid term override for', def.type, name);
            schema.$_terms[name] = term.init;
            terms[name] = term;
        }
    }

    def.terms = terms;

    // Constructor arguments

    if (!def.args) {
        def.args = parent.args;
    }

    // Prepare

    def.prepare = internals.prepare(def.prepare, parent.prepare);

    // Coerce

    if (def.coerce) {
        if (typeof def.coerce === 'function') {
            def.coerce = { method: def.coerce };
        }

        if (def.coerce.from &&
            !Array.isArray(def.coerce.from)) {

            def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
        }
    }

    def.coerce = internals.coerce(def.coerce, parent.coerce);

    // Validate

    def.validate = internals.validate(def.validate, parent.validate);

    // Rules

    const rules = Object.assign({}, parent.rules);
    if (def.rules) {
        for (const name in def.rules) {
            const rule = def.rules[name];
            Assert(typeof rule === 'object', 'Invalid rule definition for', def.type, name);

            let method = rule.method;
            if (method === undefined) {
                method = function () {

                    return this.$_addRule(name);
                };
            }

            if (method) {
                Assert(!prototype[name], 'Rule conflict in', def.type, name);
                prototype[name] = method;
            }

            Assert(!rules[name], 'Rule conflict in', def.type, name);
            rules[name] = rule;

            if (rule.alias) {
                const aliases = [].concat(rule.alias);
                for (const alias of aliases) {
                    prototype[alias] = rule.method;
                }
            }

            if (rule.args) {
                rule.argsByName = new Map();
                rule.args = rule.args.map((arg) => {

                    if (typeof arg === 'string') {
                        arg = { name: arg };
                    }

                    Assert(!rule.argsByName.has(arg.name), 'Duplicated argument name', arg.name);

                    if (Common.isSchema(arg.assert)) {
                        arg.assert = arg.assert.strict().label(arg.name);
                    }

                    rule.argsByName.set(arg.name, arg);
                    return arg;
                });
            }
        }
    }

    def.rules = rules;

    // Modifiers

    const modifiers = Object.assign({}, parent.modifiers);
    if (def.modifiers) {
        for (const name in def.modifiers) {
            Assert(!prototype[name], 'Rule conflict in', def.type, name);

            const modifier = def.modifiers[name];
            Assert(typeof modifier === 'function', 'Invalid modifier definition for', def.type, name);

            const method = function (arg) {

                return this.rule({ [name]: arg });
            };

            prototype[name] = method;
            modifiers[name] = modifier;
        }
    }

    def.modifiers = modifiers;

    // Overrides

    if (def.overrides) {
        prototype._super = base;
        schema.$_super = {};                                                            // Backwards compatibility
        for (const override in def.overrides) {
            Assert(base[override], 'Cannot override missing', override);
            def.overrides[override][Common.symbols.parent] = base[override];
            schema.$_super[override] = base[override].bind(schema);                     // Backwards compatibility
        }

        Object.assign(prototype, def.overrides);
    }

    // Casts

    def.cast = Object.assign({}, parent.cast, def.cast);

    // Manifest

    const manifest = Object.assign({}, parent.manifest, def.manifest);
    manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
    def.manifest = manifest;

    // Rebuild

    def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);

    return schema;
};


// Helpers

internals.build = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (obj, desc) {

        return parent(child(obj, desc), desc);
    };
};


internals.coerce = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return {
        from: child.from && parent.from ? [...new Set([...child.from, ...parent.from])] : null,
        method(value, helpers) {

            let coerced;
            if (!parent.from ||
                parent.from.includes(typeof value)) {

                coerced = parent.method(value, helpers);
                if (coerced) {
                    if (coerced.errors ||
                        coerced.value === undefined) {

                        return coerced;
                    }

                    value = coerced.value;
                }
            }

            if (!child.from ||
                child.from.includes(typeof value)) {

                const own = child.method(value, helpers);
                if (own) {
                    return own;
                }
            }

            return coerced;
        }
    };
};


internals.prepare = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (value, helpers) {

        const prepared = child(value, helpers);
        if (prepared) {
            if (prepared.errors ||
                prepared.value === undefined) {

                return prepared;
            }

            value = prepared.value;
        }

        return parent(value, helpers) || prepared;
    };
};


internals.rebuild = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (schema) {

        parent(schema);
        child(schema);
    };
};


internals.validate = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (value, helpers) {

        const result = parent(value, helpers);
        if (result) {
            if (result.errors &&
                (!Array.isArray(result.errors) || result.errors.length)) {

                return result;
            }

            value = result.value;
        }

        return child(value, helpers) || result;
    };
};


/***/ }),

/***/ "./node_modules/joi/lib/index.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Cache = __webpack_require__(/*! ./cache */ "./node_modules/joi/lib/cache.js");
const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");
const Compile = __webpack_require__(/*! ./compile */ "./node_modules/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/joi/lib/errors.js");
const Extend = __webpack_require__(/*! ./extend */ "./node_modules/joi/lib/extend.js");
const Manifest = __webpack_require__(/*! ./manifest */ "./node_modules/joi/lib/manifest.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/joi/lib/ref.js");
const Template = __webpack_require__(/*! ./template */ "./node_modules/joi/lib/template.js");
const Trace = __webpack_require__(/*! ./trace */ "./node_modules/joi/lib/trace.js");

let Schemas;


const internals = {
    types: {
        alternatives: __webpack_require__(/*! ./types/alternatives */ "./node_modules/joi/lib/types/alternatives.js"),
        any: __webpack_require__(/*! ./types/any */ "./node_modules/joi/lib/types/any.js"),
        array: __webpack_require__(/*! ./types/array */ "./node_modules/joi/lib/types/array.js"),
        boolean: __webpack_require__(/*! ./types/boolean */ "./node_modules/joi/lib/types/boolean.js"),
        date: __webpack_require__(/*! ./types/date */ "./node_modules/joi/lib/types/date.js"),
        function: __webpack_require__(/*! ./types/function */ "./node_modules/joi/lib/types/function.js"),
        link: __webpack_require__(/*! ./types/link */ "./node_modules/joi/lib/types/link.js"),
        number: __webpack_require__(/*! ./types/number */ "./node_modules/joi/lib/types/number.js"),
        object: __webpack_require__(/*! ./types/object */ "./node_modules/joi/lib/types/object.js"),
        string: __webpack_require__(/*! ./types/string */ "./node_modules/joi/lib/types/string.js"),
        symbol: __webpack_require__(/*! ./types/symbol */ "./node_modules/joi/lib/types/symbol.js")
    },
    aliases: {
        alt: 'alternatives',
        bool: 'boolean',
        func: 'function'
    }
};


if (Buffer) {                                                           // $lab:coverage:ignore$
    internals.types.binary = __webpack_require__(/*! ./types/binary */ "./node_modules/joi/lib/types/binary.js");
}


internals.root = function () {

    const root = {
        _types: new Set(Object.keys(internals.types))
    };

    // Types

    for (const type of root._types) {
        root[type] = function (...args) {

            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');
            return internals.generate(this, internals.types[type], args);
        };
    }

    // Shortcuts

    for (const method of ['allow', 'custom', 'disallow', 'equal', 'exist', 'forbidden', 'invalid', 'not', 'only', 'optional', 'options', 'prefs', 'preferences', 'required', 'strip', 'valid', 'when']) {
        root[method] = function (...args) {

            return this.any()[method](...args);
        };
    }

    // Methods

    Object.assign(root, internals.methods);

    // Aliases

    for (const alias in internals.aliases) {
        const target = internals.aliases[alias];
        root[alias] = root[target];
    }

    root.x = root.expression;

    // Trace

    if (Trace.setup) {                                          // $lab:coverage:ignore$
        Trace.setup(root);
    }

    return root;
};


internals.methods = {

    ValidationError: Errors.ValidationError,
    version: Common.version,
    cache: Cache.provider,

    assert(value, schema, ...args /* [message], [options] */) {

        internals.assert(value, schema, true, args);
    },

    attempt(value, schema, ...args /* [message], [options] */) {

        return internals.assert(value, schema, false, args);
    },

    build(desc) {

        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');
        return Manifest.build(this, desc);
    },

    checkPreferences(prefs) {

        Common.checkPreferences(prefs);
    },

    compile(schema, options) {

        return Compile.compile(this, schema, options);
    },

    defaults(modifier) {

        Assert(typeof modifier === 'function', 'modifier must be a function');

        const joi = Object.assign({}, this);
        for (const type of joi._types) {
            const schema = modifier(joi[type]());
            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');

            joi[type] = function (...args) {

                return internals.generate(this, schema, args);
            };
        }

        return joi;
    },

    expression(...args) {

        return new Template(...args);
    },

    extend(...extensions) {

        Common.verifyFlat(extensions, 'extend');

        Schemas = Schemas || __webpack_require__(/*! ./schemas */ "./node_modules/joi/lib/schemas.js");

        Assert(extensions.length, 'You need to provide at least one extension');
        this.assert(extensions, Schemas.extensions);

        const joi = Object.assign({}, this);
        joi._types = new Set(joi._types);

        for (let extension of extensions) {
            if (typeof extension === 'function') {
                extension = extension(joi);
            }

            this.assert(extension, Schemas.extension);

            const expanded = internals.expandExtension(extension, joi);
            for (const item of expanded) {
                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);

                const base = item.base || this.any();
                const schema = Extend.type(base, item);

                joi._types.add(item.type);
                joi[item.type] = function (...args) {

                    return internals.generate(this, schema, args);
                };
            }
        }

        return joi;
    },

    isError: Errors.ValidationError.isError,
    isExpression: Template.isTemplate,
    isRef: Ref.isRef,
    isSchema: Common.isSchema,

    in(...args) {

        return Ref.in(...args);
    },

    override: Common.symbols.override,

    ref(...args) {

        return Ref.create(...args);
    },

    types() {

        const types = {};
        for (const type of this._types) {
            types[type] = this[type]();
        }

        for (const target in internals.aliases) {
            types[target] = this[target]();
        }

        return types;
    }
};


// Helpers

internals.assert = function (value, schema, annotate, args /* [message], [options] */) {

    const message = args[0] instanceof Error || typeof args[0] === 'string' ? args[0] : null;
    const options = message ? args[1] : args[0];
    const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));

    let error = result.error;
    if (!error) {
        return result.value;
    }

    if (message instanceof Error) {
        throw message;
    }

    const display = annotate && typeof error.annotate === 'function' ? error.annotate() : error.message;

    if (error instanceof Errors.ValidationError === false) {
        error = Clone(error);
    }

    error.message = message ? `${message} ${display}` : display;
    throw error;
};


internals.generate = function (root, schema, args) {

    Assert(root, 'Must be invoked on a Joi instance.');

    schema.$_root = root;

    if (!schema._definition.args ||
        !args.length) {

        return schema;
    }

    return schema._definition.args(schema, ...args);
};


internals.expandExtension = function (extension, joi) {

    if (typeof extension.type === 'string') {
        return [extension];
    }

    const extended = [];
    for (const type of joi._types) {
        if (extension.type.test(type)) {
            const item = Object.assign({}, extension);
            item.type = type;
            item.base = joi[type]();
            extended.push(item);
        }
    }

    return extended;
};


module.exports = internals.root();


/***/ }),

/***/ "./node_modules/joi/lib/manifest.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/manifest.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");
const Messages = __webpack_require__(/*! ./messages */ "./node_modules/joi/lib/messages.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/joi/lib/ref.js");
const Template = __webpack_require__(/*! ./template */ "./node_modules/joi/lib/template.js");

let Schemas;


const internals = {};


exports.describe = function (schema) {

    const def = schema._definition;

    // Type

    const desc = {
        type: schema.type,
        flags: {},
        rules: []
    };

    // Flags

    for (const flag in schema._flags) {
        if (flag[0] !== '_') {
            desc.flags[flag] = internals.describe(schema._flags[flag]);
        }
    }

    if (!Object.keys(desc.flags).length) {
        delete desc.flags;
    }

    // Preferences

    if (schema._preferences) {
        desc.preferences = Clone(schema._preferences, { shallow: ['messages'] });
        delete desc.preferences[Common.symbols.prefs];
        if (desc.preferences.messages) {
            desc.preferences.messages = Messages.decompile(desc.preferences.messages);
        }
    }

    // Allow / Invalid

    if (schema._valids) {
        desc.allow = schema._valids.describe();
    }

    if (schema._invalids) {
        desc.invalid = schema._invalids.describe();
    }

    // Rules

    for (const rule of schema._rules) {
        const ruleDef = def.rules[rule.name];
        if (ruleDef.manifest === false) {                           // Defaults to true
            continue;
        }

        const item = { name: rule.name };

        for (const custom in def.modifiers) {
            if (rule[custom] !== undefined) {
                item[custom] = internals.describe(rule[custom]);
            }
        }

        if (rule.args) {
            item.args = {};
            for (const key in rule.args) {
                const arg = rule.args[key];
                if (key === 'options' &&
                    !Object.keys(arg).length) {

                    continue;
                }

                item.args[key] = internals.describe(arg, { assign: key });
            }

            if (!Object.keys(item.args).length) {
                delete item.args;
            }
        }

        desc.rules.push(item);
    }

    if (!desc.rules.length) {
        delete desc.rules;
    }

    // Terms (must be last to verify no name conflicts)

    for (const term in schema.$_terms) {
        if (term[0] === '_') {
            continue;
        }

        Assert(!desc[term], 'Cannot describe schema due to internal name conflict with', term);

        const items = schema.$_terms[term];
        if (!items) {
            continue;
        }

        if (items instanceof Map) {
            if (items.size) {
                desc[term] = [...items.entries()];
            }

            continue;
        }

        if (Common.isValues(items)) {
            desc[term] = items.describe();
            continue;
        }

        Assert(def.terms[term], 'Term', term, 'missing configuration');
        const manifest = def.terms[term].manifest;
        const mapped = typeof manifest === 'object';
        if (!items.length &&
            !mapped) {

            continue;
        }

        const normalized = [];
        for (const item of items) {
            normalized.push(internals.describe(item));
        }

        // Mapped

        if (mapped) {
            const { from, to } = manifest.mapped;
            desc[term] = {};
            for (const item of normalized) {
                desc[term][item[to]] = item[from];
            }

            continue;
        }

        // Single

        if (manifest === 'single') {
            Assert(normalized.length === 1, 'Term', term, 'contains more than one item');
            desc[term] = normalized[0];
            continue;
        }

        // Array

        desc[term] = normalized;
    }

    internals.validate(schema.$_root, desc);
    return desc;
};


internals.describe = function (item, options = {}) {

    if (Array.isArray(item)) {
        return item.map(internals.describe);
    }

    if (item === Common.symbols.deepDefault) {
        return { special: 'deep' };
    }

    if (typeof item !== 'object' ||
        item === null) {

        return item;
    }

    if (options.assign === 'options') {
        return Clone(item);
    }

    if (Buffer && Buffer.isBuffer(item)) {                          // $lab:coverage:ignore$
        return { buffer: item.toString('binary') };
    }

    if (item instanceof Date) {
        return item.toISOString();
    }

    if (item instanceof Error) {
        return item;
    }

    if (item instanceof RegExp) {
        if (options.assign === 'regex') {
            return item.toString();
        }

        return { regex: item.toString() };
    }

    if (item[Common.symbols.literal]) {
        return { function: item.literal };
    }

    if (typeof item.describe === 'function') {
        if (options.assign === 'ref') {
            return item.describe().ref;
        }

        return item.describe();
    }

    const normalized = {};
    for (const key in item) {
        const value = item[key];
        if (value === undefined) {
            continue;
        }

        normalized[key] = internals.describe(value, { assign: key });
    }

    return normalized;
};


exports.build = function (joi, desc) {

    const builder = new internals.Builder(joi);
    return builder.parse(desc);
};


internals.Builder = class {

    constructor(joi) {

        this.joi = joi;
    }

    parse(desc) {

        internals.validate(this.joi, desc);

        // Type

        let schema = this.joi[desc.type]()._bare();
        const def = schema._definition;

        // Flags

        if (desc.flags) {
            for (const flag in desc.flags) {
                const setter = def.flags[flag] && def.flags[flag].setter || flag;
                Assert(typeof schema[setter] === 'function', 'Invalid flag', flag, 'for type', desc.type);
                schema = schema[setter](this.build(desc.flags[flag]));
            }
        }

        // Preferences

        if (desc.preferences) {
            schema = schema.preferences(this.build(desc.preferences));
        }

        // Allow / Invalid

        if (desc.allow) {
            schema = schema.allow(...this.build(desc.allow));
        }

        if (desc.invalid) {
            schema = schema.invalid(...this.build(desc.invalid));
        }

        // Rules

        if (desc.rules) {
            for (const rule of desc.rules) {
                Assert(typeof schema[rule.name] === 'function', 'Invalid rule', rule.name, 'for type', desc.type);

                const args = [];
                if (rule.args) {
                    const built = {};
                    for (const key in rule.args) {
                        built[key] = this.build(rule.args[key], { assign: key });
                    }

                    const keys = Object.keys(built);
                    const definition = def.rules[rule.name].args;
                    if (definition) {
                        Assert(keys.length <= definition.length, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to', definition.length, ', found', keys.length, ')');
                        for (const { name } of definition) {
                            args.push(built[name]);
                        }
                    }
                    else {
                        Assert(keys.length === 1, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to 1, found', keys.length, ')');
                        args.push(built[keys[0]]);
                    }
                }

                // Apply

                schema = schema[rule.name](...args);

                // Ruleset

                const options = {};
                for (const custom in def.modifiers) {
                    if (rule[custom] !== undefined) {
                        options[custom] = this.build(rule[custom]);
                    }
                }

                if (Object.keys(options).length) {
                    schema = schema.rule(options);
                }
            }
        }

        // Terms

        const terms = {};
        for (const key in desc) {
            if (['allow', 'flags', 'invalid', 'whens', 'preferences', 'rules', 'type'].includes(key)) {
                continue;
            }

            Assert(def.terms[key], 'Term', key, 'missing configuration');
            const manifest = def.terms[key].manifest;

            if (manifest === 'schema') {
                terms[key] = desc[key].map((item) => this.parse(item));
                continue;
            }

            if (manifest === 'values') {
                terms[key] = desc[key].map((item) => this.build(item));
                continue;
            }

            if (manifest === 'single') {
                terms[key] = this.build(desc[key]);
                continue;
            }

            if (typeof manifest === 'object') {
                terms[key] = {};
                for (const name in desc[key]) {
                    const value = desc[key][name];
                    terms[key][name] = this.parse(value);
                }

                continue;
            }

            terms[key] = this.build(desc[key]);
        }

        if (desc.whens) {
            terms.whens = desc.whens.map((when) => this.build(when));
        }

        schema = def.manifest.build(schema, terms);
        schema.$_temp.ruleset = false;
        return schema;
    }

    build(desc, options = {}) {

        if (desc === null) {
            return null;
        }

        if (Array.isArray(desc)) {
            return desc.map((item) => this.build(item));
        }

        if (desc instanceof Error) {
            return desc;
        }

        if (options.assign === 'options') {
            return Clone(desc);
        }

        if (options.assign === 'regex') {
            return internals.regex(desc);
        }

        if (options.assign === 'ref') {
            return Ref.build(desc);
        }

        if (typeof desc !== 'object') {
            return desc;
        }

        if (Object.keys(desc).length === 1) {
            if (desc.buffer) {
                Assert(Buffer, 'Buffers are not supported');
                return Buffer && Buffer.from(desc.buffer, 'binary');                    // $lab:coverage:ignore$
            }

            if (desc.function) {
                return { [Common.symbols.literal]: true, literal: desc.function };
            }

            if (desc.override) {
                return Common.symbols.override;
            }

            if (desc.ref) {
                return Ref.build(desc.ref);
            }

            if (desc.regex) {
                return internals.regex(desc.regex);
            }

            if (desc.special) {
                Assert(['deep'].includes(desc.special), 'Unknown special value', desc.special);
                return Common.symbols.deepDefault;
            }

            if (desc.value) {
                return Clone(desc.value);
            }
        }

        if (desc.type) {
            return this.parse(desc);
        }

        if (desc.template) {
            return Template.build(desc);
        }

        const normalized = {};
        for (const key in desc) {
            normalized[key] = this.build(desc[key], { assign: key });
        }

        return normalized;
    }
};


internals.regex = function (string) {

    const end = string.lastIndexOf('/');
    const exp = string.slice(1, end);
    const flags = string.slice(end + 1);
    return new RegExp(exp, flags);
};


internals.validate = function (joi, desc) {

    Schemas = Schemas || __webpack_require__(/*! ./schemas */ "./node_modules/joi/lib/schemas.js");

    joi.assert(desc, Schemas.description);
};


/***/ }),

/***/ "./node_modules/joi/lib/messages.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/messages.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Template = __webpack_require__(/*! ./template */ "./node_modules/joi/lib/template.js");


const internals = {};


exports.compile = function (messages, target) {

    // Single value string ('plain error message', 'template {error} message')

    if (typeof messages === 'string') {
        Assert(!target, 'Cannot set single message string');
        return new Template(messages);
    }

    // Single value template

    if (Template.isTemplate(messages)) {
        Assert(!target, 'Cannot set single message template');
        return messages;
    }

    // By error code { 'number.min': <string | template> }

    Assert(typeof messages === 'object' && !Array.isArray(messages), 'Invalid message options');

    target = target ? Clone(target) : {};

    for (let code in messages) {
        const message = messages[code];

        if (code === 'root' ||
            Template.isTemplate(message)) {

            target[code] = message;
            continue;
        }

        if (typeof message === 'string') {
            target[code] = new Template(message);
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        Assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);

        const language = code;
        target[language] = target[language] || {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root' ||
                Template.isTemplate(localized)) {

                target[language][code] = localized;
                continue;
            }

            Assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);
            target[language][code] = new Template(localized);
        }
    }

    return target;
};


exports.decompile = function (messages) {

    // By error code { 'number.min': <string | template> }

    const target = {};
    for (let code in messages) {
        const message = messages[code];

        if (code === 'root') {
            target.root = message;
            continue;
        }

        if (Template.isTemplate(message)) {
            target[code] = message.describe({ compact: true });
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        const language = code;
        target[language] = {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root') {
                target[language].root = localized;
                continue;
            }

            target[language][code] = localized.describe({ compact: true });
        }
    }

    return target;
};


exports.merge = function (base, extended) {

    if (!base) {
        return exports.compile(extended);
    }

    if (!extended) {
        return base;
    }

    // Single value string

    if (typeof extended === 'string') {
        return new Template(extended);
    }

    // Single value template

    if (Template.isTemplate(extended)) {
        return extended;
    }

    // By error code { 'number.min': <string | template> }

    const target = Clone(base);

    for (let code in extended) {
        const message = extended[code];

        if (code === 'root' ||
            Template.isTemplate(message)) {

            target[code] = message;
            continue;
        }

        if (typeof message === 'string') {
            target[code] = new Template(message);
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        Assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);

        const language = code;
        target[language] = target[language] || {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root' ||
                Template.isTemplate(localized)) {

                target[language][code] = localized;
                continue;
            }

            Assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);
            target[language][code] = new Template(localized);
        }
    }

    return target;
};


/***/ }),

/***/ "./node_modules/joi/lib/modify.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/modify.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/joi/lib/ref.js");


const internals = {};



exports.Ids = internals.Ids = class {

    constructor() {

        this._byId = new Map();
        this._byKey = new Map();
        this._schemaChain = false;
    }

    clone() {

        const clone = new internals.Ids();
        clone._byId = new Map(this._byId);
        clone._byKey = new Map(this._byKey);
        clone._schemaChain = this._schemaChain;
        return clone;
    }

    concat(source) {

        if (source._schemaChain) {
            this._schemaChain = true;
        }

        for (const [id, value] of source._byId.entries()) {
            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);
            this._byId.set(id, value);
        }

        for (const [key, value] of source._byKey.entries()) {
            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);
            this._byKey.set(key, value);
        }
    }

    fork(path, adjuster, root) {

        const chain = this._collect(path);
        chain.push({ schema: root });
        const tail = chain.shift();
        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };

        Assert(Common.isSchema(adjusted.schema), 'adjuster function failed to return a joi schema type');

        for (const node of chain) {
            adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };
        }

        return adjusted.schema;
    }

    labels(path, behind = []) {

        const current = path[0];
        const node = this._get(current);
        if (!node) {
            return [...behind, ...path].join('.');
        }

        const forward = path.slice(1);
        behind = [...behind, node.schema._flags.label || current];
        if (!forward.length) {
            return behind.join('.');
        }

        return node.schema._ids.labels(forward, behind);
    }

    reach(path, behind = []) {

        const current = path[0];
        const node = this._get(current);
        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));

        const forward = path.slice(1);
        if (!forward.length) {
            return node.schema;
        }

        return node.schema._ids.reach(forward, [...behind, current]);
    }

    register(schema, { key } = {}) {

        if (!schema ||
            !Common.isSchema(schema)) {

            return;
        }

        if (schema.$_property('schemaChain') ||
            schema._ids._schemaChain) {

            this._schemaChain = true;
        }

        const id = schema._flags.id;
        if (id) {
            const existing = this._byId.get(id);
            Assert(!existing || existing.schema === schema, 'Cannot add different schemas with the same id:', id);
            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);

            this._byId.set(id, { schema, id });
        }

        if (key) {
            Assert(!this._byKey.has(key), 'Schema already contains key:', key);
            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);

            this._byKey.set(key, { schema, id: key });
        }
    }

    reset() {

        this._byId = new Map();
        this._byKey = new Map();
        this._schemaChain = false;
    }

    _collect(path, behind = [], nodes = []) {

        const current = path[0];
        const node = this._get(current);
        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));

        nodes = [node, ...nodes];

        const forward = path.slice(1);
        if (!forward.length) {
            return nodes;
        }

        return node.schema._ids._collect(forward, [...behind, current], nodes);
    }

    _get(id) {

        return this._byId.get(id) || this._byKey.get(id);
    }
};


internals.fork = function (schema, id, replacement) {

    const each = (item, { key }) => {

        if (id === (item._flags.id || key)) {
            return replacement;
        }
    };

    const obj = exports.schema(schema, { each, ref: false });
    return obj ? obj.$_mutateRebuild() : schema;
};


exports.schema = function (schema, options) {

    let obj;

    for (const name in schema._flags) {
        if (name[0] === '_') {
            continue;
        }

        const result = internals.scan(schema._flags[name], { source: 'flags', name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            obj._flags[name] = result;
        }
    }

    for (let i = 0; i < schema._rules.length; ++i) {
        const rule = schema._rules[i];
        const result = internals.scan(rule.args, { source: 'rules', name: rule.name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            const clone = Object.assign({}, rule);
            clone.args = result;
            obj._rules[i] = clone;

            const existingUnique = obj._singleRules.get(rule.name);
            if (existingUnique === rule) {
                obj._singleRules.set(rule.name, clone);
            }
        }
    }

    for (const name in schema.$_terms) {
        if (name[0] === '_') {
            continue;
        }

        const result = internals.scan(schema.$_terms[name], { source: 'terms', name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            obj.$_terms[name] = result;
        }
    }

    return obj;
};


internals.scan = function (item, source, options, _path, _key) {

    const path = _path || [];

    if (item === null ||
        typeof item !== 'object') {

        return;
    }

    let clone;

    if (Array.isArray(item)) {
        for (let i = 0; i < item.length; ++i) {
            const key = source.source === 'terms' && source.name === 'keys' && item[i].key;
            const result = internals.scan(item[i], source, options, [i, ...path], key);
            if (result !== undefined) {
                clone = clone || item.slice();
                clone[i] = result;
            }
        }

        return clone;
    }

    if (options.schema !== false && Common.isSchema(item) ||
        options.ref !== false && Ref.isRef(item)) {

        const result = options.each(item, { ...source, path, key: _key });
        if (result === item) {
            return;
        }

        return result;
    }

    for (const key in item) {
        if (key[0] === '_') {
            continue;
        }

        const result = internals.scan(item[key], source, options, [key, ...path], _key);
        if (result !== undefined) {
            clone = clone || Object.assign({}, item);
            clone[key] = result;
        }
    }

    return clone;
};


/***/ }),

/***/ "./node_modules/joi/lib/ref.js":
/*!*************************************!*\
  !*** ./node_modules/joi/lib/ref.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");

let Template;


const internals = {
    symbol: Symbol('ref'),      // Used to internally identify references (shared with other joi versions)
    defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: '.',
        type: 'value'
    }
};


exports.create = function (key, options = {}) {

    Assert(typeof key === 'string', 'Invalid reference key:', key);
    Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'prefix', 'render', 'separator']);
    Assert(!options.prefix || typeof options.prefix === 'object', 'options.prefix must be of type object');

    const ref = Object.assign({}, internals.defaults, options);
    delete ref.prefix;

    const separator = ref.separator;
    const context = internals.context(key, separator, options.prefix);
    ref.type = context.type;
    key = context.key;

    if (ref.type === 'value') {
        if (context.root) {
            Assert(!separator || key[0] !== separator, 'Cannot specify relative path with root prefix');
            ref.ancestor = 'root';
            if (!key) {
                key = null;
            }
        }

        if (separator &&
            separator === key) {

            key = null;
            ref.ancestor = 0;
        }
        else {
            if (ref.ancestor !== undefined) {
                Assert(!separator || !key || key[0] !== separator, 'Cannot combine prefix with ancestor option');
            }
            else {
                const [ancestor, slice] = internals.ancestor(key, separator);
                if (slice) {
                    key = key.slice(slice);
                    if (key === '') {
                        key = null;
                    }
                }

                ref.ancestor = ancestor;
            }
        }
    }

    ref.path = separator ? (key === null ? [] : key.split(separator)) : [key];

    return new internals.Ref(ref);
};


exports["in"] = function (key, options = {}) {

    return exports.create(key, { ...options, in: true });
};


exports.isRef = function (ref) {

    return ref ? !!ref[Common.symbols.ref] : false;
};


internals.Ref = class {

    constructor(options) {

        Assert(typeof options === 'object', 'Invalid reference construction');
        Common.assertOptions(options, [
            'adjust', 'ancestor', 'in', 'iterables', 'map', 'path', 'render', 'separator', 'type',  // Copied
            'depth', 'key', 'root', 'display'                                                       // Overridden
        ]);

        Assert([false, undefined].includes(options.separator) || typeof options.separator === 'string' && options.separator.length === 1, 'Invalid separator');
        Assert(!options.adjust || typeof options.adjust === 'function', 'options.adjust must be a function');
        Assert(!options.map || Array.isArray(options.map), 'options.map must be an array');
        Assert(!options.map || !options.adjust, 'Cannot set both map and adjust options');

        Object.assign(this, internals.defaults, options);

        Assert(this.type === 'value' || this.ancestor === undefined, 'Non-value references cannot reference ancestors');

        if (Array.isArray(this.map)) {
            this.map = new Map(this.map);
        }

        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];

        this.updateDisplay();
    }

    resolve(value, state, prefs, local, options = {}) {

        Assert(!this.in || options.in, 'Invalid in() reference usage');

        if (this.type === 'global') {
            return this._resolve(prefs.context, state, options);
        }

        if (this.type === 'local') {
            return this._resolve(local, state, options);
        }

        if (!this.ancestor) {
            return this._resolve(value, state, options);
        }

        if (this.ancestor === 'root') {
            return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
        }

        Assert(this.ancestor <= state.ancestors.length, 'Invalid reference exceeds the schema root:', this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options);
    }

    _resolve(target, state, options) {

        let resolved;

        if (this.type === 'value' &&
            state.mainstay.shadow &&
            options.shadow !== false) {

            resolved = state.mainstay.shadow.get(this.absolute(state));
        }

        if (resolved === undefined) {
            resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
        }

        if (this.adjust) {
            resolved = this.adjust(resolved);
        }

        if (this.map) {
            const mapped = this.map.get(resolved);
            if (mapped !== undefined) {
                resolved = mapped;
            }
        }

        if (state.mainstay) {
            state.mainstay.tracer.resolve(state, this, resolved);
        }

        return resolved;
    }

    toString() {

        return this.display;
    }

    absolute(state) {

        return [...state.path.slice(0, -this.ancestor), ...this.path];
    }

    clone() {

        return new internals.Ref(this);
    }

    describe() {

        const ref = { path: this.path };

        if (this.type !== 'value') {
            ref.type = this.type;
        }

        if (this.separator !== '.') {
            ref.separator = this.separator;
        }

        if (this.type === 'value' &&
            this.ancestor !== 1) {

            ref.ancestor = this.ancestor;
        }

        if (this.map) {
            ref.map = [...this.map];
        }

        for (const key of ['adjust', 'iterables', 'render']) {
            if (this[key] !== null &&
                this[key] !== undefined) {

                ref[key] = this[key];
            }
        }

        if (this.in !== false) {
            ref.in = true;
        }

        return { ref };
    }

    updateDisplay() {

        const key = this.key !== null ? this.key : '';
        if (this.type !== 'value') {
            this.display = `ref:${this.type}:${key}`;
            return;
        }

        if (!this.separator) {
            this.display = `ref:${key}`;
            return;
        }

        if (!this.ancestor) {
            this.display = `ref:${this.separator}${key}`;
            return;
        }

        if (this.ancestor === 'root') {
            this.display = `ref:root:${key}`;
            return;
        }

        if (this.ancestor === 1) {
            this.display = `ref:${key || '..'}`;
            return;
        }

        const lead = new Array(this.ancestor + 1).fill(this.separator).join('');
        this.display = `ref:${lead}${key || ''}`;
    }
};


internals.Ref.prototype[Common.symbols.ref] = true;


exports.build = function (desc) {

    desc = Object.assign({}, internals.defaults, desc);
    if (desc.type === 'value' &&
        desc.ancestor === undefined) {

        desc.ancestor = 1;
    }

    return new internals.Ref(desc);
};


internals.context = function (key, separator, prefix = {}) {

    key = key.trim();

    if (prefix) {
        const globalp = prefix.global === undefined ? '$' : prefix.global;
        if (globalp !== separator &&
            key.startsWith(globalp)) {

            return { key: key.slice(globalp.length), type: 'global' };
        }

        const local = prefix.local === undefined ? '#' : prefix.local;
        if (local !== separator &&
            key.startsWith(local)) {

            return { key: key.slice(local.length), type: 'local' };
        }

        const root = prefix.root === undefined ? '/' : prefix.root;
        if (root !== separator &&
            key.startsWith(root)) {

            return { key: key.slice(root.length), type: 'value', root: true };
        }
    }

    return { key, type: 'value' };
};


internals.ancestor = function (key, separator) {

    if (!separator) {
        return [1, 0];              // 'a_b' -> 1 (parent)
    }

    if (key[0] !== separator) {     // 'a.b' -> 1 (parent)
        return [1, 0];
    }

    if (key[1] !== separator) {     // '.a.b' -> 0 (self)
        return [0, 1];
    }

    let i = 2;
    while (key[i] === separator) {
        ++i;
    }

    return [i - 1, i];              // '...a.b.' -> 2 (grandparent)
};


exports.toSibling = 0;

exports.toParent = 1;


exports.Manager = class {

    constructor() {

        this.refs = [];                     // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...
    }

    register(source, target) {

        if (!source) {
            return;
        }

        target = target === undefined ? exports.toParent : target;

        // Array

        if (Array.isArray(source)) {
            for (const ref of source) {
                this.register(ref, target);
            }

            return;
        }

        // Schema

        if (Common.isSchema(source)) {
            for (const item of source._refs.refs) {
                if (item.ancestor - target >= 0) {
                    this.refs.push({ ancestor: item.ancestor - target, root: item.root });
                }
            }

            return;
        }

        // Reference

        if (exports.isRef(source) &&
            source.type === 'value' &&
            source.ancestor - target >= 0) {

            this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }

        // Template

        Template = Template || __webpack_require__(/*! ./template */ "./node_modules/joi/lib/template.js");

        if (Template.isTemplate(source)) {
            this.register(source.refs(), target);
        }
    }

    get length() {

        return this.refs.length;
    }

    clone() {

        const copy = new exports.Manager();
        copy.refs = Clone(this.refs);
        return copy;
    }

    reset() {

        this.refs = [];
    }

    roots() {

        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
    }
};


/***/ }),

/***/ "./node_modules/joi/lib/schemas.js":
/*!*****************************************!*\
  !*** ./node_modules/joi/lib/schemas.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Joi = __webpack_require__(/*! ./index */ "./node_modules/joi/lib/index.js");


const internals = {};


// Preferences

internals.wrap = Joi.string()
    .min(1)
    .max(2)
    .allow(false);


exports.preferences = Joi.object({
    allowUnknown: Joi.boolean(),
    abortEarly: Joi.boolean(),
    artifacts: Joi.boolean(),
    cache: Joi.boolean(),
    context: Joi.object(),
    convert: Joi.boolean(),
    dateFormat: Joi.valid('date', 'iso', 'string', 'time', 'utc'),
    debug: Joi.boolean(),
    errors: {
        escapeHtml: Joi.boolean(),
        label: Joi.valid('path', 'key', false),
        language: [
            Joi.string(),
            Joi.object().ref()
        ],
        render: Joi.boolean(),
        stack: Joi.boolean(),
        wrap: {
            label: internals.wrap,
            array: internals.wrap,
            string: internals.wrap
        }
    },
    externals: Joi.boolean(),
    messages: Joi.object(),
    noDefaults: Joi.boolean(),
    nonEnumerables: Joi.boolean(),
    presence: Joi.valid('required', 'optional', 'forbidden'),
    skipFunctions: Joi.boolean(),
    stripUnknown: Joi.object({
        arrays: Joi.boolean(),
        objects: Joi.boolean()
    })
        .or('arrays', 'objects')
        .allow(true, false),
    warnings: Joi.boolean()
})
    .strict();


// Extensions

internals.nameRx = /^[a-zA-Z0-9]\w*$/;


internals.rule = Joi.object({
    alias: Joi.array().items(Joi.string().pattern(internals.nameRx)).single(),
    args: Joi.array().items(
        Joi.string(),
        Joi.object({
            name: Joi.string().pattern(internals.nameRx).required(),
            ref: Joi.boolean(),
            assert: Joi.alternatives([
                Joi.function(),
                Joi.object().schema()
            ])
                .conditional('ref', { is: true, then: Joi.required() }),
            normalize: Joi.function(),
            message: Joi.string().when('assert', { is: Joi.function(), then: Joi.required() })
        })
    ),
    convert: Joi.boolean(),
    manifest: Joi.boolean(),
    method: Joi.function().allow(false),
    multi: Joi.boolean(),
    validate: Joi.function()
});


exports.extension = Joi.object({
    type: Joi.alternatives([
        Joi.string(),
        Joi.object().regex()
    ])
        .required(),
    args: Joi.function(),
    cast: Joi.object().pattern(internals.nameRx, Joi.object({
        from: Joi.function().maxArity(1).required(),
        to: Joi.function().minArity(1).maxArity(2).required()
    })),
    base: Joi.object().schema()
        .when('type', { is: Joi.object().regex(), then: Joi.forbidden() }),
    coerce: [
        Joi.function().maxArity(3),
        Joi.object({ method: Joi.function().maxArity(3).required(), from: Joi.array().items(Joi.string()).single() })
    ],
    flags: Joi.object().pattern(internals.nameRx, Joi.object({
        setter: Joi.string(),
        default: Joi.any()
    })),
    manifest: {
        build: Joi.function().arity(2)
    },
    messages: [Joi.object(), Joi.string()],
    modifiers: Joi.object().pattern(internals.nameRx, Joi.function().minArity(1).maxArity(2)),
    overrides: Joi.object().pattern(internals.nameRx, Joi.function()),
    prepare: Joi.function().maxArity(3),
    rebuild: Joi.function().arity(1),
    rules: Joi.object().pattern(internals.nameRx, internals.rule),
    terms: Joi.object().pattern(internals.nameRx, Joi.object({
        init: Joi.array().allow(null).required(),
        manifest: Joi.object().pattern(/.+/, [
            Joi.valid('schema', 'single'),
            Joi.object({
                mapped: Joi.object({
                    from: Joi.string().required(),
                    to: Joi.string().required()
                })
                    .required()
            })
        ])
    })),
    validate: Joi.function().maxArity(3)
})
    .strict();


exports.extensions = Joi.array().items(Joi.object(), Joi.function().arity(1)).strict();


// Manifest

internals.desc = {

    buffer: Joi.object({
        buffer: Joi.string()
    }),

    func: Joi.object({
        function: Joi.function().required(),
        options: {
            literal: true
        }
    }),

    override: Joi.object({
        override: true
    }),

    ref: Joi.object({
        ref: Joi.object({
            type: Joi.valid('value', 'global', 'local'),
            path: Joi.array().required(),
            separator: Joi.string().length(1).allow(false),
            ancestor: Joi.number().min(0).integer().allow('root'),
            map: Joi.array().items(Joi.array().length(2)).min(1),
            adjust: Joi.function(),
            iterables: Joi.boolean(),
            in: Joi.boolean(),
            render: Joi.boolean()
        })
            .required()
    }),

    regex: Joi.object({
        regex: Joi.string().min(3)
    }),

    special: Joi.object({
        special: Joi.valid('deep').required()
    }),

    template: Joi.object({
        template: Joi.string().required(),
        options: Joi.object()
    }),

    value: Joi.object({
        value: Joi.alternatives([Joi.object(), Joi.array()]).required()
    })
};


internals.desc.entity = Joi.alternatives([
    Joi.array().items(Joi.link('...')),
    Joi.boolean(),
    Joi.function(),
    Joi.number(),
    Joi.string(),
    internals.desc.buffer,
    internals.desc.func,
    internals.desc.ref,
    internals.desc.regex,
    internals.desc.special,
    internals.desc.template,
    internals.desc.value,
    Joi.link('/')
]);


internals.desc.values = Joi.array()
    .items(
        null,
        Joi.boolean(),
        Joi.function(),
        Joi.number().allow(Infinity, -Infinity),
        Joi.string().allow(''),
        Joi.symbol(),
        internals.desc.buffer,
        internals.desc.func,
        internals.desc.override,
        internals.desc.ref,
        internals.desc.regex,
        internals.desc.template,
        internals.desc.value
    );


internals.desc.messages = Joi.object()
    .pattern(/.+/, [
        Joi.string(),
        internals.desc.template,
        Joi.object().pattern(/.+/, [Joi.string(), internals.desc.template])
    ]);


exports.description = Joi.object({
    type: Joi.string().required(),
    flags: Joi.object({
        cast: Joi.string(),
        default: Joi.any(),
        description: Joi.string(),
        empty: Joi.link('/'),
        failover: internals.desc.entity,
        id: Joi.string(),
        label: Joi.string(),
        only: true,
        presence: ['optional', 'required', 'forbidden'],
        result: ['raw', 'strip'],
        strip: Joi.boolean(),
        unit: Joi.string()
    })
        .unknown(),
    preferences: {
        allowUnknown: Joi.boolean(),
        abortEarly: Joi.boolean(),
        artifacts: Joi.boolean(),
        cache: Joi.boolean(),
        convert: Joi.boolean(),
        dateFormat: ['date', 'iso', 'string', 'time', 'utc'],
        errors: {
            escapeHtml: Joi.boolean(),
            label: ['path', 'key'],
            language: [
                Joi.string(),
                internals.desc.ref
            ],
            wrap: {
                label: internals.wrap,
                array: internals.wrap
            }
        },
        externals: Joi.boolean(),
        messages: internals.desc.messages,
        noDefaults: Joi.boolean(),
        nonEnumerables: Joi.boolean(),
        presence: ['required', 'optional', 'forbidden'],
        skipFunctions: Joi.boolean(),
        stripUnknown: Joi.object({
            arrays: Joi.boolean(),
            objects: Joi.boolean()
        })
            .or('arrays', 'objects')
            .allow(true, false),
        warnings: Joi.boolean()
    },
    allow: internals.desc.values,
    invalid: internals.desc.values,
    rules: Joi.array().min(1).items({
        name: Joi.string().required(),
        args: Joi.object().min(1),
        keep: Joi.boolean(),
        message: [
            Joi.string(),
            internals.desc.messages
        ],
        warn: Joi.boolean()
    }),

    // Terms

    keys: Joi.object().pattern(/.*/, Joi.link('/')),
    link: internals.desc.ref
})
    .pattern(/^[a-z]\w*$/, Joi.any());


/***/ }),

/***/ "./node_modules/joi/lib/state.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/state.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");


const internals = {
    value: Symbol('value')
};


module.exports = internals.State = class {

    constructor(path, ancestors, state) {

        this.path = path;
        this.ancestors = ancestors;                 // [parent, ..., root]

        this.mainstay = state.mainstay;
        this.schemas = state.schemas;               // [current, ..., root]
        this.debug = null;
    }

    localize(path, ancestors = null, schema = null) {

        const state = new internals.State(path, ancestors, this);

        if (schema &&
            state.schemas) {

            state.schemas = [internals.schemas(schema), ...state.schemas];
        }

        return state;
    }

    nest(schema, debug) {

        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];
        state.debug = debug;
        return state;
    }

    shadow(value, reason) {

        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
    }

    snapshot() {

        if (this.mainstay.shadow) {
            this._snapshot = Clone(this.mainstay.shadow.node(this.path));
        }
    }

    restore() {

        if (this.mainstay.shadow) {
            this.mainstay.shadow.override(this.path, this._snapshot);
            this._snapshot = undefined;
        }
    }
};


internals.schemas = function (schema) {

    if (Common.isSchema(schema)) {
        return { schema };
    }

    return schema;
};


internals.Shadow = class {

    constructor() {

        this._values = null;
    }

    set(path, value, reason) {

        if (!path.length) {                                     // No need to store root value
            return;
        }

        if (reason === 'strip' &&
            typeof path[path.length - 1] === 'number') {        // Cannot store stripped array values (due to shift)

            return;
        }

        this._values = this._values || new Map();

        let node = this._values;
        for (let i = 0; i < path.length; ++i) {
            const segment = path[i];
            let next = node.get(segment);
            if (!next) {
                next = new Map();
                node.set(segment, next);
            }

            node = next;
        }

        node[internals.value] = value;
    }

    get(path) {

        const node = this.node(path);
        if (node) {
            return node[internals.value];
        }
    }

    node(path) {

        if (!this._values) {
            return;
        }

        return Reach(this._values, path, { iterables: true });
    }

    override(path, node) {

        if (!this._values) {
            return;
        }

        const parents = path.slice(0, -1);
        const own = path[path.length - 1];
        const parent = Reach(this._values, parents, { iterables: true });

        if (node) {
            parent.set(own, node);
            return;
        }

        if (parent) {
            parent.delete(own);
        }
    }
};


/***/ }),

/***/ "./node_modules/joi/lib/template.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/template.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const EscapeHtml = __webpack_require__(/*! @hapi/hoek/lib/escapeHtml */ "./node_modules/@hapi/hoek/lib/escapeHtml.js");
const Formula = __webpack_require__(/*! @sideway/formula */ "./node_modules/@sideway/formula/lib/index.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/joi/lib/errors.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/joi/lib/ref.js");


const internals = {
    symbol: Symbol('template'),

    opens: new Array(1000).join('\u0000'),
    closes: new Array(1000).join('\u0001'),

    dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
    }
};


module.exports = exports = internals.Template = class {

    constructor(source, options) {

        Assert(typeof source === 'string', 'Template source must be a string');
        Assert(!source.includes('\u0000') && !source.includes('\u0001'), 'Template source cannot contain reserved control characters');

        this.source = source;
        this.rendered = source;

        this._template = null;
        this._settings = Clone(options);

        this._parse();
    }

    _parse() {

        // 'text {raw} {{ref}} \\{{ignore}} {{ignore\\}} {{ignore {{ignore}'

        if (!this.source.includes('{')) {
            return;
        }

        // Encode escaped \\{{{{{

        const encoded = internals.encode(this.source);

        // Split on first { in each set

        const parts = internals.split(encoded);

        // Process parts

        let refs = false;
        const processed = [];
        const head = parts.shift();
        if (head) {
            processed.push(head);
        }

        for (const part of parts) {
            const raw = part[0] !== '{';
            const ender = raw ? '}' : '}}';
            const end = part.indexOf(ender);
            if (end === -1 ||                               // Ignore non-matching closing
                part[1] === '{') {                          // Ignore more than two {

                processed.push(`{${internals.decode(part)}`);
                continue;
            }

            let variable = part.slice(raw ? 0 : 1, end);
            const wrapped = variable[0] === ':';
            if (wrapped) {
                variable = variable.slice(1);
            }

            const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
            processed.push(dynamic);
            if (typeof dynamic !== 'string') {
                refs = true;
            }

            const rest = part.slice(end + ender.length);
            if (rest) {
                processed.push(internals.decode(rest));
            }
        }

        if (!refs) {
            this.rendered = processed.join('');
            return;
        }

        this._template = processed;
    }

    static date(date, prefs) {

        return internals.dateFormat[prefs.dateFormat].call(date);
    }

    describe(options = {}) {

        if (!this._settings &&
            options.compact) {

            return this.source;
        }

        const desc = { template: this.source };
        if (this._settings) {
            desc.options = this._settings;
        }

        return desc;
    }

    static build(desc) {

        return new internals.Template(desc.template, desc.options);
    }

    isDynamic() {

        return !!this._template;
    }

    static isTemplate(template) {

        return template ? !!template[Common.symbols.template] : false;
    }

    refs() {

        if (!this._template) {
            return;
        }

        const refs = [];
        for (const part of this._template) {
            if (typeof part !== 'string') {
                refs.push(...part.refs);
            }
        }

        return refs;
    }

    resolve(value, state, prefs, local) {

        if (this._template &&
            this._template.length === 1) {

            return this._part(this._template[0], /* context -> [*/ value, state, prefs, local, {} /*] */);
        }

        return this.render(value, state, prefs, local);
    }

    _part(part, ...args) {

        if (part.ref) {
            return part.ref.resolve(...args);
        }

        return part.formula.evaluate(args);
    }

    render(value, state, prefs, local, options = {}) {

        if (!this.isDynamic()) {
            return this.rendered;
        }

        const parts = [];
        for (const part of this._template) {
            if (typeof part === 'string') {
                parts.push(part);
            }
            else {
                const rendered = this._part(part, /* context -> [*/ value, state, prefs, local, options /*] */);
                const string = internals.stringify(rendered, value, state, prefs, local, options);
                if (string !== undefined) {
                    const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);
                    parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
                }
            }
        }

        return parts.join('');
    }

    _ref(content, { raw, wrapped }) {

        const refs = [];
        const reference = (variable) => {

            const ref = Ref.create(variable, this._settings);
            refs.push(ref);
            return (context) => ref.resolve(...context);
        };

        try {
            var formula = new Formula.Parser(content, { reference, functions: internals.functions, constants: internals.constants });
        }
        catch (err) {
            err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
            throw err;
        }

        if (formula.single) {
            if (formula.single.type === 'reference') {
                const ref = refs[0];
                return { ref, raw, refs, wrapped: wrapped || ref.type === 'local' && ref.key === 'label' };
            }

            return internals.stringify(formula.single.value);
        }

        return { formula, raw, refs };
    }

    toString() {

        return this.source;
    }
};


internals.Template.prototype[Common.symbols.template] = true;
internals.Template.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects


internals.encode = function (string) {

    return string
        .replace(/\\(\{+)/g, ($0, $1) => {

            return internals.opens.slice(0, $1.length);
        })
        .replace(/\\(\}+)/g, ($0, $1) => {

            return internals.closes.slice(0, $1.length);
        });
};


internals.decode = function (string) {

    return string
        .replace(/\u0000/g, '{')
        .replace(/\u0001/g, '}');
};


internals.split = function (string) {

    const parts = [];
    let current = '';

    for (let i = 0; i < string.length; ++i) {
        const char = string[i];

        if (char === '{') {
            let next = '';
            while (i + 1 < string.length &&
                string[i + 1] === '{') {

                next += '{';
                ++i;
            }

            parts.push(current);
            current = next;
        }
        else {
            current += char;
        }
    }

    parts.push(current);
    return parts;
};


internals.wrap = function (value, ends) {

    if (!ends) {
        return value;
    }

    if (ends.length === 1) {
        return `${ends}${value}${ends}`;
    }

    return `${ends[0]}${value}${ends[1]}`;
};


internals.stringify = function (value, original, state, prefs, local, options = {}) {

    const type = typeof value;
    const wrap = prefs && prefs.errors && prefs.errors.wrap || {};

    let skipWrap = false;
    if (Ref.isRef(value) &&
        value.render) {

        skipWrap = value.in;
        value = value.resolve(original, state, prefs, local, { in: value.in, ...options });
    }

    if (value === null) {
        return 'null';
    }

    if (type === 'string') {
        return internals.wrap(value, options.arrayItems && wrap.string);
    }

    if (type === 'number' ||
        type === 'function' ||
        type === 'symbol') {

        return value.toString();
    }

    if (type !== 'object') {
        return JSON.stringify(value);
    }

    if (value instanceof Date) {
        return internals.Template.date(value, prefs);
    }

    if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
            pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }

        value = pairs;
    }

    if (!Array.isArray(value)) {
        return value.toString();
    }

    const values = [];
    for (const item of value) {
        values.push(internals.stringify(item, original, state, prefs, local, { arrayItems: true, ...options }));
    }

    return internals.wrap(values.join(', '), !skipWrap && wrap.array);
};


internals.constants = {

    true: true,
    false: false,
    null: null,

    second: 1000,
    minute: 60 * 1000,
    hour: 60 * 60 * 1000,
    day: 24 * 60 * 60 * 1000
};


internals.functions = {

    if(condition, then, otherwise) {

        return condition ? then : otherwise;
    },

    length(item) {

        if (typeof item === 'string') {
            return item.length;
        }

        if (!item || typeof item !== 'object') {
            return null;
        }

        if (Array.isArray(item)) {
            return item.length;
        }

        return Object.keys(item).length;
    },

    msg(code) {

        const [value, state, prefs, local, options] = this;
        const messages = options.messages;
        if (!messages) {
            return '';
        }

        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);
        if (!template) {
            return '';
        }

        return template.render(value, state, prefs, local, options);
    },

    number(value) {

        if (typeof value === 'number') {
            return value;
        }

        if (typeof value === 'string') {
            return parseFloat(value);
        }

        if (typeof value === 'boolean') {
            return value ? 1 : 0;
        }

        if (value instanceof Date) {
            return value.getTime();
        }

        return null;
    }
};


/***/ }),

/***/ "./node_modules/joi/lib/trace.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/trace.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const Pinpoint = __webpack_require__(/*! @sideway/pinpoint */ "./node_modules/@sideway/pinpoint/lib/index.js");

const Errors = __webpack_require__(/*! ./errors */ "./node_modules/joi/lib/errors.js");


const internals = {
    codes: {
        error: 1,
        pass: 2,
        full: 3
    },
    labels: {
        0: 'never used',
        1: 'always error',
        2: 'always pass'
    }
};


exports.setup = function (root) {

    const trace = function () {

        root._tracer = root._tracer || new internals.Tracer();
        return root._tracer;
    };

    root.trace = trace;
    root[Symbol.for('@hapi/lab/coverage/initialize')] = trace;

    root.untrace = () => {

        root._tracer = null;
    };
};


exports.location = function (schema) {

    return schema.$_setFlag('_tracerLocation', Pinpoint.location(2));                       // base.tracer(), caller
};


internals.Tracer = class {

    constructor() {

        this.name = 'Joi';
        this._schemas = new Map();
    }

    _register(schema) {

        const existing = this._schemas.get(schema);
        if (existing) {
            return existing.store;
        }

        const store = new internals.Store(schema);
        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);   // internals.tracer(), internals.entry(), exports.entry(), validate(), caller
        this._schemas.set(schema, { filename, line, store });
        return store;
    }

    _combine(merged, sources) {

        for (const { store } of this._schemas.values()) {
            store._combine(merged, sources);
        }
    }

    report(file) {

        const coverage = [];

        // Process each registered schema

        for (const { filename, line, store } of this._schemas.values()) {
            if (file &&
                file !== filename) {

                continue;
            }

            // Process sub schemas of the registered root

            const missing = [];
            const skipped = [];

            for (const [schema, log] of store._sources.entries()) {

                // Check if sub schema parent skipped

                if (internals.sub(log.paths, skipped)) {
                    continue;
                }

                // Check if sub schema reached

                if (!log.entry) {
                    missing.push({
                        status: 'never reached',
                        paths: [...log.paths]
                    });

                    skipped.push(...log.paths);
                    continue;
                }

                // Check values

                for (const type of ['valid', 'invalid']) {
                    const set = schema[`_${type}s`];
                    if (!set) {
                        continue;
                    }

                    const values = new Set(set._values);
                    const refs = new Set(set._refs);
                    for (const { value, ref } of log[type]) {
                        values.delete(value);
                        refs.delete(ref);
                    }

                    if (values.size ||
                        refs.size) {

                        missing.push({
                            status: [...values, ...[...refs].map((ref) => ref.display)],
                            rule: `${type}s`
                        });
                    }
                }

                // Check rules status

                const rules = schema._rules.map((rule) => rule.name);
                for (const type of ['default', 'failover']) {
                    if (schema._flags[type] !== undefined) {
                        rules.push(type);
                    }
                }

                for (const name of rules) {
                    const status = internals.labels[log.rule[name] || 0];
                    if (status) {
                        const report = { rule: name, status };
                        if (log.paths.size) {
                            report.paths = [...log.paths];
                        }

                        missing.push(report);
                    }
                }
            }

            if (missing.length) {
                coverage.push({
                    filename,
                    line,
                    missing,
                    severity: 'error',
                    message: `Schema missing tests for ${missing.map(internals.message).join(', ')}`
                });
            }
        }

        return coverage.length ? coverage : null;
    }
};


internals.Store = class {

    constructor(schema) {

        this.active = true;
        this._sources = new Map();          // schema -> { paths, entry, rule, valid, invalid }
        this._combos = new Map();           // merged -> [sources]
        this._scan(schema);
    }

    debug(state, source, name, result) {

        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });
    }

    entry(schema, state) {

        internals.debug(state, { type: 'entry' });

        this._record(schema, (log) => {

            log.entry = true;
        });
    }

    filter(schema, state, source, value) {

        internals.debug(state, { type: source, ...value });

        this._record(schema, (log) => {

            log[source].add(value);
        });
    }

    log(schema, state, source, name, result) {

        internals.debug(state, { type: source, name, result: result === 'full' ? 'pass' : result });

        this._record(schema, (log) => {

            log[source][name] = log[source][name] || 0;
            log[source][name] |= internals.codes[result];
        });
    }

    resolve(state, ref, to) {

        if (!state.mainstay.debug) {
            return;
        }

        const log = { type: 'resolve', ref: ref.display, to, path: state.path };
        state.mainstay.debug.push(log);
    }

    value(state, by, from, to, name) {

        if (!state.mainstay.debug ||
            DeepEqual(from, to)) {

            return;
        }

        const log = { type: 'value', by, from, to, path: state.path };
        if (name) {
            log.name = name;
        }

        state.mainstay.debug.push(log);
    }

    _record(schema, each) {

        const log = this._sources.get(schema);
        if (log) {
            each(log);
            return;
        }

        const sources = this._combos.get(schema);
        for (const source of sources) {
            this._record(source, each);
        }
    }

    _scan(schema, _path) {

        const path = _path || [];

        let log = this._sources.get(schema);
        if (!log) {
            log = {
                paths: new Set(),
                entry: false,
                rule: {},
                valid: new Set(),
                invalid: new Set()
            };

            this._sources.set(schema, log);
        }

        if (path.length) {
            log.paths.add(path);
        }

        const each = (sub, source) => {

            const subId = internals.id(sub, source);
            this._scan(sub, path.concat(subId));
        };

        schema.$_modify({ each, ref: false });
    }

    _combine(merged, sources) {

        this._combos.set(merged, sources);
    }
};


internals.message = function (item) {

    const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ':' : '') : '';
    return `${path}${item.rule || ''} (${item.status})`;
};


internals.id = function (schema, { source, name, path, key }) {

    if (schema._flags.id) {
        return schema._flags.id;
    }

    if (key) {
        return key;
    }

    name = `@${name}`;

    if (source === 'terms') {
        return [name, path[Math.min(path.length - 1, 1)]];
    }

    return name;
};


internals.sub = function (paths, skipped) {

    for (const path of paths) {
        for (const skip of skipped) {
            if (DeepEqual(path.slice(0, skip.length), skip)) {
                return true;
            }
        }
    }

    return false;
};


internals.debug = function (state, event) {

    if (state.mainstay.debug) {
        event.path = state.debug ? [...state.path, state.debug] : state.path;
        state.mainstay.debug.push(event);
    }
};


/***/ }),

/***/ "./node_modules/joi/lib/types/alternatives.js":
/*!****************************************************!*\
  !*** ./node_modules/joi/lib/types/alternatives.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Merge = __webpack_require__(/*! @hapi/hoek/lib/merge */ "./node_modules/@hapi/hoek/lib/merge.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ../errors */ "./node_modules/joi/lib/errors.js");
const Ref = __webpack_require__(/*! ../ref */ "./node_modules/joi/lib/ref.js");


const internals = {};


module.exports = Any.extend({

    type: 'alternatives',

    flags: {

        match: { default: 'any' }                 // 'any', 'one', 'all'
    },

    terms: {

        matches: { init: [], register: Ref.toSibling }
    },

    args(schema, ...schemas) {

        if (schemas.length === 1) {
            if (Array.isArray(schemas[0])) {
                return schema.try(...schemas[0]);
            }
        }

        return schema.try(...schemas);
    },

    validate(value, helpers) {

        const { schema, error, state, prefs } = helpers;

        // Match all or one

        if (schema._flags.match) {
            const matched = [];
            const failed = [];

            for (let i = 0; i < schema.$_terms.matches.length; ++i) {
                const item = schema.$_terms.matches[i];
                const localState = state.nest(item.schema, `match.${i}`);
                localState.snapshot();

                const result = item.schema.$_validate(value, localState, prefs);
                if (!result.errors) {
                    matched.push(result.value);
                }
                else {
                    failed.push(result.errors);
                    localState.restore();
                }
            }

            if (matched.length === 0) {
                const context = {
                    details: failed.map((f) => Errors.details(f, { override: false }))
                };

                return { errors: error('alternatives.any', context) };
            }

            // Match one

            if (schema._flags.match === 'one') {
                return matched.length === 1 ? { value: matched[0] } : { errors: error('alternatives.one') };
            }

            // Match all

            if (matched.length !== schema.$_terms.matches.length) {
                const context = {
                    details: failed.map((f) => Errors.details(f, { override: false }))
                };

                return { errors: error('alternatives.all', context) };
            }

            const isAnyObj = (alternative) => {

                return alternative.$_terms.matches.some((v) => {

                    return v.schema.type === 'object' ||
                        (v.schema.type === 'alternatives' && isAnyObj(v.schema));
                });
            };

            return isAnyObj(schema) ? { value: matched.reduce((acc, v) => Merge(acc, v, { mergeArrays: false })) } : { value: matched[matched.length - 1] };
        }

        // Match any

        const errors = [];
        for (let i = 0; i < schema.$_terms.matches.length; ++i) {
            const item = schema.$_terms.matches[i];

            // Try

            if (item.schema) {
                const localState = state.nest(item.schema, `match.${i}`);
                localState.snapshot();

                const result = item.schema.$_validate(value, localState, prefs);
                if (!result.errors) {
                    return result;
                }

                localState.restore();
                errors.push({ schema: item.schema, reports: result.errors });
                continue;
            }

            // Conditional

            const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
            const tests = item.is ? [item] : item.switch;

            for (let j = 0; j < tests.length; ++j) {
                const test = tests[j];
                const { is, then, otherwise } = test;

                const id = `match.${i}${item.switch ? '.' + j : ''}`;
                if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
                    if (otherwise) {
                        return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
                    }
                }
                else if (then) {
                    return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
                }
            }
        }

        return internals.errors(errors, helpers);
    },

    rules: {

        conditional: {
            method(condition, options) {

                Assert(!this._flags._endedSwitch, 'Unreachable condition');
                Assert(!this._flags.match, 'Cannot combine match mode', this._flags.match, 'with conditional rule');
                Assert(options.break === undefined, 'Cannot use break option with alternatives conditional');

                const obj = this.clone();

                const match = Compile.when(obj, condition, options);
                const conditions = match.is ? [match] : match.switch;
                for (const item of conditions) {
                    if (item.then &&
                        item.otherwise) {

                        obj.$_setFlag('_endedSwitch', true, { clone: false });
                        break;
                    }
                }

                obj.$_terms.matches.push(match);
                return obj.$_mutateRebuild();
            }
        },

        match: {
            method(mode) {

                Assert(['any', 'one', 'all'].includes(mode), 'Invalid alternatives match mode', mode);

                if (mode !== 'any') {
                    for (const match of this.$_terms.matches) {
                        Assert(match.schema, 'Cannot combine match mode', mode, 'with conditional rules');
                    }
                }

                return this.$_setFlag('match', mode);
            }
        },

        try: {
            method(...schemas) {

                Assert(schemas.length, 'Missing alternative schemas');
                Common.verifyFlat(schemas, 'try');

                Assert(!this._flags._endedSwitch, 'Unreachable condition');

                const obj = this.clone();
                for (const schema of schemas) {
                    obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
                }

                return obj.$_mutateRebuild();
            }
        }
    },

    overrides: {

        label(name) {

            const obj = this.$_parent('label', name);
            const each = (item, source) => (source.path[0] !== 'is' ? item.label(name) : undefined);
            return obj.$_modify({ each, ref: false });
        }
    },

    rebuild(schema) {

        // Flag when an alternative type is an array

        const each = (item) => {

            if (Common.isSchema(item) &&
                item.type === 'array') {

                schema.$_setFlag('_arrayItems', true, { clone: false });
            }
        };

        schema.$_modify({ each });
    },

    manifest: {

        build(obj, desc) {

            if (desc.matches) {
                for (const match of desc.matches) {
                    const { schema, ref, is, not, then, otherwise } = match;
                    if (schema) {
                        obj = obj.try(schema);
                    }
                    else if (ref) {
                        obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });
                    }
                    else {
                        obj = obj.conditional(is, { then, otherwise });
                    }
                }
            }

            return obj;
        }
    },

    messages: {
        'alternatives.all': '{{#label}} does not match all of the required types',
        'alternatives.any': '{{#label}} does not match any of the allowed types',
        'alternatives.match': '{{#label}} does not match any of the allowed types',
        'alternatives.one': '{{#label}} matches more than one allowed type',
        'alternatives.types': '{{#label}} must be one of {{#types}}'
    }
});


// Helpers

internals.errors = function (failures, { error, state }) {

    // Nothing matched due to type criteria rules

    if (!failures.length) {
        return { errors: error('alternatives.any') };
    }

    // Single error

    if (failures.length === 1) {
        return { errors: failures[0].reports };
    }

    // Analyze reasons

    const valids = new Set();
    const complex = [];

    for (const { reports, schema } of failures) {

        // Multiple errors (!abortEarly)

        if (reports.length > 1) {
            return internals.unmatched(failures, error);
        }

        // Custom error

        const report = reports[0];
        if (report instanceof Errors.Report === false) {
            return internals.unmatched(failures, error);
        }

        // Internal object or array error

        if (report.state.path.length !== state.path.length) {
            complex.push({ type: schema.type, report });
            continue;
        }

        // Valids

        if (report.code === 'any.only') {
            for (const valid of report.local.valids) {
                valids.add(valid);
            }

            continue;
        }

        // Base type

        const [type, code] = report.code.split('.');
        if (code !== 'base') {
            complex.push({ type: schema.type, report });
            continue;
        }

        valids.add(type);
    }

    // All errors are base types or valids

    if (!complex.length) {
        return { errors: error('alternatives.types', { types: [...valids] }) };
    }

    // Single complex error

    if (complex.length === 1) {
        return { errors: complex[0].report };
    }

    return internals.unmatched(failures, error);
};


internals.unmatched = function (failures, error) {

    const errors = [];
    for (const failure of failures) {
        errors.push(...failure.reports);
    }

    return { errors: error('alternatives.match', Errors.details(errors, { override: false })) };
};


/***/ }),

/***/ "./node_modules/joi/lib/types/any.js":
/*!*******************************************!*\
  !*** ./node_modules/joi/lib/types/any.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Base = __webpack_require__(/*! ../base */ "./node_modules/joi/lib/base.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/joi/lib/common.js");
const Messages = __webpack_require__(/*! ../messages */ "./node_modules/joi/lib/messages.js");


const internals = {};


module.exports = Base.extend({

    type: 'any',

    flags: {

        only: { default: false }
    },

    terms: {

        alterations: { init: null },
        examples: { init: null },
        externals: { init: null },
        metas: { init: [] },
        notes: { init: [] },
        shared: { init: null },
        tags: { init: [] },
        whens: { init: null }
    },

    rules: {

        custom: {
            method(method, description) {

                Assert(typeof method === 'function', 'Method must be a function');
                Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');

                return this.$_addRule({ name: 'custom', args: { method, description } });
            },
            validate(value, helpers, { method }) {

                try {
                    return method(value, helpers);
                }
                catch (err) {
                    return helpers.error('any.custom', { error: err });
                }
            },
            args: ['method', 'description'],
            multi: true
        },

        messages: {
            method(messages) {

                return this.prefs({ messages });
            }
        },

        shared: {
            method(schema) {

                Assert(Common.isSchema(schema) && schema._flags.id, 'Schema must be a schema with an id');

                const obj = this.clone();
                obj.$_terms.shared = obj.$_terms.shared || [];
                obj.$_terms.shared.push(schema);
                obj.$_mutateRegister(schema);
                return obj;
            }
        },

        warning: {
            method(code, local) {

                Assert(code && typeof code === 'string', 'Invalid warning code');

                return this.$_addRule({ name: 'warning', args: { code, local }, warn: true });
            },
            validate(value, helpers, { code, local }) {

                return helpers.error(code, local);
            },
            args: ['code', 'local'],
            multi: true
        }
    },

    modifiers: {

        keep(rule, enabled = true) {

            rule.keep = enabled;
        },

        message(rule, message) {

            rule.message = Messages.compile(message);
        },

        warn(rule, enabled = true) {

            rule.warn = enabled;
        }
    },

    manifest: {

        build(obj, desc) {

            for (const key in desc) {
                const values = desc[key];

                if (['examples', 'externals', 'metas', 'notes', 'tags'].includes(key)) {
                    for (const value of values) {
                        obj = obj[key.slice(0, -1)](value);
                    }

                    continue;
                }

                if (key === 'alterations') {
                    const alter = {};
                    for (const { target, adjuster } of values) {
                        alter[target] = adjuster;
                    }

                    obj = obj.alter(alter);
                    continue;
                }

                if (key === 'whens') {
                    for (const value of values) {
                        const { ref, is, not, then, otherwise, concat } = value;
                        if (concat) {
                            obj = obj.concat(concat);
                        }
                        else if (ref) {
                            obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });
                        }
                        else {
                            obj = obj.when(is, { then, otherwise, break: value.break });
                        }
                    }

                    continue;
                }

                if (key === 'shared') {
                    for (const value of values) {
                        obj = obj.shared(value);
                    }
                }
            }

            return obj;
        }
    },

    messages: {
        'any.custom': '{{#label}} failed custom validation because {{#error.message}}',
        'any.default': '{{#label}} threw an error when running default method',
        'any.failover': '{{#label}} threw an error when running failover method',
        'any.invalid': '{{#label}} contains an invalid value',
        'any.only': '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
        'any.ref': '{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}',
        'any.required': '{{#label}} is required',
        'any.unknown': '{{#label}} is not allowed'
    }
});


/***/ }),

/***/ "./node_modules/joi/lib/types/array.js":
/*!*********************************************!*\
  !*** ./node_modules/joi/lib/types/array.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/joi/lib/compile.js");


const internals = {};


module.exports = Any.extend({

    type: 'array',

    flags: {

        single: { default: false },
        sparse: { default: false }
    },

    terms: {

        items: { init: [], manifest: 'schema' },
        ordered: { init: [], manifest: 'schema' },

        _exclusions: { init: [] },
        _inclusions: { init: [] },
        _requireds: { init: [] }
    },

    coerce: {
        from: 'object',
        method(value, { schema, state, prefs }) {

            if (!Array.isArray(value)) {
                return;
            }

            const sort = schema.$_getRule('sort');
            if (!sort) {
                return;
            }

            return internals.sort(schema, value, sort.args.options, state, prefs);
        }
    },

    validate(value, { schema, error }) {

        if (!Array.isArray(value)) {
            if (schema._flags.single) {
                const single = [value];
                single[Common.symbols.arraySingle] = true;
                return { value: single };
            }

            return { errors: error('array.base') };
        }

        if (!schema.$_getRule('items') &&
            !schema.$_terms.externals) {

            return;
        }

        return { value: value.slice() };        // Clone the array so that we don't modify the original
    },

    rules: {

        has: {
            method(schema) {

                schema = this.$_compile(schema, { appendPath: true });
                const obj = this.$_addRule({ name: 'has', args: { schema } });
                obj.$_mutateRegister(schema);
                return obj;
            },
            validate(value, { state, prefs, error }, { schema: has }) {

                const ancestors = [value, ...state.ancestors];
                for (let i = 0; i < value.length; ++i) {
                    const localState = state.localize([...state.path, i], ancestors, has);
                    if (has.$_match(value[i], localState, prefs)) {
                        return value;
                    }
                }

                const patternLabel = has._flags.label;
                if (patternLabel) {
                    return error('array.hasKnown', { patternLabel });
                }

                return error('array.hasUnknown', null);
            },
            multi: true
        },

        items: {
            method(...schemas) {

                Common.verifyFlat(schemas, 'items');

                const obj = this.$_addRule('items');

                for (let i = 0; i < schemas.length; ++i) {
                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
                    obj.$_terms.items.push(type);
                }

                return obj.$_mutateRebuild();
            },
            validate(value, { schema, error, state, prefs, errorsArray }) {

                const requireds = schema.$_terms._requireds.slice();
                const ordereds = schema.$_terms.ordered.slice();
                const inclusions = [...schema.$_terms._inclusions, ...requireds];

                const wasArray = !value[Common.symbols.arraySingle];
                delete value[Common.symbols.arraySingle];

                const errors = errorsArray();

                let il = value.length;
                for (let i = 0; i < il; ++i) {
                    const item = value[i];

                    let errored = false;
                    let isValid = false;

                    const key = wasArray ? i : new Number(i);       // eslint-disable-line no-new-wrappers
                    const path = [...state.path, key];

                    // Sparse

                    if (!schema._flags.sparse &&
                        item === undefined) {

                        errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }

                        ordereds.shift();
                        continue;
                    }

                    // Exclusions

                    const ancestors = [value, ...state.ancestors];

                    for (const exclusion of schema.$_terms._exclusions) {
                        if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: 'ignore' })) {
                            continue;
                        }

                        errors.push(error('array.excludes', { pos: i, value: item }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }

                        errored = true;
                        ordereds.shift();
                        break;
                    }

                    if (errored) {
                        continue;
                    }

                    // Ordered

                    if (schema.$_terms.ordered.length) {
                        if (ordereds.length) {
                            const ordered = ordereds.shift();
                            const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                            if (!res.errors) {
                                if (ordered._flags.result === 'strip') {
                                    internals.fastSplice(value, i);
                                    --i;
                                    --il;
                                }
                                else if (!schema._flags.sparse && res.value === undefined) {
                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                    if (prefs.abortEarly) {
                                        return errors;
                                    }

                                    continue;
                                }
                                else {
                                    value[i] = res.value;
                                }
                            }
                            else {
                                errors.push(...res.errors);
                                if (prefs.abortEarly) {
                                    return errors;
                                }
                            }

                            continue;
                        }
                        else if (!schema.$_terms.items.length) {
                            errors.push(error('array.orderedLength', { pos: i, limit: schema.$_terms.ordered.length }));
                            if (prefs.abortEarly) {
                                return errors;
                            }

                            break;      // No reason to continue since there are no other rules to validate other than array.orderedLength
                        }
                    }

                    // Requireds

                    const requiredChecks = [];
                    let jl = requireds.length;
                    for (let j = 0; j < jl; ++j) {
                        const localState = state.localize(path, ancestors, requireds[j]);
                        localState.snapshot();

                        const res = requireds[j].$_validate(item, localState, prefs);
                        requiredChecks[j] = res;

                        if (!res.errors) {
                            value[i] = res.value;
                            isValid = true;
                            internals.fastSplice(requireds, j);
                            --j;
                            --jl;

                            if (!schema._flags.sparse &&
                                res.value === undefined) {

                                errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                if (prefs.abortEarly) {
                                    return errors;
                                }
                            }

                            break;
                        }

                        localState.restore();
                    }

                    if (isValid) {
                        continue;
                    }

                    // Inclusions

                    const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;

                    jl = inclusions.length;
                    for (const inclusion of inclusions) {

                        // Avoid re-running requireds that already didn't match in the previous loop

                        let res;
                        const previousCheck = requireds.indexOf(inclusion);
                        if (previousCheck !== -1) {
                            res = requiredChecks[previousCheck];
                        }
                        else {
                            const localState = state.localize(path, ancestors, inclusion);
                            localState.snapshot();

                            res = inclusion.$_validate(item, localState, prefs);
                            if (!res.errors) {
                                if (inclusion._flags.result === 'strip') {
                                    internals.fastSplice(value, i);
                                    --i;
                                    --il;
                                }
                                else if (!schema._flags.sparse &&
                                    res.value === undefined) {

                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                    errored = true;
                                }
                                else {
                                    value[i] = res.value;
                                }

                                isValid = true;
                                break;
                            }

                            localState.restore();
                        }

                        // Return the actual error if only one inclusion defined

                        if (jl === 1) {
                            if (stripUnknown) {
                                internals.fastSplice(value, i);
                                --i;
                                --il;
                                isValid = true;
                                break;
                            }

                            errors.push(...res.errors);
                            if (prefs.abortEarly) {
                                return errors;
                            }

                            errored = true;
                            break;
                        }
                    }

                    if (errored) {
                        continue;
                    }

                    if ((schema.$_terms._inclusions.length || schema.$_terms._requireds.length) &&
                        !isValid) {

                        if (stripUnknown) {
                            internals.fastSplice(value, i);
                            --i;
                            --il;
                            continue;
                        }

                        errors.push(error('array.includes', { pos: i, value: item }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }
                    }
                }

                if (requireds.length) {
                    internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
                }

                if (ordereds.length) {
                    internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);

                    if (!errors.length) {
                        internals.fillDefault(ordereds, value, state, prefs);
                    }
                }

                return errors.length ? errors : value;
            },

            priority: true,
            manifest: false
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value.length, limit, operator)) {
                    return value;
                }

                return helpers.error('array.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        },

        ordered: {
            method(...schemas) {

                Common.verifyFlat(schemas, 'ordered');

                const obj = this.$_addRule('items');

                for (let i = 0; i < schemas.length; ++i) {
                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
                    internals.validateSingle(type, obj);

                    obj.$_mutateRegister(type);
                    obj.$_terms.ordered.push(type);
                }

                return obj.$_mutateRebuild();
            }
        },

        single: {
            method(enabled) {

                const value = enabled === undefined ? true : !!enabled;
                Assert(!value || !this._flags._arrayItems, 'Cannot specify single rule when array has array items');

                return this.$_setFlag('single', value);
            }
        },

        sort: {
            method(options = {}) {

                Common.assertOptions(options, ['by', 'order']);

                const settings = {
                    order: options.order || 'ascending'
                };

                if (options.by) {
                    settings.by = Compile.ref(options.by, { ancestor: 0 });
                    Assert(!settings.by.ancestor, 'Cannot sort by ancestor');
                }

                return this.$_addRule({ name: 'sort', args: { options: settings } });
            },
            validate(value, { error, state, prefs, schema }, { options }) {

                const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);
                if (errors) {
                    return errors;
                }

                for (let i = 0; i < value.length; ++i) {
                    if (value[i] !== sorted[i]) {
                        return error('array.sort', { order: options.order, by: options.by ? options.by.key : 'value' });
                    }
                }

                return value;
            },
            convert: true
        },

        sparse: {
            method(enabled) {

                const value = enabled === undefined ? true : !!enabled;

                if (this._flags.sparse === value) {
                    return this;
                }

                const obj = value ? this.clone() : this.$_addRule('items');
                return obj.$_setFlag('sparse', value, { clone: false });
            }
        },

        unique: {
            method(comparator, options = {}) {

                Assert(!comparator || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');
                Common.assertOptions(options, ['ignoreUndefined', 'separator']);

                const rule = { name: 'unique', args: { options, comparator } };

                if (comparator) {
                    if (typeof comparator === 'string') {
                        const separator = Common.default(options.separator, '.');
                        rule.path = separator ? comparator.split(separator) : [comparator];
                    }
                    else {
                        rule.comparator = comparator;
                    }
                }

                return this.$_addRule(rule);
            },
            validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {

                const found = {
                    string: Object.create(null),
                    number: Object.create(null),
                    undefined: Object.create(null),
                    boolean: Object.create(null),
                    object: new Map(),
                    function: new Map(),
                    custom: new Map()
                };

                const compare = comparator || DeepEqual;
                const ignoreUndefined = options.ignoreUndefined;

                for (let i = 0; i < value.length; ++i) {
                    const item = path ? Reach(value[i], path) : value[i];
                    const records = comparator ? found.custom : found[typeof item];
                    Assert(records, 'Failed to find unique map container for type', typeof item);

                    if (records instanceof Map) {
                        const entries = records.entries();
                        let current;
                        while (!(current = entries.next()).done) {
                            if (compare(current.value[0], item)) {
                                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                                const context = {
                                    pos: i,
                                    value: value[i],
                                    dupePos: current.value[1],
                                    dupeValue: value[current.value[1]]
                                };

                                if (path) {
                                    context.path = raw;
                                }

                                return error('array.unique', context, localState);
                            }
                        }

                        records.set(item, i);
                    }
                    else {
                        if ((!ignoreUndefined || item !== undefined) &&
                            records[item] !== undefined) {

                            const context = {
                                pos: i,
                                value: value[i],
                                dupePos: records[item],
                                dupeValue: value[records[item]]
                            };

                            if (path) {
                                context.path = raw;
                            }

                            const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                            return error('array.unique', context, localState);
                        }

                        records[item] = i;
                    }
                }

                return value;
            },
            args: ['comparator', 'options'],
            multi: true
        }
    },

    cast: {
        set: {
            from: Array.isArray,
            to(value, helpers) {

                return new Set(value);
            }
        }
    },

    rebuild(schema) {

        schema.$_terms._inclusions = [];
        schema.$_terms._exclusions = [];
        schema.$_terms._requireds = [];

        for (const type of schema.$_terms.items) {
            internals.validateSingle(type, schema);

            if (type._flags.presence === 'required') {
                schema.$_terms._requireds.push(type);
            }
            else if (type._flags.presence === 'forbidden') {
                schema.$_terms._exclusions.push(type);
            }
            else {
                schema.$_terms._inclusions.push(type);
            }
        }

        for (const type of schema.$_terms.ordered) {
            internals.validateSingle(type, schema);
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.items) {
                obj = obj.items(...desc.items);
            }

            if (desc.ordered) {
                obj = obj.ordered(...desc.ordered);
            }

            return obj;
        }
    },

    messages: {
        'array.base': '{{#label}} must be an array',
        'array.excludes': '{{#label}} contains an excluded value',
        'array.hasKnown': '{{#label}} does not contain at least one required match for type {:#patternLabel}',
        'array.hasUnknown': '{{#label}} does not contain at least one required match',
        'array.includes': '{{#label}} does not match any of the allowed types',
        'array.includesRequiredBoth': '{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)',
        'array.includesRequiredKnowns': '{{#label}} does not contain {{#knownMisses}}',
        'array.includesRequiredUnknowns': '{{#label}} does not contain {{#unknownMisses}} required value(s)',
        'array.length': '{{#label}} must contain {{#limit}} items',
        'array.max': '{{#label}} must contain less than or equal to {{#limit}} items',
        'array.min': '{{#label}} must contain at least {{#limit}} items',
        'array.orderedLength': '{{#label}} must contain at most {{#limit}} items',
        'array.sort': '{{#label}} must be sorted in {#order} order by {{#by}}',
        'array.sort.mismatching': '{{#label}} cannot be sorted due to mismatching types',
        'array.sort.unsupported': '{{#label}} cannot be sorted due to unsupported type {#type}',
        'array.sparse': '{{#label}} must not be a sparse array item',
        'array.unique': '{{#label}} contains a duplicate value'
    }
});


// Helpers

internals.fillMissedErrors = function (schema, errors, requireds, value, state, prefs) {

    const knownMisses = [];
    let unknownMisses = 0;
    for (const required of requireds) {
        const label = required._flags.label;
        if (label) {
            knownMisses.push(label);
        }
        else {
            ++unknownMisses;
        }
    }

    if (knownMisses.length) {
        if (unknownMisses) {
            errors.push(schema.$_createError('array.includesRequiredBoth', value, { knownMisses, unknownMisses }, state, prefs));
        }
        else {
            errors.push(schema.$_createError('array.includesRequiredKnowns', value, { knownMisses }, state, prefs));
        }
    }
    else {
        errors.push(schema.$_createError('array.includesRequiredUnknowns', value, { unknownMisses }, state, prefs));
    }
};


internals.fillOrderedErrors = function (schema, errors, ordereds, value, state, prefs) {

    const requiredOrdereds = [];

    for (const ordered of ordereds) {
        if (ordered._flags.presence === 'required') {
            requiredOrdereds.push(ordered);
        }
    }

    if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
    }
};


internals.fillDefault = function (ordereds, value, state, prefs) {

    const overrides = [];
    let trailingUndefined = true;

    for (let i = ordereds.length - 1; i >= 0; --i) {
        const ordered = ordereds[i];
        const ancestors = [value, ...state.ancestors];
        const override = ordered.$_validate(undefined, state.localize(state.path, ancestors, ordered), prefs).value;

        if (trailingUndefined) {
            if (override === undefined) {
                continue;
            }

            trailingUndefined = false;
        }

        overrides.unshift(override);
    }

    if (overrides.length) {
        value.push(...overrides);
    }
};


internals.fastSplice = function (arr, i) {

    let pos = i;
    while (pos < arr.length) {
        arr[pos++] = arr[pos];
    }

    --arr.length;
};


internals.validateSingle = function (type, obj) {

    if (type.type === 'array' ||
        type._flags._arrayItems) {

        Assert(!obj._flags.single, 'Cannot specify array item with single rule enabled');
        obj.$_setFlag('_arrayItems', true, { clone: false });
    }
};


internals.sort = function (schema, value, settings, state, prefs) {

    const order = settings.order === 'ascending' ? 1 : -1;
    const aFirst = -1 * order;
    const bFirst = order;

    const sort = (a, b) => {

        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
            return compare;
        }

        if (settings.by) {
            a = settings.by.resolve(a, state, prefs);
            b = settings.by.resolve(b, state, prefs);
        }

        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
            return compare;
        }

        const type = typeof a;
        if (type !== typeof b) {
            throw schema.$_createError('array.sort.mismatching', value, null, state, prefs);
        }

        if (type !== 'number' &&
            type !== 'string') {

            throw schema.$_createError('array.sort.unsupported', value, { type }, state, prefs);
        }

        if (type === 'number') {
            return (a - b) * order;
        }

        return a < b ? aFirst : bFirst;
    };

    try {
        return { value: value.slice().sort(sort) };
    }
    catch (err) {
        return { errors: err };
    }
};


internals.compare = function (a, b, aFirst, bFirst) {

    if (a === b) {
        return 0;
    }

    if (a === undefined) {
        return 1;           // Always last regardless of sort order
    }

    if (b === undefined) {
        return -1;           // Always last regardless of sort order
    }

    if (a === null) {
        return bFirst;
    }

    if (b === null) {
        return aFirst;
    }

    return null;
};


/***/ }),

/***/ "./node_modules/joi/lib/types/binary.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/binary.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/joi/lib/common.js");


const internals = {};


module.exports = Any.extend({

    type: 'binary',

    coerce: {
        from: 'string',
        method(value, { schema }) {

            try {
                return { value: Buffer.from(value, schema._flags.encoding) };
            }
            catch (ignoreErr) { }
        }
    },

    validate(value, { error }) {

        if (!Buffer.isBuffer(value)) {
            return { value, errors: error('binary.base') };
        }
    },

    rules: {
        encoding: {
            method(encoding) {

                Assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

                return this.$_setFlag('encoding', encoding);
            }
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', method: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value.length, limit, operator)) {
                    return value;
                }

                return helpers.error('binary.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        }
    },

    cast: {
        string: {
            from: (value) => Buffer.isBuffer(value),
            to(value, helpers) {

                return value.toString();
            }
        }
    },

    messages: {
        'binary.base': '{{#label}} must be a buffer or a string',
        'binary.length': '{{#label}} must be {{#limit}} bytes',
        'binary.max': '{{#label}} must be less than or equal to {{#limit}} bytes',
        'binary.min': '{{#label}} must be at least {{#limit}} bytes'
    }
});


/***/ }),

/***/ "./node_modules/joi/lib/types/boolean.js":
/*!***********************************************!*\
  !*** ./node_modules/joi/lib/types/boolean.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/joi/lib/common.js");
const Values = __webpack_require__(/*! ../values */ "./node_modules/joi/lib/values.js");


const internals = {};


internals.isBool = function (value) {

    return typeof value === 'boolean';
};


module.exports = Any.extend({

    type: 'boolean',

    flags: {

        sensitive: { default: false }
    },

    terms: {

        falsy: {
            init: null,
            manifest: 'values'
        },

        truthy: {
            init: null,
            manifest: 'values'
        }
    },

    coerce(value, { schema }) {

        if (typeof value === 'boolean') {
            return;
        }

        if (typeof value === 'string') {
            const normalized = schema._flags.sensitive ? value : value.toLowerCase();
            value = normalized === 'true' ? true : (normalized === 'false' ? false : value);
        }

        if (typeof value !== 'boolean') {
            value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) ||
                (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);
        }

        return { value };
    },

    validate(value, { error }) {

        if (typeof value !== 'boolean') {
            return { value, errors: error('boolean.base') };
        }
    },

    rules: {
        truthy: {
            method(...values) {

                Common.verifyFlat(values, 'truthy');

                const obj = this.clone();
                obj.$_terms.truthy = obj.$_terms.truthy || new Values();

                for (let i = 0; i < values.length; ++i) {
                    const value = values[i];

                    Assert(value !== undefined, 'Cannot call truthy with undefined');
                    obj.$_terms.truthy.add(value);
                }

                return obj;
            }
        },

        falsy: {
            method(...values) {

                Common.verifyFlat(values, 'falsy');

                const obj = this.clone();
                obj.$_terms.falsy = obj.$_terms.falsy || new Values();

                for (let i = 0; i < values.length; ++i) {
                    const value = values[i];

                    Assert(value !== undefined, 'Cannot call falsy with undefined');
                    obj.$_terms.falsy.add(value);
                }

                return obj;
            }
        },

        sensitive: {
            method(enabled = true) {

                return this.$_setFlag('sensitive', enabled);
            }
        }
    },

    cast: {
        number: {
            from: internals.isBool,
            to(value, helpers) {

                return value ? 1 : 0;
            }
        },
        string: {
            from: internals.isBool,
            to(value, helpers) {

                return value ? 'true' : 'false';
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.truthy) {
                obj = obj.truthy(...desc.truthy);
            }

            if (desc.falsy) {
                obj = obj.falsy(...desc.falsy);
            }

            return obj;
        }
    },

    messages: {
        'boolean.base': '{{#label}} must be a boolean'
    }
});


/***/ }),

/***/ "./node_modules/joi/lib/types/date.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/date.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/joi/lib/common.js");
const Template = __webpack_require__(/*! ../template */ "./node_modules/joi/lib/template.js");


const internals = {};


internals.isDate = function (value) {

    return value instanceof Date;
};


module.exports = Any.extend({

    type: 'date',

    coerce: {
        from: ['number', 'string'],
        method(value, { schema }) {

            return { value: internals.parse(value, schema._flags.format) || value };
        }
    },

    validate(value, { schema, error, prefs }) {

        if (value instanceof Date &&
            !isNaN(value.getTime())) {

            return;
        }

        const format = schema._flags.format;

        if (!prefs.convert ||
            !format ||
            typeof value !== 'string') {

            return { value, errors: error('date.base') };
        }

        return { value, errors: error('date.format', { format }) };
    },

    rules: {

        compare: {
            method: false,
            validate(value, helpers, { date }, { name, operator, args }) {

                const to = date === 'now' ? Date.now() : date.getTime();
                if (Common.compare(value.getTime(), to, operator)) {
                    return value;
                }

                return helpers.error('date.' + name, { limit: args.date, value });
            },
            args: [
                {
                    name: 'date',
                    ref: true,
                    normalize: (date) => {

                        return date === 'now' ? date : internals.parse(date);
                    },
                    assert: (date) => date !== null,
                    message: 'must have a valid date format'
                }
            ]
        },

        format: {
            method(format) {

                Assert(['iso', 'javascript', 'unix'].includes(format), 'Unknown date format', format);

                return this.$_setFlag('format', format);
            }
        },

        greater: {
            method(date) {

                return this.$_addRule({ name: 'greater', method: 'compare', args: { date }, operator: '>' });
            }
        },

        iso: {
            method() {

                return this.format('iso');
            }
        },

        less: {
            method(date) {

                return this.$_addRule({ name: 'less', method: 'compare', args: { date }, operator: '<' });
            }
        },

        max: {
            method(date) {

                return this.$_addRule({ name: 'max', method: 'compare', args: { date }, operator: '<=' });
            }
        },

        min: {
            method(date) {

                return this.$_addRule({ name: 'min', method: 'compare', args: { date }, operator: '>=' });
            }
        },

        timestamp: {
            method(type = 'javascript') {

                Assert(['javascript', 'unix'].includes(type), '"type" must be one of "javascript, unix"');

                return this.format(type);
            }
        }
    },

    cast: {
        number: {
            from: internals.isDate,
            to(value, helpers) {

                return value.getTime();
            }
        },
        string: {
            from: internals.isDate,
            to(value, { prefs }) {

                return Template.date(value, prefs);
            }
        }
    },

    messages: {
        'date.base': '{{#label}} must be a valid date',
        'date.format': '{{#label}} must be in {msg("date.format." + #format) || #format} format',
        'date.greater': '{{#label}} must be greater than {{:#limit}}',
        'date.less': '{{#label}} must be less than {{:#limit}}',
        'date.max': '{{#label}} must be less than or equal to {{:#limit}}',
        'date.min': '{{#label}} must be greater than or equal to {{:#limit}}',

        // Messages used in date.format

        'date.format.iso': 'ISO 8601 date',
        'date.format.javascript': 'timestamp or number of milliseconds',
        'date.format.unix': 'timestamp or number of seconds'
    }
});


// Helpers

internals.parse = function (value, format) {

    if (value instanceof Date) {
        return value;
    }

    if (typeof value !== 'string' &&
        (isNaN(value) || !isFinite(value))) {

        return null;
    }

    if (/^\s*$/.test(value)) {
        return null;
    }

    // ISO

    if (format === 'iso') {
        if (!Common.isIsoDate(value)) {
            return null;
        }

        return internals.date(value.toString());
    }

    // Normalize number string

    const original = value;
    if (typeof value === 'string' &&
        /^[+-]?\d+(\.\d+)?$/.test(value)) {

        value = parseFloat(value);
    }

    // Timestamp

    if (format) {
        if (format === 'javascript') {
            return internals.date(1 * value);        // Casting to number
        }

        if (format === 'unix') {
            return internals.date(1000 * value);
        }

        if (typeof original === 'string') {
            return null;
        }
    }

    // Plain

    return internals.date(value);
};


internals.date = function (value) {

    const date = new Date(value);
    if (!isNaN(date.getTime())) {
        return date;
    }

    return null;
};


/***/ }),

/***/ "./node_modules/joi/lib/types/function.js":
/*!************************************************!*\
  !*** ./node_modules/joi/lib/types/function.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Keys = __webpack_require__(/*! ./keys */ "./node_modules/joi/lib/types/keys.js");


const internals = {};


module.exports = Keys.extend({

    type: 'function',

    properties: {
        typeof: 'function'
    },

    rules: {
        arity: {
            method(n) {

                Assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

                return this.$_addRule({ name: 'arity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length === n) {
                    return value;
                }

                return helpers.error('function.arity', { n });
            }
        },

        class: {
            method() {

                return this.$_addRule('class');
            },
            validate(value, helpers) {

                if ((/^\s*class\s/).test(value.toString())) {
                    return value;
                }

                return helpers.error('function.class', { value });
            }
        },

        minArity: {
            method(n) {

                Assert(Number.isSafeInteger(n) && n > 0, 'n must be a strict positive integer');

                return this.$_addRule({ name: 'minArity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length >= n) {
                    return value;
                }

                return helpers.error('function.minArity', { n });
            }
        },

        maxArity: {
            method(n) {

                Assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

                return this.$_addRule({ name: 'maxArity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length <= n) {
                    return value;
                }

                return helpers.error('function.maxArity', { n });
            }
        }
    },

    messages: {
        'function.arity': '{{#label}} must have an arity of {{#n}}',
        'function.class': '{{#label}} must be a class',
        'function.maxArity': '{{#label}} must have an arity lesser or equal to {{#n}}',
        'function.minArity': '{{#label}} must have an arity greater or equal to {{#n}}'
    }
});


/***/ }),

/***/ "./node_modules/joi/lib/types/keys.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/keys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const ApplyToDefaults = __webpack_require__(/*! @hapi/hoek/lib/applyToDefaults */ "./node_modules/@hapi/hoek/lib/applyToDefaults.js");
const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Topo = __webpack_require__(/*! @hapi/topo */ "./node_modules/@hapi/topo/lib/index.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ../errors */ "./node_modules/joi/lib/errors.js");
const Ref = __webpack_require__(/*! ../ref */ "./node_modules/joi/lib/ref.js");
const Template = __webpack_require__(/*! ../template */ "./node_modules/joi/lib/template.js");


const internals = {
    renameDefaults: {
        alias: false,                   // Keep old value in place
        multiple: false,                // Allow renaming multiple keys into the same target
        override: false                 // Overrides an existing key
    }
};


module.exports = Any.extend({

    type: '_keys',

    properties: {

        typeof: 'object'
    },

    flags: {

        unknown: { default: false }
    },

    terms: {

        dependencies: { init: null },
        keys: { init: null, manifest: { mapped: { from: 'schema', to: 'key' } } },
        patterns: { init: null },
        renames: { init: null }
    },

    args(schema, keys) {

        return schema.keys(keys);
    },

    validate(value, { schema, error, state, prefs }) {

        if (!value ||
            typeof value !== schema.$_property('typeof') ||
            Array.isArray(value)) {

            return { value, errors: error('object.base', { type: schema.$_property('typeof') }) };
        }

        // Skip if there are no other rules to test

        if (!schema.$_terms.renames &&
            !schema.$_terms.dependencies &&
            !schema.$_terms.keys &&                       // null allows any keys
            !schema.$_terms.patterns &&
            !schema.$_terms.externals) {

            return;
        }

        // Shallow clone value

        value = internals.clone(value, prefs);
        const errors = [];

        // Rename keys

        if (schema.$_terms.renames &&
            !internals.rename(schema, value, state, prefs, errors)) {

            return { value, errors };
        }

        // Anything allowed

        if (!schema.$_terms.keys &&                       // null allows any keys
            !schema.$_terms.patterns &&
            !schema.$_terms.dependencies) {

            return { value, errors };
        }

        // Defined keys

        const unprocessed = new Set(Object.keys(value));

        if (schema.$_terms.keys) {
            const ancestors = [value, ...state.ancestors];

            for (const child of schema.$_terms.keys) {
                const key = child.key;
                const item = value[key];

                unprocessed.delete(key);

                const localState = state.localize([...state.path, key], ancestors, child);
                const result = child.schema.$_validate(item, localState, prefs);

                if (result.errors) {
                    if (prefs.abortEarly) {
                        return { value, errors: result.errors };
                    }

                    if (result.value !== undefined) {
                        value[key] = result.value;
                    }

                    errors.push(...result.errors);
                }
                else if (child.schema._flags.result === 'strip' ||
                    result.value === undefined && item !== undefined) {

                    delete value[key];
                }
                else if (result.value !== undefined) {
                    value[key] = result.value;
                }
            }
        }

        // Unknown keys

        if (unprocessed.size ||
            schema._flags._hasPatternMatch) {

            const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
            if (early) {
                return early;
            }
        }

        // Validate dependencies

        if (schema.$_terms.dependencies) {
            for (const dep of schema.$_terms.dependencies) {
                if (dep.key &&
                    dep.key.resolve(value, state, prefs, null, { shadow: false }) === undefined) {

                    continue;
                }

                const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
                if (failed) {
                    const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
                    if (prefs.abortEarly) {
                        return { value, errors: report };
                    }

                    errors.push(report);
                }
            }
        }

        return { value, errors };
    },

    rules: {

        and: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'and');

                return internals.dependency(this, 'and', null, peers);
            }
        },

        append: {
            method(schema) {

                if (schema === null ||
                    schema === undefined ||
                    Object.keys(schema).length === 0) {

                    return this;
                }

                return this.keys(schema);
            }
        },

        assert: {
            method(subject, schema, message) {

                if (!Template.isTemplate(subject)) {
                    subject = Compile.ref(subject);
                }

                Assert(message === undefined || typeof message === 'string', 'Message must be a string');

                schema = this.$_compile(schema, { appendPath: true });

                const obj = this.$_addRule({ name: 'assert', args: { subject, schema, message } });
                obj.$_mutateRegister(subject);
                obj.$_mutateRegister(schema);
                return obj;
            },
            validate(value, { error, prefs, state }, { subject, schema, message }) {

                const about = subject.resolve(value, state, prefs);
                const path = Ref.isRef(subject) ? subject.absolute(state) : [];
                if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {
                    return value;
                }

                return error('object.assert', { subject, message });
            },
            args: ['subject', 'schema', 'message'],
            multi: true
        },

        instance: {
            method(constructor, name) {

                Assert(typeof constructor === 'function', 'constructor must be a function');

                name = name || constructor.name;

                return this.$_addRule({ name: 'instance', args: { constructor, name } });
            },
            validate(value, helpers, { constructor, name }) {

                if (value instanceof constructor) {
                    return value;
                }

                return helpers.error('object.instance', { type: name, value });
            },
            args: ['constructor', 'name']
        },

        keys: {
            method(schema) {

                Assert(schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
                Assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');

                const obj = this.clone();

                if (!schema) {                                      // Allow all
                    obj.$_terms.keys = null;
                }
                else if (!Object.keys(schema).length) {             // Allow none
                    obj.$_terms.keys = new internals.Keys();
                }
                else {
                    obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();
                    for (const key in schema) {
                        Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
                    }
                }

                return obj.$_mutateRebuild();
            }
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(Object.keys(value).length, limit, operator)) {
                    return value;
                }

                return helpers.error('object.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        },

        nand: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'nand');

                return internals.dependency(this, 'nand', null, peers);
            }
        },

        or: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'or');

                return internals.dependency(this, 'or', null, peers);
            }
        },

        oxor: {
            method(...peers /*, [options] */) {

                return internals.dependency(this, 'oxor', null, peers);
            }
        },

        pattern: {
            method(pattern, schema, options = {}) {

                const isRegExp = pattern instanceof RegExp;
                if (!isRegExp) {
                    pattern = this.$_compile(pattern, { appendPath: true });
                }

                Assert(schema !== undefined, 'Invalid rule');
                Common.assertOptions(options, ['fallthrough', 'matches']);

                if (isRegExp) {
                    Assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');
                }

                schema = this.$_compile(schema, { appendPath: true });

                const obj = this.clone();
                obj.$_terms.patterns = obj.$_terms.patterns || [];
                const config = { [isRegExp ? 'regex' : 'schema']: pattern, rule: schema };
                if (options.matches) {
                    config.matches = this.$_compile(options.matches);
                    if (config.matches.type !== 'array') {
                        config.matches = config.matches.$_root.array().items(config.matches);
                    }

                    obj.$_mutateRegister(config.matches);
                    obj.$_setFlag('_hasPatternMatch', true, { clone: false });
                }

                if (options.fallthrough) {
                    config.fallthrough = true;
                }

                obj.$_terms.patterns.push(config);
                obj.$_mutateRegister(schema);
                return obj;
            }
        },

        ref: {
            method() {

                return this.$_addRule('ref');
            },
            validate(value, helpers) {

                if (Ref.isRef(value)) {
                    return value;
                }

                return helpers.error('object.refType', { value });
            }
        },

        regex: {
            method() {

                return this.$_addRule('regex');
            },
            validate(value, helpers) {

                if (value instanceof RegExp) {
                    return value;
                }

                return helpers.error('object.regex', { value });
            }
        },

        rename: {
            method(from, to, options = {}) {

                Assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');
                Assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');
                Assert(to !== from, 'Cannot rename key to same name:', from);

                Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);

                const obj = this.clone();

                obj.$_terms.renames = obj.$_terms.renames || [];
                for (const rename of obj.$_terms.renames) {
                    Assert(rename.from !== from, 'Cannot rename the same key multiple times');
                }

                if (to instanceof Template) {
                    obj.$_mutateRegister(to);
                }

                obj.$_terms.renames.push({
                    from,
                    to,
                    options: ApplyToDefaults(internals.renameDefaults, options)
                });

                return obj;
            }
        },

        schema: {
            method(type = 'any') {

                return this.$_addRule({ name: 'schema', args: { type } });
            },
            validate(value, helpers, { type }) {

                if (Common.isSchema(value) &&
                    (type === 'any' || value.type === type)) {

                    return value;
                }

                return helpers.error('object.schema', { type });
            }
        },

        unknown: {
            method(allow) {

                return this.$_setFlag('unknown', allow !== false);
            }
        },

        with: {
            method(key, peers, options = {}) {

                return internals.dependency(this, 'with', key, peers, options);
            }
        },

        without: {
            method(key, peers, options = {}) {

                return internals.dependency(this, 'without', key, peers, options);
            }
        },

        xor: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'xor');

                return internals.dependency(this, 'xor', null, peers);
            }
        }
    },

    overrides: {

        default(value, options) {

            if (value === undefined) {
                value = Common.symbols.deepDefault;
            }

            return this.$_parent('default', value, options);
        }
    },

    rebuild(schema) {

        if (schema.$_terms.keys) {
            const topo = new Topo.Sorter();
            for (const child of schema.$_terms.keys) {
                Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
            }

            schema.$_terms.keys = new internals.Keys(...topo.nodes);
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.keys) {
                obj = obj.keys(desc.keys);
            }

            if (desc.dependencies) {
                for (const { rel, key = null, peers, options } of desc.dependencies) {
                    obj = internals.dependency(obj, rel, key, peers, options);
                }
            }

            if (desc.patterns) {
                for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {
                    obj = obj.pattern(regex || schema, rule, { fallthrough, matches });
                }
            }

            if (desc.renames) {
                for (const { from, to, options } of desc.renames) {
                    obj = obj.rename(from, to, options);
                }
            }

            return obj;
        }
    },

    messages: {
        'object.and': '{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',
        'object.assert': '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
        'object.base': '{{#label}} must be of type {{#type}}',
        'object.instance': '{{#label}} must be an instance of {{:#type}}',
        'object.length': '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.max': '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.min': '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.missing': '{{#label}} must contain at least one of {{#peersWithLabels}}',
        'object.nand': '{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}',
        'object.oxor': '{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}',
        'object.pattern.match': '{{#label}} keys failed to match pattern requirements',
        'object.refType': '{{#label}} must be a Joi reference',
        'object.regex': '{{#label}} must be a RegExp object',
        'object.rename.multiple': '{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}',
        'object.rename.override': '{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists',
        'object.schema': '{{#label}} must be a Joi schema of {{#type}} type',
        'object.unknown': '{{#label}} is not allowed',
        'object.with': '{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}',
        'object.without': '{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}',
        'object.xor': '{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}'
    }
});


// Helpers

internals.clone = function (value, prefs) {

    // Object

    if (typeof value === 'object') {
        if (prefs.nonEnumerables) {
            return Clone(value, { shallow: true });
        }

        const clone = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone, value);
        return clone;
    }

    // Function

    const clone = function (...args) {

        return value.apply(this, args);
    };

    clone.prototype = Clone(value.prototype);
    Object.defineProperty(clone, 'name', { value: value.name, writable: false });
    Object.defineProperty(clone, 'length', { value: value.length, writable: false });
    Object.assign(clone, value);
    return clone;
};


internals.dependency = function (schema, rel, key, peers, options) {

    Assert(key === null || typeof key === 'string', rel, 'key must be a strings');

    // Extract options from peers array

    if (!options) {
        options = peers.length > 1 && typeof peers[peers.length - 1] === 'object' ? peers.pop() : {};
    }

    Common.assertOptions(options, ['separator']);

    peers = [].concat(peers);

    // Cast peer paths

    const separator = Common.default(options.separator, '.');
    const paths = [];
    for (const peer of peers) {
        Assert(typeof peer === 'string', rel, 'peers must be strings');
        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
    }

    // Cast key

    if (key !== null) {
        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
    }

    // Add rule

    const obj = schema.clone();
    obj.$_terms.dependencies = obj.$_terms.dependencies || [];
    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));
    return obj;
};


internals.dependencies = {

    and(schema, dep, value, state, prefs) {

        const missing = [];
        const present = [];
        const count = dep.peers.length;
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {
                missing.push(peer.key);
            }
            else {
                present.push(peer.key);
            }
        }

        if (missing.length !== count &&
            present.length !== count) {

            return {
                code: 'object.and',
                context: {
                    present,
                    presentWithLabels: internals.keysToLabels(schema, present),
                    missing,
                    missingWithLabels: internals.keysToLabels(schema, missing)
                }
            };
        }
    },

    nand(schema, dep, value, state, prefs) {

        const present = [];
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                present.push(peer.key);
            }
        }

        if (present.length !== dep.peers.length) {
            return;
        }

        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
            code: 'object.nand',
            context: {
                main,
                mainWithLabel: internals.keysToLabels(schema, main),
                peers: values,
                peersWithLabels: internals.keysToLabels(schema, values)
            }
        };
    },

    or(schema, dep, value, state, prefs) {

        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                return;
            }
        }

        return {
            code: 'object.missing',
            context: {
                peers: dep.paths,
                peersWithLabels: internals.keysToLabels(schema, dep.paths)
            }
        };
    },

    oxor(schema, dep, value, state, prefs) {

        const present = [];
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                present.push(peer.key);
            }
        }

        if (!present.length ||
            present.length === 1) {

            return;
        }

        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: 'object.oxor', context };
    },

    with(schema, dep, value, state, prefs) {

        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {
                return {
                    code: 'object.with',
                    context: {
                        main: dep.key.key,
                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                        peer: peer.key,
                        peerWithLabel: internals.keysToLabels(schema, peer.key)
                    }
                };
            }
        }
    },

    without(schema, dep, value, state, prefs) {

        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                return {
                    code: 'object.without',
                    context: {
                        main: dep.key.key,
                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                        peer: peer.key,
                        peerWithLabel: internals.keysToLabels(schema, peer.key)
                    }
                };
            }
        }
    },

    xor(schema, dep, value, state, prefs) {

        const present = [];
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                present.push(peer.key);
            }
        }

        if (present.length === 1) {
            return;
        }

        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        if (present.length === 0) {
            return { code: 'object.missing', context };
        }

        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: 'object.xor', context };
    }
};


internals.keysToLabels = function (schema, keys) {

    if (Array.isArray(keys)) {
        return keys.map((key) => schema.$_mapLabels(key));
    }

    return schema.$_mapLabels(keys);
};


internals.rename = function (schema, value, state, prefs, errors) {

    const renamed = {};
    for (const rename of schema.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== 'string';

        if (!pattern) {
            if (Object.prototype.hasOwnProperty.call(value, rename.from) &&
                (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {

                matches.push(rename);
            }
        }
        else {
            for (const from in value) {
                if (value[from] === undefined &&
                    rename.options.ignoreUndefined) {

                    continue;
                }

                if (from === rename.to) {
                    continue;
                }

                const match = rename.from.exec(from);
                if (!match) {
                    continue;
                }

                matches.push({ from, to: rename.to, match });
            }
        }

        for (const match of matches) {
            const from = match.from;
            let to = match.to;
            if (to instanceof Template) {
                to = to.render(value, state, prefs, match.match);
            }

            if (from === to) {
                continue;
            }

            if (!rename.options.multiple &&
                renamed[to]) {

                errors.push(schema.$_createError('object.rename.multiple', value, { from, to, pattern }, state, prefs));
                if (prefs.abortEarly) {
                    return false;
                }
            }

            if (Object.prototype.hasOwnProperty.call(value, to) &&
                !rename.options.override &&
                !renamed[to]) {

                errors.push(schema.$_createError('object.rename.override', value, { from, to, pattern }, state, prefs));
                if (prefs.abortEarly) {
                    return false;
                }
            }

            if (value[from] === undefined) {
                delete value[to];
            }
            else {
                value[to] = value[from];
            }

            renamed[to] = true;

            if (!rename.options.alias) {
                delete value[from];
            }
        }
    }

    return true;
};


internals.unknown = function (schema, value, unprocessed, errors, state, prefs) {

    if (schema.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema.$_terms.patterns.map((pattern) => {

            if (pattern.matches) {
                hasMatches = true;
                return [];
            }
        });

        const ancestors = [value, ...state.ancestors];

        for (const key of unprocessed) {
            const item = value[key];
            const path = [...state.path, key];

            for (let i = 0; i < schema.$_terms.patterns.length; ++i) {
                const pattern = schema.$_terms.patterns[i];
                if (pattern.regex) {
                    const match = pattern.regex.test(key);
                    state.mainstay.tracer.debug(state, 'rule', `pattern.${i}`, match ? 'pass' : 'error');
                    if (!match) {
                        continue;
                    }
                }
                else {
                    if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
                        continue;
                    }
                }

                unprocessed.delete(key);

                const localState = state.localize(path, ancestors, { schema: pattern.rule, key });
                const result = pattern.rule.$_validate(item, localState, prefs);
                if (result.errors) {
                    if (prefs.abortEarly) {
                        return { value, errors: result.errors };
                    }

                    errors.push(...result.errors);
                }

                if (pattern.matches) {
                    matches[i].push(key);
                }

                value[key] = result.value;
                if (!pattern.fallthrough) {
                    break;
                }
            }
        }

        // Validate pattern matches rules

        if (hasMatches) {
            for (let i = 0; i < matches.length; ++i) {
                const match = matches[i];
                if (!match) {
                    continue;
                }

                const stpm = schema.$_terms.patterns[i].matches;
                const localState = state.localize(state.path, ancestors, stpm);
                const result = stpm.$_validate(match, localState, prefs);
                if (result.errors) {
                    const details = Errors.details(result.errors, { override: false });
                    details.matches = match;
                    const report = schema.$_createError('object.pattern.match', value, details, state, prefs);
                    if (prefs.abortEarly) {
                        return { value, errors: report };
                    }

                    errors.push(report);
                }
            }
        }
    }

    if (!unprocessed.size ||
        !schema.$_terms.keys && !schema.$_terms.patterns) {     // If no keys or patterns specified, unknown keys allowed

        return;
    }

    if (prefs.stripUnknown && !schema._flags.unknown ||
        prefs.skipFunctions) {

        const stripUnknown = prefs.stripUnknown ? (prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects) : false;

        for (const key of unprocessed) {
            if (stripUnknown) {
                delete value[key];
                unprocessed.delete(key);
            }
            else if (typeof value[key] === 'function') {
                unprocessed.delete(key);
            }
        }
    }

    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
    if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
            const localState = state.localize([...state.path, unprocessedKey], []);
            const report = schema.$_createError('object.unknown', value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
            if (prefs.abortEarly) {
                return { value, errors: report };
            }

            errors.push(report);
        }
    }
};


internals.Dependency = class {

    constructor(rel, key, peers, paths) {

        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
    }

    describe() {

        const desc = {
            rel: this.rel,
            peers: this.paths
        };

        if (this.key !== null) {
            desc.key = this.key.key;
        }

        if (this.peers[0].separator !== '.') {
            desc.options = { separator: this.peers[0].separator };
        }

        return desc;
    }
};


internals.Keys = class extends Array {

    concat(source) {

        const result = this.slice();

        const keys = new Map();
        for (let i = 0; i < result.length; ++i) {
            keys.set(result[i].key, i);
        }

        for (const item of source) {
            const key = item.key;
            const pos = keys.get(key);
            if (pos !== undefined) {
                result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
            }
            else {
                result.push(item);
            }
        }

        return result;
    }
};


/***/ }),

/***/ "./node_modules/joi/lib/types/link.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/link.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ../errors */ "./node_modules/joi/lib/errors.js");


const internals = {};


module.exports = Any.extend({

    type: 'link',

    properties: {
        schemaChain: true
    },

    terms: {

        link: { init: null, manifest: 'single', register: false }
    },

    args(schema, ref) {

        return schema.ref(ref);
    },

    validate(value, { schema, state, prefs }) {

        Assert(schema.$_terms.link, 'Uninitialized link schema');

        const linked = internals.generate(schema, value, state, prefs);
        const ref = schema.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
    },

    generate(schema, value, state, prefs) {

        return internals.generate(schema, value, state, prefs);
    },

    rules: {

        ref: {
            method(ref) {

                Assert(!this.$_terms.link, 'Cannot reinitialize schema');

                ref = Compile.ref(ref);

                Assert(ref.type === 'value' || ref.type === 'local', 'Invalid reference type:', ref.type);
                Assert(ref.type === 'local' || ref.ancestor === 'root' || ref.ancestor > 0, 'Link cannot reference itself');

                const obj = this.clone();
                obj.$_terms.link = [{ ref }];
                return obj;
            }
        },

        relative: {
            method(enabled = true) {

                return this.$_setFlag('relative', enabled);
            }
        }
    },

    overrides: {

        concat(source) {

            Assert(this.$_terms.link, 'Uninitialized link schema');
            Assert(Common.isSchema(source), 'Invalid schema object');
            Assert(source.type !== 'link', 'Cannot merge type link with another link');

            const obj = this.clone();

            if (!obj.$_terms.whens) {
                obj.$_terms.whens = [];
            }

            obj.$_terms.whens.push({ concat: source });
            return obj.$_mutateRebuild();
        }
    },

    manifest: {

        build(obj, desc) {

            Assert(desc.link, 'Invalid link description missing link');
            return obj.ref(desc.link);
        }
    }
});


// Helpers

internals.generate = function (schema, value, state, prefs) {

    let linked = state.mainstay.links.get(schema);
    if (linked) {
        return linked._generate(value, state, prefs).schema;
    }

    const ref = schema.$_terms.link[0].ref;
    const { perspective, path } = internals.perspective(ref, state);
    internals.assert(perspective, 'which is outside of schema boundaries', ref, schema, state, prefs);

    try {
        linked = path.length ? perspective.$_reach(path) : perspective;
    }
    catch (ignoreErr) {
        internals.assert(false, 'to non-existing schema', ref, schema, state, prefs);
    }

    internals.assert(linked.type !== 'link', 'which is another link', ref, schema, state, prefs);

    if (!schema._flags.relative) {
        state.mainstay.links.set(schema, linked);
    }

    return linked._generate(value, state, prefs).schema;
};


internals.perspective = function (ref, state) {

    if (ref.type === 'local') {
        for (const { schema, key } of state.schemas) {                              // From parent to root
            const id = schema._flags.id || key;
            if (id === ref.path[0]) {
                return { perspective: schema, path: ref.path.slice(1) };
            }

            if (schema.$_terms.shared) {
                for (const shared of schema.$_terms.shared) {
                    if (shared._flags.id === ref.path[0]) {
                        return { perspective: shared, path: ref.path.slice(1) };
                    }
                }
            }
        }

        return { perspective: null, path: null };
    }

    if (ref.ancestor === 'root') {
        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
    }

    return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
};


internals.assert = function (condition, message, ref, schema, state, prefs) {

    if (condition) {                // Manual check to avoid generating error message on success
        return;
    }

    Assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
};


/***/ }),

/***/ "./node_modules/joi/lib/types/number.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/number.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/joi/lib/common.js");


const internals = {
    numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
};


module.exports = Any.extend({

    type: 'number',

    flags: {

        unsafe: { default: false }
    },

    coerce: {
        from: 'string',
        method(value, { schema, error }) {

            const matches = value.match(internals.numberRx);
            if (!matches) {
                return;
            }

            value = value.trim();
            const result = { value: parseFloat(value) };

            if (result.value === 0) {
                result.value = 0;           // -0
            }

            if (!schema._flags.unsafe) {
                if (value.match(/e/i)) {
                    const constructed = internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`);
                    if (constructed !== internals.normalizeExponent(value)) {
                        result.errors = error('number.unsafe');
                        return result;
                    }
                }
                else {
                    const string = result.value.toString();
                    if (string.match(/e/i)) {
                        return result;
                    }

                    if (string !== internals.normalizeDecimal(value)) {
                        result.errors = error('number.unsafe');
                        return result;
                    }
                }
            }

            return result;
        }
    },

    validate(value, { schema, error, prefs }) {

        if (value === Infinity ||
            value === -Infinity) {

            return { value, errors: error('number.infinity') };
        }

        if (!Common.isNumber(value)) {
            return { value, errors: error('number.base') };
        }

        const result = { value };

        if (prefs.convert) {
            const rule = schema.$_getRule('precision');
            if (rule) {
                const precision = Math.pow(10, rule.args.limit);                    // This is conceptually equivalent to using toFixed but it should be much faster
                result.value = Math.round(result.value * precision) / precision;
            }
        }

        if (result.value === 0) {
            result.value = 0;           // -0
        }

        if (!schema._flags.unsafe &&
            (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {

            result.errors = error('number.unsafe');
        }

        return result;
    },

    rules: {

        compare: {
            method: false,
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value, limit, operator)) {
                    return value;
                }

                return helpers.error('number.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.isNumber,
                    message: 'must be a number'
                }
            ]
        },

        greater: {
            method(limit) {

                return this.$_addRule({ name: 'greater', method: 'compare', args: { limit }, operator: '>' });
            }
        },

        integer: {
            method() {

                return this.$_addRule('integer');
            },
            validate(value, helpers) {

                if (Math.trunc(value) - value === 0) {
                    return value;
                }

                return helpers.error('number.integer');
            }
        },

        less: {
            method(limit) {

                return this.$_addRule({ name: 'less', method: 'compare', args: { limit }, operator: '<' });
            }
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'compare', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'compare', args: { limit }, operator: '>=' });
            }
        },

        multiple: {
            method(base) {

                return this.$_addRule({ name: 'multiple', args: { base } });
            },
            validate(value, helpers, { base }, options) {

                if (value * (1 / base) % 1 === 0) {
                    return value;
                }

                return helpers.error('number.multiple', { multiple: options.args.base, value });
            },
            args: [
                {
                    name: 'base',
                    ref: true,
                    assert: (value) => typeof value === 'number' && isFinite(value) && value > 0,
                    message: 'must be a positive number'
                }
            ],
            multi: true
        },

        negative: {
            method() {

                return this.sign('negative');
            }
        },

        port: {
            method() {

                return this.$_addRule('port');
            },
            validate(value, helpers) {

                if (Number.isSafeInteger(value) &&
                    value >= 0 &&
                    value <= 65535) {

                    return value;
                }

                return helpers.error('number.port');
            }
        },

        positive: {
            method() {

                return this.sign('positive');
            }
        },

        precision: {
            method(limit) {

                Assert(Number.isSafeInteger(limit), 'limit must be an integer');

                return this.$_addRule({ name: 'precision', args: { limit } });
            },
            validate(value, helpers, { limit }) {

                const places = value.toString().match(internals.precisionRx);
                const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
                if (decimals <= limit) {
                    return value;
                }

                return helpers.error('number.precision', { limit, value });
            },
            convert: true
        },

        sign: {
            method(sign) {

                Assert(['negative', 'positive'].includes(sign), 'Invalid sign', sign);

                return this.$_addRule({ name: 'sign', args: { sign } });
            },
            validate(value, helpers, { sign }) {

                if (sign === 'negative' && value < 0 ||
                    sign === 'positive' && value > 0) {

                    return value;
                }

                return helpers.error(`number.${sign}`);
            }
        },

        unsafe: {
            method(enabled = true) {

                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_setFlag('unsafe', enabled);
            }
        }
    },

    cast: {
        string: {
            from: (value) => typeof value === 'number',
            to(value, helpers) {

                return value.toString();
            }
        }
    },

    messages: {
        'number.base': '{{#label}} must be a number',
        'number.greater': '{{#label}} must be greater than {{#limit}}',
        'number.infinity': '{{#label}} cannot be infinity',
        'number.integer': '{{#label}} must be an integer',
        'number.less': '{{#label}} must be less than {{#limit}}',
        'number.max': '{{#label}} must be less than or equal to {{#limit}}',
        'number.min': '{{#label}} must be greater than or equal to {{#limit}}',
        'number.multiple': '{{#label}} must be a multiple of {{#multiple}}',
        'number.negative': '{{#label}} must be a negative number',
        'number.port': '{{#label}} must be a valid port',
        'number.positive': '{{#label}} must be a positive number',
        'number.precision': '{{#label}} must have no more than {{#limit}} decimal places',
        'number.unsafe': '{{#label}} must be a safe number'
    }
});


// Helpers

internals.normalizeExponent = function (str) {

    return str
        .replace(/E/, 'e')
        .replace(/\.(\d*[1-9])?0+e/, '.$1e')
        .replace(/\.e/, 'e')
        .replace(/e\+/, 'e')
        .replace(/^\+/, '')
        .replace(/^(-?)0+([1-9])/, '$1$2');
};


internals.normalizeDecimal = function (str) {

    str = str
        // Remove leading plus signs
        .replace(/^\+/, '')
        // Remove trailing zeros if there is a decimal point and unecessary decimal points
        .replace(/\.0*$/, '')
        // Add a integer 0 if the numbers starts with a decimal point
        .replace(/^(-?)\.([^\.]*)$/, '$10.$2')
        // Remove leading zeros
        .replace(/^(-?)0+([0-9])/, '$1$2');

    if (str.includes('.') &&
        str.endsWith('0')) {

        str = str.replace(/0+$/, '');
    }

    if (str === '-0') {
        return '0';
    }

    return str;
};


/***/ }),

/***/ "./node_modules/joi/lib/types/object.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/object.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Keys = __webpack_require__(/*! ./keys */ "./node_modules/joi/lib/types/keys.js");


const internals = {};


module.exports = Keys.extend({

    type: 'object',

    cast: {
        map: {
            from: (value) => value && typeof value === 'object',
            to(value, helpers) {

                return new Map(Object.entries(value));
            }
        }
    }
});


/***/ }),

/***/ "./node_modules/joi/lib/types/string.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/string.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Domain = __webpack_require__(/*! @sideway/address/lib/domain */ "./node_modules/@sideway/address/lib/domain.js");
const Email = __webpack_require__(/*! @sideway/address/lib/email */ "./node_modules/@sideway/address/lib/email.js");
const Ip = __webpack_require__(/*! @sideway/address/lib/ip */ "./node_modules/@sideway/address/lib/ip.js");
const EscapeRegex = __webpack_require__(/*! @hapi/hoek/lib/escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js");
const Tlds = __webpack_require__(/*! @sideway/address/lib/tlds */ "./node_modules/@sideway/address/lib/tlds.js");
const Uri = __webpack_require__(/*! @sideway/address/lib/uri */ "./node_modules/@sideway/address/lib/uri.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/joi/lib/common.js");


const internals = {
    tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,              // $lab:coverage:ignore$
    base64Regex: {
        // paddingRequired
        true: {
            // urlSafe
            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
    },
    dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
    hexRegex: /^[a-f0-9]+$/i,
    ipRegex: Ip.regex({ cidr: 'forbidden' }).regex,
    isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,

    guidBrackets: {
        '{': '}', '[': ']', '(': ')', '': ''
    },
    guidVersions: {
        uuidv1: '1',
        uuidv2: '2',
        uuidv3: '3',
        uuidv4: '4',
        uuidv5: '5'
    },
    guidSeparators: new Set([undefined, true, false, '-', ':']),

    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']
};


module.exports = Any.extend({

    type: 'string',

    flags: {

        insensitive: { default: false },
        truncate: { default: false }
    },

    terms: {

        replacements: { init: null }
    },

    coerce: {
        from: 'string',
        method(value, { schema, state, prefs }) {

            const normalize = schema.$_getRule('normalize');
            if (normalize) {
                value = value.normalize(normalize.args.form);
            }

            const casing = schema.$_getRule('case');
            if (casing) {
                value = casing.args.direction === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
            }

            const trim = schema.$_getRule('trim');
            if (trim &&
                trim.args.enabled) {

                value = value.trim();
            }

            if (schema.$_terms.replacements) {
                for (const replacement of schema.$_terms.replacements) {
                    value = value.replace(replacement.pattern, replacement.replacement);
                }
            }

            const hex = schema.$_getRule('hex');
            if (hex &&
                hex.args.options.byteAligned &&
                value.length % 2 !== 0) {

                value = `0${value}`;
            }

            if (schema.$_getRule('isoDate')) {
                const iso = internals.isoDate(value);
                if (iso) {
                    value = iso;
                }
            }

            if (schema._flags.truncate) {
                const rule = schema.$_getRule('max');
                if (rule) {
                    let limit = rule.args.limit;
                    if (Common.isResolvable(limit)) {
                        limit = limit.resolve(value, state, prefs);
                        if (!Common.limit(limit)) {
                            return { value, errors: schema.$_createError('any.ref', limit, { ref: rule.args.limit, arg: 'limit', reason: 'must be a positive integer' }, state, prefs) };
                        }
                    }

                    value = value.slice(0, limit);
                }
            }

            return { value };
        }
    },

    validate(value, { schema, error }) {

        if (typeof value !== 'string') {
            return { value, errors: error('string.base') };
        }

        if (value === '') {
            const min = schema.$_getRule('min');
            if (min &&
                min.args.limit === 0) {

                return;
            }

            return { value, errors: error('string.empty') };
        }
    },

    rules: {

        alphanum: {
            method() {

                return this.$_addRule('alphanum');
            },
            validate(value, helpers) {

                if (/^[a-zA-Z0-9]+$/.test(value)) {
                    return value;
                }

                return helpers.error('string.alphanum');
            }
        },

        base64: {
            method(options = {}) {

                Common.assertOptions(options, ['paddingRequired', 'urlSafe']);

                options = { urlSafe: false, paddingRequired: true, ...options };
                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');
                Assert(typeof options.urlSafe === 'boolean', 'urlSafe must be boolean');

                return this.$_addRule({ name: 'base64', args: { options } });
            },
            validate(value, helpers, { options }) {

                const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
                if (regex.test(value)) {
                    return value;
                }

                return helpers.error('string.base64');
            }
        },

        case: {
            method(direction) {

                Assert(['lower', 'upper'].includes(direction), 'Invalid case:', direction);

                return this.$_addRule({ name: 'case', args: { direction } });
            },
            validate(value, helpers, { direction }) {

                if (direction === 'lower' && value === value.toLocaleLowerCase() ||
                    direction === 'upper' && value === value.toLocaleUpperCase()) {

                    return value;
                }

                return helpers.error(`string.${direction}case`);
            },
            convert: true
        },

        creditCard: {
            method() {

                return this.$_addRule('creditCard');
            },
            validate(value, helpers) {

                let i = value.length;
                let sum = 0;
                let mul = 1;

                while (i--) {
                    const char = value.charAt(i) * mul;
                    sum = sum + (char - (char > 9) * 9);
                    mul = mul ^ 3;
                }

                if (sum > 0 &&
                    sum % 10 === 0) {

                    return value;
                }

                return helpers.error('string.creditCard');
            }
        },

        dataUri: {
            method(options = {}) {

                Common.assertOptions(options, ['paddingRequired']);

                options = { paddingRequired: true, ...options };
                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');

                return this.$_addRule({ name: 'dataUri', args: { options } });
            },
            validate(value, helpers, { options }) {

                const matches = value.match(internals.dataUriRegex);

                if (matches) {
                    if (!matches[2]) {
                        return value;
                    }

                    if (matches[2] !== 'base64') {
                        return value;
                    }

                    const base64regex = internals.base64Regex[options.paddingRequired].false;
                    if (base64regex.test(matches[3])) {
                        return value;
                    }
                }

                return helpers.error('string.dataUri');
            }
        },

        domain: {
            method(options) {

                if (options) {
                    Common.assertOptions(options, ['allowFullyQualified', 'allowUnicode', 'maxDomainSegments', 'minDomainSegments', 'tlds']);
                }

                const address = internals.addressOptions(options);
                return this.$_addRule({ name: 'domain', args: { options }, address });
            },
            validate(value, helpers, args, { address }) {

                if (Domain.isValid(value, address)) {
                    return value;
                }

                return helpers.error('string.domain');
            }
        },

        email: {
            method(options = {}) {

                Common.assertOptions(options, ['allowFullyQualified', 'allowUnicode', 'ignoreLength', 'maxDomainSegments', 'minDomainSegments', 'multiple', 'separator', 'tlds']);
                Assert(options.multiple === undefined || typeof options.multiple === 'boolean', 'multiple option must be an boolean');

                const address = internals.addressOptions(options);
                const regex = new RegExp(`\\s*[${options.separator ? EscapeRegex(options.separator) : ','}]\\s*`);

                return this.$_addRule({ name: 'email', args: { options }, regex, address });
            },
            validate(value, helpers, { options }, { regex, address }) {

                const emails = options.multiple ? value.split(regex) : [value];
                const invalids = [];
                for (const email of emails) {
                    if (!Email.isValid(email, address)) {
                        invalids.push(email);
                    }
                }

                if (!invalids.length) {
                    return value;
                }

                return helpers.error('string.email', { value, invalids });
            }
        },

        guid: {
            alias: 'uuid',
            method(options = {}) {

                Common.assertOptions(options, ['version', 'separator']);

                let versionNumbers = '';

                if (options.version) {
                    const versions = [].concat(options.version);

                    Assert(versions.length >= 1, 'version must have at least 1 valid version specified');
                    const set = new Set();

                    for (let i = 0; i < versions.length; ++i) {
                        const version = versions[i];
                        Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                        const versionNumber = internals.guidVersions[version.toLowerCase()];
                        Assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));
                        Assert(!set.has(versionNumber), 'version at position ' + i + ' must not be a duplicate');

                        versionNumbers += versionNumber;
                        set.add(versionNumber);
                    }
                }

                Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, "-", or ":"');
                const separator = options.separator === undefined ? '[:-]?' :
                    options.separator === true ? '[:-]' :
                        options.separator === false ? '[]?' : `\\${options.separator}`;

                const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, 'i');

                return this.$_addRule({ name: 'guid', args: { options }, regex });
            },
            validate(value, helpers, args, { regex }) {

                const results = regex.exec(value);

                if (!results) {
                    return helpers.error('string.guid');
                }

                // Matching braces

                if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
                    return helpers.error('string.guid');
                }

                return value;
            }
        },

        hex: {
            method(options = {}) {

                Common.assertOptions(options, ['byteAligned']);

                options = { byteAligned: false, ...options };
                Assert(typeof options.byteAligned === 'boolean', 'byteAligned must be boolean');

                return this.$_addRule({ name: 'hex', args: { options } });
            },
            validate(value, helpers, { options }) {

                if (!internals.hexRegex.test(value)) {
                    return helpers.error('string.hex');
                }

                if (options.byteAligned &&
                    value.length % 2 !== 0) {

                    return helpers.error('string.hexAlign');
                }

                return value;
            }
        },

        hostname: {
            method() {

                return this.$_addRule('hostname');
            },
            validate(value, helpers) {

                if (Domain.isValid(value, { minDomainSegments: 1 }) ||
                    internals.ipRegex.test(value)) {

                    return value;
                }

                return helpers.error('string.hostname');
            }
        },

        insensitive: {
            method() {

                return this.$_setFlag('insensitive', true);
            }
        },

        ip: {
            method(options = {}) {

                Common.assertOptions(options, ['cidr', 'version']);

                const { cidr, versions, regex } = Ip.regex(options);
                const version = options.version ? versions : undefined;
                return this.$_addRule({ name: 'ip', args: { options: { cidr, version } }, regex });
            },
            validate(value, helpers, { options }, { regex }) {

                if (regex.test(value)) {
                    return value;
                }

                if (options.version) {
                    return helpers.error('string.ipVersion', { value, cidr: options.cidr, version: options.version });
                }

                return helpers.error('string.ip', { value, cidr: options.cidr });
            }
        },

        isoDate: {
            method() {

                return this.$_addRule('isoDate');
            },
            validate(value, { error }) {

                if (internals.isoDate(value)) {
                    return value;
                }

                return error('string.isoDate');
            }
        },

        isoDuration: {
            method() {

                return this.$_addRule('isoDuration');
            },
            validate(value, helpers) {

                if (internals.isoDurationRegex.test(value)) {
                    return value;
                }

                return helpers.error('string.isoDuration');
            }
        },

        length: {
            method(limit, encoding) {

                return internals.length(this, 'length', limit, '=', encoding);
            },
            validate(value, helpers, { limit, encoding }, { name, operator, args }) {

                const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;      // $lab:coverage:ignore$
                if (Common.compare(length, limit, operator)) {
                    return value;
                }

                return helpers.error('string.' + name, { limit: args.limit, value, encoding });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                },
                'encoding'
            ]
        },

        lowercase: {
            method() {

                return this.case('lower');
            }
        },

        max: {
            method(limit, encoding) {

                return internals.length(this, 'max', limit, '<=', encoding);
            },
            args: ['limit', 'encoding']
        },

        min: {
            method(limit, encoding) {

                return internals.length(this, 'min', limit, '>=', encoding);
            },
            args: ['limit', 'encoding']
        },

        normalize: {
            method(form = 'NFC') {

                Assert(internals.normalizationForms.includes(form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));

                return this.$_addRule({ name: 'normalize', args: { form } });
            },
            validate(value, { error }, { form }) {

                if (value === value.normalize(form)) {
                    return value;
                }

                return error('string.normalize', { value, form });
            },
            convert: true
        },

        pattern: {
            alias: 'regex',
            method(regex, options = {}) {

                Assert(regex instanceof RegExp, 'regex must be a RegExp');
                Assert(!regex.flags.includes('g') && !regex.flags.includes('y'), 'regex should not use global or sticky mode');

                if (typeof options === 'string') {
                    options = { name: options };
                }

                Common.assertOptions(options, ['invert', 'name']);

                const errorCode = ['string.pattern', options.invert ? '.invert' : '', options.name ? '.name' : '.base'].join('');
                return this.$_addRule({ name: 'pattern', args: { regex, options }, errorCode });
            },
            validate(value, helpers, { regex, options }, { errorCode }) {

                const patternMatch = regex.test(value);

                if (patternMatch ^ options.invert) {
                    return value;
                }

                return helpers.error(errorCode, { name: options.name, regex, value });
            },
            args: ['regex', 'options'],
            multi: true
        },

        replace: {
            method(pattern, replacement) {

                if (typeof pattern === 'string') {
                    pattern = new RegExp(EscapeRegex(pattern), 'g');
                }

                Assert(pattern instanceof RegExp, 'pattern must be a RegExp');
                Assert(typeof replacement === 'string', 'replacement must be a String');

                const obj = this.clone();

                if (!obj.$_terms.replacements) {
                    obj.$_terms.replacements = [];
                }

                obj.$_terms.replacements.push({ pattern, replacement });
                return obj;
            }
        },

        token: {
            method() {

                return this.$_addRule('token');
            },
            validate(value, helpers) {

                if (/^\w+$/.test(value)) {
                    return value;
                }

                return helpers.error('string.token');
            }
        },

        trim: {
            method(enabled = true) {

                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_addRule({ name: 'trim', args: { enabled } });
            },
            validate(value, helpers, { enabled }) {

                if (!enabled ||
                    value === value.trim()) {

                    return value;
                }

                return helpers.error('string.trim');
            },
            convert: true
        },

        truncate: {
            method(enabled = true) {

                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_setFlag('truncate', enabled);
            }
        },

        uppercase: {
            method() {

                return this.case('upper');
            }
        },

        uri: {
            method(options = {}) {

                Common.assertOptions(options, ['allowRelative', 'allowQuerySquareBrackets', 'domain', 'relativeOnly', 'scheme']);

                if (options.domain) {
                    Common.assertOptions(options.domain, ['allowFullyQualified', 'allowUnicode', 'maxDomainSegments', 'minDomainSegments', 'tlds']);
                }

                const { regex, scheme } = Uri.regex(options);
                const domain = options.domain ? internals.addressOptions(options.domain) : null;
                return this.$_addRule({ name: 'uri', args: { options }, regex, domain, scheme });
            },
            validate(value, helpers, { options }, { regex, domain, scheme }) {

                if (['http:/', 'https:/'].includes(value)) {            // scheme:/ is technically valid but makes no sense
                    return helpers.error('string.uri');
                }

                const match = regex.exec(value);
                if (match) {
                    const matched = match[1] || match[2];
                    if (domain &&
                        (!options.allowRelative || matched) &&
                        !Domain.isValid(matched, domain)) {

                        return helpers.error('string.domain', { value: matched });
                    }

                    return value;
                }

                if (options.relativeOnly) {
                    return helpers.error('string.uriRelativeOnly');
                }

                if (options.scheme) {
                    return helpers.error('string.uriCustomScheme', { scheme, value });
                }

                return helpers.error('string.uri');
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.replacements) {
                for (const { pattern, replacement } of desc.replacements) {
                    obj = obj.replace(pattern, replacement);
                }
            }

            return obj;
        }
    },

    messages: {
        'string.alphanum': '{{#label}} must only contain alpha-numeric characters',
        'string.base': '{{#label}} must be a string',
        'string.base64': '{{#label}} must be a valid base64 string',
        'string.creditCard': '{{#label}} must be a credit card',
        'string.dataUri': '{{#label}} must be a valid dataUri string',
        'string.domain': '{{#label}} must contain a valid domain name',
        'string.email': '{{#label}} must be a valid email',
        'string.empty': '{{#label}} is not allowed to be empty',
        'string.guid': '{{#label}} must be a valid GUID',
        'string.hex': '{{#label}} must only contain hexadecimal characters',
        'string.hexAlign': '{{#label}} hex decoded representation must be byte aligned',
        'string.hostname': '{{#label}} must be a valid hostname',
        'string.ip': '{{#label}} must be a valid ip address with a {{#cidr}} CIDR',
        'string.ipVersion': '{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',
        'string.isoDate': '{{#label}} must be in iso format',
        'string.isoDuration': '{{#label}} must be a valid ISO 8601 duration',
        'string.length': '{{#label}} length must be {{#limit}} characters long',
        'string.lowercase': '{{#label}} must only contain lowercase characters',
        'string.max': '{{#label}} length must be less than or equal to {{#limit}} characters long',
        'string.min': '{{#label}} length must be at least {{#limit}} characters long',
        'string.normalize': '{{#label}} must be unicode normalized in the {{#form}} form',
        'string.token': '{{#label}} must only contain alpha-numeric and underscore characters',
        'string.pattern.base': '{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}',
        'string.pattern.name': '{{#label}} with value {:[.]} fails to match the {{#name}} pattern',
        'string.pattern.invert.base': '{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}',
        'string.pattern.invert.name': '{{#label}} with value {:[.]} matches the inverted {{#name}} pattern',
        'string.trim': '{{#label}} must not have leading or trailing whitespace',
        'string.uri': '{{#label}} must be a valid uri',
        'string.uriCustomScheme': '{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern',
        'string.uriRelativeOnly': '{{#label}} must be a valid relative uri',
        'string.uppercase': '{{#label}} must only contain uppercase characters'
    }
});


// Helpers

internals.addressOptions = function (options) {

    if (!options) {
        return options;
    }

    // minDomainSegments

    Assert(options.minDomainSegments === undefined ||
        Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, 'minDomainSegments must be a positive integer');

    // maxDomainSegments

    Assert(options.maxDomainSegments === undefined ||
        Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, 'maxDomainSegments must be a positive integer');

    // tlds

    if (options.tlds === false) {
        return options;
    }

    if (options.tlds === true ||
        options.tlds === undefined) {

        Assert(internals.tlds, 'Built-in TLD list disabled');
        return Object.assign({}, options, internals.tlds);
    }

    Assert(typeof options.tlds === 'object', 'tlds must be true, false, or an object');

    const deny = options.tlds.deny;
    if (deny) {
        if (Array.isArray(deny)) {
            options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });
        }

        Assert(options.tlds.deny instanceof Set, 'tlds.deny must be an array, Set, or boolean');
        Assert(!options.tlds.allow, 'Cannot specify both tlds.allow and tlds.deny lists');
        internals.validateTlds(options.tlds.deny, 'tlds.deny');
        return options;
    }

    const allow = options.tlds.allow;
    if (!allow) {
        return options;
    }

    if (allow === true) {
        Assert(internals.tlds, 'Built-in TLD list disabled');
        return Object.assign({}, options, internals.tlds);
    }

    if (Array.isArray(allow)) {
        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });
    }

    Assert(options.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');
    internals.validateTlds(options.tlds.allow, 'tlds.allow');
    return options;
};


internals.validateTlds = function (set, source) {

    for (const tld of set) {
        Assert(Domain.isValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);
    }
};


internals.isoDate = function (value) {

    if (!Common.isIsoDate(value)) {
        return null;
    }

    if (/.*T.*[+-]\d\d$/.test(value)) {             // Add missing trailing zeros to timeshift
        value += '00';
    }

    const date = new Date(value);
    if (isNaN(date.getTime())) {
        return null;
    }

    return date.toISOString();
};


internals.length = function (schema, name, limit, operator, encoding) {

    Assert(!encoding || Buffer && Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);      // $lab:coverage:ignore$

    return schema.$_addRule({ name, method: 'length', args: { limit, encoding }, operator });
};


/***/ }),

/***/ "./node_modules/joi/lib/types/symbol.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/symbol.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/joi/lib/types/any.js");


const internals = {};


internals.Map = class extends Map {

    slice() {

        return new internals.Map(this);
    }
};


module.exports = Any.extend({

    type: 'symbol',

    terms: {

        map: { init: new internals.Map() }
    },

    coerce: {
        method(value, { schema, error }) {

            const lookup = schema.$_terms.map.get(value);
            if (lookup) {
                value = lookup;
            }

            if (!schema._flags.only ||
                typeof value === 'symbol') {

                return { value };
            }

            return { value, errors: error('symbol.map', { map: schema.$_terms.map }) };
        }
    },

    validate(value, { error }) {

        if (typeof value !== 'symbol') {
            return { value, errors: error('symbol.base') };
        }
    },

    rules: {
        map: {
            method(iterable) {

                if (iterable &&
                    !iterable[Symbol.iterator] &&
                    typeof iterable === 'object') {

                    iterable = Object.entries(iterable);
                }

                Assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');

                const obj = this.clone();

                const symbols = [];
                for (const entry of iterable) {
                    Assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');
                    const [key, value] = entry;

                    Assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be of type object, function, or Symbol');
                    Assert(typeof value === 'symbol', 'Value must be a Symbol');

                    obj.$_terms.map.set(key, value);
                    symbols.push(value);
                }

                return obj.valid(...symbols);
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.map) {
                obj = obj.map(desc.map);
            }

            return obj;
        }
    },

    messages: {
        'symbol.base': '{{#label}} must be a symbol',
        'symbol.map': '{{#label}} must be one of {{#map}}'
    }
});


/***/ }),

/***/ "./node_modules/joi/lib/validator.js":
/*!*******************************************!*\
  !*** ./node_modules/joi/lib/validator.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Ignore = __webpack_require__(/*! @hapi/hoek/lib/ignore */ "./node_modules/@hapi/hoek/lib/ignore.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/joi/lib/errors.js");
const State = __webpack_require__(/*! ./state */ "./node_modules/joi/lib/state.js");


const internals = {
    result: Symbol('result')
};


exports.entry = function (value, schema, prefs) {

    let settings = Common.defaults;
    if (prefs) {
        Assert(prefs.warnings === undefined, 'Cannot override warnings preference in synchronous validation');
        Assert(prefs.artifacts === undefined, 'Cannot override artifacts preference in synchronous validation');
        settings = Common.preferences(Common.defaults, prefs);
    }

    const result = internals.entry(value, schema, settings);
    Assert(!result.mainstay.externals.length, 'Schema with external rules must use validateAsync()');
    const outcome = { value: result.value };

    if (result.error) {
        outcome.error = result.error;
    }

    if (result.mainstay.warnings.length) {
        outcome.warning = Errors.details(result.mainstay.warnings);
    }

    if (result.mainstay.debug) {
        outcome.debug = result.mainstay.debug;
    }

    if (result.mainstay.artifacts) {
        outcome.artifacts = result.mainstay.artifacts;
    }

    return outcome;
};


exports.entryAsync = async function (value, schema, prefs) {

    let settings = Common.defaults;
    if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
    }

    const result = internals.entry(value, schema, settings);
    const mainstay = result.mainstay;
    if (result.error) {
        if (mainstay.debug) {
            result.error.debug = mainstay.debug;
        }

        throw result.error;
    }

    if (mainstay.externals.length) {
        let root = result.value;
        for (const { method, path, label } of mainstay.externals) {
            let node = root;
            let key;
            let parent;

            if (path.length) {
                key = path[path.length - 1];
                parent = Reach(root, path.slice(0, -1));
                node = parent[key];
            }

            try {
                const output = await method(node, { prefs });
                if (output === undefined ||
                    output === node) {

                    continue;
                }

                if (parent) {
                    parent[key] = output;
                }
                else {
                    root = output;
                }
            }
            catch (err) {
                if (settings.errors.label) {
                    err.message += ` (${label})`;       // Change message to include path
                }

                throw err;
            }
        }

        result.value = root;
    }

    if (!settings.warnings &&
        !settings.debug &&
        !settings.artifacts) {

        return result.value;
    }

    const outcome = { value: result.value };
    if (mainstay.warnings.length) {
        outcome.warning = Errors.details(mainstay.warnings);
    }

    if (mainstay.debug) {
        outcome.debug = mainstay.debug;
    }

    if (mainstay.artifacts) {
        outcome.artifacts = mainstay.artifacts;
    }

    return outcome;
};


internals.entry = function (value, schema, prefs) {

    // Prepare state

    const { tracer, cleanup } = internals.tracer(schema, prefs);
    const debug = prefs.debug ? [] : null;
    const links = schema._ids._schemaChain ? new Map() : null;
    const mainstay = { externals: [], warnings: [], tracer, debug, links };
    const schemas = schema._ids._schemaChain ? [{ schema }] : null;
    const state = new State([], [], { mainstay, schemas });

    // Validate value

    const result = exports.validate(value, schema, state, prefs);

    // Process value and errors

    if (cleanup) {
        schema.$_root.untrace();
    }

    const error = Errors.process(result.errors, value, prefs);
    return { value: result.value, error, mainstay };
};


internals.tracer = function (schema, prefs) {

    if (schema.$_root._tracer) {
        return { tracer: schema.$_root._tracer._register(schema) };
    }

    if (prefs.debug) {
        Assert(schema.$_root.trace, 'Debug mode not supported');
        return { tracer: schema.$_root.trace()._register(schema), cleanup: true };
    }

    return { tracer: internals.ignore };
};


exports.validate = function (value, schema, state, prefs, overrides = {}) {

    if (schema.$_terms.whens) {
        schema = schema._generate(value, state, prefs).schema;
    }

    // Setup state and settings

    if (schema._preferences) {
        prefs = internals.prefs(schema, prefs);
    }

    // Cache

    if (schema._cache &&
        prefs.cache) {

        const result = schema._cache.get(value);
        state.mainstay.tracer.debug(state, 'validate', 'cached', !!result);
        if (result) {
            return result;
        }
    }

    // Helpers

    const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);
    const helpers = {
        original: value,
        prefs,
        schema,
        state,
        error: createError,
        errorsArray: internals.errorsArray,
        warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),
        message: (messages, local) => schema.$_createError('custom', value, local, state, prefs, { messages })
    };

    // Prepare

    state.mainstay.tracer.entry(schema, state);

    const def = schema._definition;
    if (def.prepare &&
        value !== undefined &&
        prefs.convert) {

        const prepared = def.prepare(value, helpers);
        if (prepared) {
            state.mainstay.tracer.value(state, 'prepare', value, prepared.value);
            if (prepared.errors) {
                return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);         // Prepare error always aborts early
            }

            value = prepared.value;
        }
    }

    // Type coercion

    if (def.coerce &&
        value !== undefined &&
        prefs.convert &&
        (!def.coerce.from || def.coerce.from.includes(typeof value))) {

        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
            state.mainstay.tracer.value(state, 'coerced', value, coerced.value);
            if (coerced.errors) {
                return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);           // Coerce error always aborts early
            }

            value = coerced.value;
        }
    }

    // Empty value

    const empty = schema._flags.empty;
    if (empty &&
        empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {

        state.mainstay.tracer.value(state, 'empty', value, undefined);
        value = undefined;
    }

    // Presence requirements (required, optional, forbidden)

    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);
    if (value === undefined) {
        if (presence === 'forbidden') {
            return internals.finalize(value, null, helpers);
        }

        if (presence === 'required') {
            return internals.finalize(value, [schema.$_createError('any.required', value, null, state, prefs)], helpers);
        }

        if (presence === 'optional') {
            if (schema._flags.default !== Common.symbols.deepDefault) {
                return internals.finalize(value, null, helpers);
            }

            state.mainstay.tracer.value(state, 'default', value, {});
            value = {};
        }
    }
    else if (presence === 'forbidden') {
        return internals.finalize(value, [schema.$_createError('any.unknown', value, null, state, prefs)], helpers);
    }

    // Allowed values

    const errors = [];

    if (schema._valids) {
        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
            if (prefs.convert) {
                state.mainstay.tracer.value(state, 'valids', value, match.value);
                value = match.value;
            }

            state.mainstay.tracer.filter(schema, state, 'valid', match);
            return internals.finalize(value, null, helpers);
        }

        if (schema._flags.only) {
            const report = schema.$_createError('any.only', value, { valids: schema._valids.values({ display: true }) }, state, prefs);
            if (prefs.abortEarly) {
                return internals.finalize(value, [report], helpers);
            }

            errors.push(report);
        }
    }

    // Denied values

    if (schema._invalids) {
        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
            state.mainstay.tracer.filter(schema, state, 'invalid', match);
            const report = schema.$_createError('any.invalid', value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);
            if (prefs.abortEarly) {
                return internals.finalize(value, [report], helpers);
            }

            errors.push(report);
        }
    }

    // Base type

    if (def.validate) {
        const base = def.validate(value, helpers);
        if (base) {
            state.mainstay.tracer.value(state, 'base', value, base.value);
            value = base.value;

            if (base.errors) {
                if (!Array.isArray(base.errors)) {
                    errors.push(base.errors);
                    return internals.finalize(value, errors, helpers);          // Base error always aborts early
                }

                if (base.errors.length) {
                    errors.push(...base.errors);
                    return internals.finalize(value, errors, helpers);          // Base error always aborts early
                }
            }
        }
    }

    // Validate tests

    if (!schema._rules.length) {
        return internals.finalize(value, errors, helpers);
    }

    return internals.rules(value, errors, helpers);
};


internals.rules = function (value, errors, helpers) {

    const { schema, state, prefs } = helpers;

    for (const rule of schema._rules) {
        const definition = schema._definition.rules[rule.method];

        // Skip rules that are also applied in coerce step

        if (definition.convert &&
            prefs.convert) {

            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'full');
            continue;
        }

        // Resolve references

        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
            args = Object.assign({}, args);                                     // Shallow copy
            for (const key of rule._resolve) {
                const resolver = definition.argsByName.get(key);

                const resolved = args[key].resolve(value, state, prefs);
                const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;

                const invalid = Common.validateArg(normalized, null, resolver);
                if (invalid) {
                    ret = schema.$_createError('any.ref', resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
                    break;
                }

                args[key] = normalized;
            }
        }

        // Test rule

        ret = ret || definition.validate(value, helpers, args, rule);           // Use ret if already set to reference error

        const result = internals.rule(ret, rule);
        if (result.errors) {
            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'error');

            if (rule.warn) {
                state.mainstay.warnings.push(...result.errors);
                continue;
            }

            if (prefs.abortEarly) {
                return internals.finalize(value, result.errors, helpers);
            }

            errors.push(...result.errors);
        }
        else {
            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'pass');
            state.mainstay.tracer.value(state, 'rule', value, result.value, rule.name);
            value = result.value;
        }
    }

    return internals.finalize(value, errors, helpers);
};


internals.rule = function (ret, rule) {

    if (ret instanceof Errors.Report) {
        internals.error(ret, rule);
        return { errors: [ret], value: null };
    }

    if (Array.isArray(ret) &&
        ret[Common.symbols.errors]) {

        ret.forEach((report) => internals.error(report, rule));
        return { errors: ret, value: null };
    }

    return { errors: null, value: ret };
};


internals.error = function (report, rule) {

    if (rule.message) {
        report._setTemplate(rule.message);
    }

    return report;
};


internals.finalize = function (value, errors, helpers) {

    errors = errors || [];
    const { schema, state, prefs } = helpers;

    // Failover value

    if (errors.length) {
        const failover = internals.default('failover', undefined, errors, helpers);
        if (failover !== undefined) {
            state.mainstay.tracer.value(state, 'failover', value, failover);
            value = failover;
            errors = [];
        }
    }

    // Error override

    if (errors.length &&
        schema._flags.error) {

        if (typeof schema._flags.error === 'function') {
            errors = schema._flags.error(errors);
            if (!Array.isArray(errors)) {
                errors = [errors];
            }

            for (const error of errors) {
                Assert(error instanceof Error || error instanceof Errors.Report, 'error() must return an Error object');
            }
        }
        else {
            errors = [schema._flags.error];
        }
    }

    // Default

    if (value === undefined) {
        const defaulted = internals.default('default', value, errors, helpers);
        state.mainstay.tracer.value(state, 'default', value, defaulted);
        value = defaulted;
    }

    // Cast

    if (schema._flags.cast &&
        value !== undefined) {

        const caster = schema._definition.cast[schema._flags.cast];
        if (caster.from(value)) {
            const casted = caster.to(value, helpers);
            state.mainstay.tracer.value(state, 'cast', value, casted, schema._flags.cast);
            value = casted;
        }
    }

    // Externals

    if (schema.$_terms.externals &&
        prefs.externals &&
        prefs._externals !== false) {                       // Disabled for matching

        for (const { method } of schema.$_terms.externals) {
            state.mainstay.externals.push({ method, path: state.path, label: Errors.label(schema._flags, state, prefs) });
        }
    }

    // Result

    const result = { value, errors: errors.length ? errors : null };

    if (schema._flags.result) {
        result.value = schema._flags.result === 'strip' ? undefined : /* raw */ helpers.original;
        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);
        state.shadow(value, schema._flags.result);
    }

    // Cache

    if (schema._cache &&
        prefs.cache !== false &&
        !schema._refs.length) {

        schema._cache.set(helpers.original, result);
    }

    // Artifacts

    if (value !== undefined &&
        !result.errors &&
        schema._flags.artifact !== undefined) {

        state.mainstay.artifacts = state.mainstay.artifacts || new Map();
        if (!state.mainstay.artifacts.has(schema._flags.artifact)) {
            state.mainstay.artifacts.set(schema._flags.artifact, []);
        }

        state.mainstay.artifacts.get(schema._flags.artifact).push(state.path);
    }

    return result;
};


internals.prefs = function (schema, prefs) {

    const isDefaultOptions = prefs === Common.defaults;
    if (isDefaultOptions &&
        schema._preferences[Common.symbols.prefs]) {

        return schema._preferences[Common.symbols.prefs];
    }

    prefs = Common.preferences(prefs, schema._preferences);
    if (isDefaultOptions) {
        schema._preferences[Common.symbols.prefs] = prefs;
    }

    return prefs;
};


internals.default = function (flag, value, errors, helpers) {

    const { schema, state, prefs } = helpers;
    const source = schema._flags[flag];
    if (prefs.noDefaults ||
        source === undefined) {

        return value;
    }

    state.mainstay.tracer.log(schema, state, 'rule', flag, 'full');

    if (!source) {
        return source;
    }

    if (typeof source === 'function') {
        const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];

        try {
            return source(...args);
        }
        catch (err) {
            errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
            return;
        }
    }

    if (typeof source !== 'object') {
        return source;
    }

    if (source[Common.symbols.literal]) {
        return source.literal;
    }

    if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
    }

    return Clone(source);
};


internals.trim = function (value, schema) {

    if (typeof value !== 'string') {
        return value;
    }

    const trim = schema.$_getRule('trim');
    if (!trim ||
        !trim.args.enabled) {

        return value;
    }

    return value.trim();
};


internals.ignore = {
    active: false,
    debug: Ignore,
    entry: Ignore,
    filter: Ignore,
    log: Ignore,
    resolve: Ignore,
    value: Ignore
};


internals.errorsArray = function () {

    const errors = [];
    errors[Common.symbols.errors] = true;
    return errors;
};


/***/ }),

/***/ "./node_modules/joi/lib/values.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/values.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/joi/lib/common.js");


const internals = {};


module.exports = internals.Values = class {

    constructor(values, refs) {

        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);

        this._override = false;
    }

    get length() {

        return this._values.size + this._refs.size;
    }

    add(value, refs) {

        // Reference

        if (Common.isResolvable(value)) {
            if (!this._refs.has(value)) {
                this._refs.add(value);

                if (refs) {                     // Skipped in a merge
                    refs.register(value);
                }
            }

            return;
        }

        // Value

        if (!this.has(value, null, null, false)) {
            this._values.add(value);

            if (typeof value === 'string') {
                this._lowercase.set(value.toLowerCase(), value);
            }
        }
    }

    static merge(target, source, remove) {

        target = target || new internals.Values();

        if (source) {
            if (source._override) {
                return source.clone();
            }

            for (const item of [...source._values, ...source._refs]) {
                target.add(item);
            }
        }

        if (remove) {
            for (const item of [...remove._values, ...remove._refs]) {
                target.remove(item);
            }
        }

        return target.length ? target : null;
    }

    remove(value) {

        // Reference

        if (Common.isResolvable(value)) {
            this._refs.delete(value);
            return;
        }

        // Value

        this._values.delete(value);

        if (typeof value === 'string') {
            this._lowercase.delete(value.toLowerCase());
        }
    }

    has(value, state, prefs, insensitive) {

        return !!this.get(value, state, prefs, insensitive);
    }

    get(value, state, prefs, insensitive) {

        if (!this.length) {
            return false;
        }

        // Simple match

        if (this._values.has(value)) {
            return { value };
        }

        // Case insensitive string match

        if (typeof value === 'string' &&
            value &&
            insensitive) {

            const found = this._lowercase.get(value.toLowerCase());
            if (found) {
                return { value: found };
            }
        }

        if (!this._refs.size &&
            typeof value !== 'object') {

            return false;
        }

        // Objects

        if (typeof value === 'object') {
            for (const item of this._values) {
                if (DeepEqual(item, value)) {
                    return { value: item };
                }
            }
        }

        // References

        if (state) {
            for (const ref of this._refs) {
                const resolved = ref.resolve(value, state, prefs, null, { in: true });
                if (resolved === undefined) {
                    continue;
                }

                const items = !ref.in || typeof resolved !== 'object'
                    ? [resolved]
                    : Array.isArray(resolved) ? resolved : Object.keys(resolved);

                for (const item of items) {
                    if (typeof item !== typeof value) {
                        continue;
                    }

                    if (insensitive &&
                        value &&
                        typeof value === 'string') {

                        if (item.toLowerCase() === value.toLowerCase()) {
                            return { value: item, ref };
                        }
                    }
                    else {
                        if (DeepEqual(item, value)) {
                            return { value: item, ref };
                        }
                    }
                }
            }
        }

        return false;
    }

    override() {

        this._override = true;
    }

    values(options) {

        if (options &&
            options.display) {

            const values = [];

            for (const item of [...this._values, ...this._refs]) {
                if (item !== undefined) {
                    values.push(item);
                }
            }

            return values;
        }

        return Array.from([...this._values, ...this._refs]);
    }

    clone() {

        const set = new internals.Values(this._values, this._refs);
        set._override = this._override;
        return set;
    }

    concat(source) {

        Assert(!source._override, 'Cannot concat override set of values');

        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
        set._override = this._override;
        return set;
    }

    describe() {

        const normalized = [];

        if (this._override) {
            normalized.push({ override: true });
        }

        for (const value of this._values.values()) {
            normalized.push(value && typeof value === 'object' ? { value } : value);
        }

        for (const value of this._refs.values()) {
            normalized.push(value.describe());
        }

        return normalized;
    }
};


internals.Values.prototype[Common.symbols.values] = true;


// Aliases

internals.Values.prototype.slice = internals.Values.prototype.clone;


// Helpers

internals.lowercases = function (from) {

    const map = new Map();

    if (from) {
        for (const value of from) {
            if (typeof value === 'string') {
                map.set(value.toLowerCase(), value);
            }
        }
    }

    return map;
};


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hello = exports.handler = void 0;
// import joi from "joi";
const core_1 = __importDefault(__webpack_require__(/*! @middy/core */ "./node_modules/@middy/core/index.cjs"));
const validation_1 = __importDefault(__webpack_require__(/*! ./validation */ "./src/validation.ts"));
const handler = (event) => {
    const name = event.queryStringParameters?.name;
    const response = {
        statusCode: 200,
        body: JSON.stringify({
            message: `Hello ${name}!`,
        }, null, 2),
    };
    return new Promise((resolve) => {
        resolve(response);
    });
};
exports.handler = handler;
exports.hello = (0, core_1.default)(exports.handler).use((0, validation_1.default)());


/***/ }),

/***/ "./src/validation.ts":
/*!***************************!*\
  !*** ./src/validation.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const joi_1 = __importDefault(__webpack_require__(/*! joi */ "./node_modules/joi/lib/index.js"));
const boom_1 = __importDefault(__webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js"));
const schema = joi_1.default.object({
    name: joi_1.default.string().alphanum().required(),
});
const middleware = () => {
    const before = async (request) => {
        const name = request.event.queryStringParameters?.name;
        const candidate = schema.validate({ name });
        if (Object.prototype.hasOwnProperty.call(candidate, "error")) {
            const response = boom_1.default.badRequest("Invalid query string parametr, it should be name=some_name");
            return response;
        }
        // eslint-disable-next-line consistent-return, no-useless-return
        return;
    };
    return {
        before,
    };
};
exports["default"] = middleware;


/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "./node_modules/@middy/core/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/@middy/core/index.cjs ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
module.exports = void 0;
var _events = __webpack_require__(/*! events */ "events");
const defaultLambdaHandler = ()=>{};
const defaultPlugin = {
    timeoutEarlyInMillis: 5,
    timeoutEarlyResponse: ()=>{
        throw new Error('Timeout');
    }
};
const middy = (lambdaHandler = defaultLambdaHandler, plugin = {})=>{
    if (typeof lambdaHandler !== 'function') {
        plugin = lambdaHandler;
        lambdaHandler = defaultLambdaHandler;
    }
    plugin = {
        ...defaultPlugin,
        ...plugin
    };
    plugin.timeoutEarly = plugin.timeoutEarlyInMillis > 0;
    plugin.beforePrefetch?.();
    const beforeMiddlewares = [];
    const afterMiddlewares = [];
    const onErrorMiddlewares = [];
    const middy1 = (event = {}, context = {})=>{
        plugin.requestStart?.();
        const request = {
            event,
            context,
            response: undefined,
            error: undefined,
            internal: plugin.internal ?? {}
        };
        return runRequest(request, [
            ...beforeMiddlewares
        ], lambdaHandler, [
            ...afterMiddlewares
        ], [
            ...onErrorMiddlewares
        ], plugin);
    };
    middy1.use = (middlewares)=>{
        if (!Array.isArray(middlewares)) {
            middlewares = [
                middlewares
            ];
        }
        for (const middleware of middlewares){
            const { before , after , onError  } = middleware;
            if (!before && !after && !onError) {
                throw new Error('Middleware must be an object containing at least one key among "before", "after", "onError"');
            }
            if (before) middy1.before(before);
            if (after) middy1.after(after);
            if (onError) middy1.onError(onError);
        }
        return middy1;
    };
    middy1.before = (beforeMiddleware)=>{
        beforeMiddlewares.push(beforeMiddleware);
        return middy1;
    };
    middy1.after = (afterMiddleware)=>{
        afterMiddlewares.unshift(afterMiddleware);
        return middy1;
    };
    middy1.onError = (onErrorMiddleware)=>{
        onErrorMiddlewares.unshift(onErrorMiddleware);
        return middy1;
    };
    middy1.handler = (replaceLambdaHandler)=>{
        lambdaHandler = replaceLambdaHandler;
        return middy1;
    };
    return middy1;
};
const runRequest = async (request, beforeMiddlewares, lambdaHandler, afterMiddlewares, onErrorMiddlewares, plugin)=>{
    const timeoutEarly = plugin.timeoutEarly && request.context.getRemainingTimeInMillis;
    try {
        await runMiddlewares(request, beforeMiddlewares, plugin);
        if (typeof request.response === 'undefined') {
            plugin.beforeHandler?.();
            const handlerAbort = new AbortController();
            let timeoutAbort;
            if (timeoutEarly) timeoutAbort = new AbortController();
            request.response = await Promise.race([
                lambdaHandler(request.event, request.context, {
                    signal: handlerAbort.signal
                }),
                timeoutEarly ? setTimeoutPromise(request.context.getRemainingTimeInMillis() - plugin.timeoutEarlyInMillis, {
                    signal: timeoutAbort.signal
                }).then(()=>{
                    handlerAbort.abort();
                    return plugin.timeoutEarlyResponse();
                }) : Promise.race([])
            ]);
            if (timeoutEarly) timeoutAbort.abort();
            plugin.afterHandler?.();
            await runMiddlewares(request, afterMiddlewares, plugin);
        }
    } catch (e) {
        request.response = undefined;
        request.error = e;
        try {
            await runMiddlewares(request, onErrorMiddlewares, plugin);
        } catch (e) {
            e.originalError = request.error;
            request.error = e;
            throw request.error;
        }
        if (typeof request.response === 'undefined') throw request.error;
    } finally{
        await plugin.requestEnd?.(request);
    }
    return request.response;
};
const runMiddlewares = async (request, middlewares, plugin)=>{
    for (const nextMiddleware of middlewares){
        plugin.beforeMiddleware?.(nextMiddleware.name);
        const res = await nextMiddleware(request);
        plugin.afterMiddleware?.(nextMiddleware.name);
        if (typeof res !== 'undefined') {
            request.response = res;
            return;
        }
    }
};
const polyfillAbortController = ()=>{
    if (process.version < 'v15.0.0') {
        class AbortSignal {
            toString() {
                return '[object AbortSignal]';
            }
            get [Symbol.toStringTag]() {
                return 'AbortSignal';
            }
            removeEventListener(name, handler) {
                this.eventEmitter.removeListener(name, handler);
            }
            addEventListener(name, handler) {
                this.eventEmitter.on(name, handler);
            }
            dispatchEvent(type) {
                const event = {
                    type,
                    target: this
                };
                const handlerName = `on${type}`;
                if (typeof this[handlerName] === 'function') this[handlerName](event);
                this.eventEmitter.emit(type, event);
            }
            constructor(){
                this.eventEmitter = new _events.EventEmitter();
                this.onabort = null;
                this.aborted = false;
            }
        }
        return class AbortController {
            abort() {
                if (this.signal.aborted) return;
                this.signal.aborted = true;
                this.signal.dispatchEvent('abort');
            }
            toString() {
                return '[object AbortController]';
            }
            get [Symbol.toStringTag]() {
                return 'AbortController';
            }
            constructor(){
                this.signal = new AbortSignal();
            }
        };
    } else {
        return AbortController;
    }
};
global.AbortController = polyfillAbortController();
const polyfillSetTimeoutPromise = ()=>{
    return (ms, { signal  })=>{
        if (signal.aborted) {
            return Promise.reject(new Error('Aborted', 'AbortError'));
        }
        return new Promise((resolve, reject)=>{
            const abortHandler = ()=>{
                clearTimeout(timeout);
                reject(new Error('Aborted', 'AbortError'));
            };
            const timeout = setTimeout(()=>{
                resolve();
                signal.removeEventListener('abort', abortHandler);
            }, ms);
            signal.addEventListener('abort', abortHandler);
        });
    };
};
const setTimeoutPromise = polyfillSetTimeoutPromise();
var _default = middy;
module.exports = _default;


//# sourceMappingURL=index.cjs.map

/***/ }),

/***/ "./node_modules/joi/package.json":
/*!***************************************!*\
  !*** ./node_modules/joi/package.json ***!
  \***************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"joi","description":"Object schema validation","version":"17.6.0","repository":"git://github.com/sideway/joi","main":"lib/index.js","types":"lib/index.d.ts","browser":"dist/joi-browser.min.js","files":["lib/**/*","dist/*"],"keywords":["schema","validation"],"dependencies":{"@hapi/hoek":"^9.0.0","@hapi/topo":"^5.0.0","@sideway/address":"^4.1.3","@sideway/formula":"^3.0.0","@sideway/pinpoint":"^2.0.0"},"devDependencies":{"@hapi/bourne":"2.x.x","@hapi/code":"8.x.x","@hapi/joi-legacy-test":"npm:@hapi/joi@15.x.x","@hapi/lab":"24.x.x","typescript":"4.3.x"},"scripts":{"prepublishOnly":"cd browser && npm install && npm run build","test":"lab -t 100 -a @hapi/code -L -Y","test-cov-html":"lab -r html -o coverage.html -a @hapi/code"},"license":"BSD-3-Clause"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDBEQUFZOzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFlBQVk7O0FBRVoscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHFEQUFxRDtBQUNyRSx3RUFBd0U7QUFDeEUsd0VBQXdFO0FBQ3hFO0FBQ0E7O0FBRUEsZ0RBQWdELGFBQWE7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLGNBQWM7O0FBRWQ7QUFDQTs7O0FBR0EsZUFBZTs7QUFFZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUEsa0JBQWtCOztBQUVsQix1Q0FBdUMsaURBQWlEO0FBQ3hGOzs7QUFHQSxvQkFBb0IscURBQXFEOztBQUV6RSw0Q0FBNEMsNkNBQTZDOztBQUV6Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkJBQTZCLE9BQU87O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixLQUFLLElBQUksNkNBQTZDO0FBQ2hGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLG9DQUFvQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsdUJBQXVCOztBQUV2Qix1Q0FBdUMsc0RBQXNEO0FBQzdGOzs7QUFHQSxpQkFBaUI7O0FBRWpCLHVDQUF1QyxnREFBZ0Q7QUFDdkY7OztBQUdBLGdCQUFnQjs7QUFFaEIsdUNBQXVDLCtDQUErQztBQUN0Rjs7O0FBR0Esd0JBQXdCOztBQUV4Qiw0Q0FBNEMsdURBQXVEOztBQUVuRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLHFCQUFxQjs7QUFFckIsdUNBQXVDLG9EQUFvRDtBQUMzRjs7O0FBR0EseUJBQXlCOztBQUV6Qix1Q0FBdUMsd0RBQXdEO0FBQy9GOzs7QUFHQSxxQkFBcUI7O0FBRXJCLHVDQUF1QyxvREFBb0Q7QUFDM0Y7OztBQUdBLGdCQUFnQjs7QUFFaEIsdUNBQXVDLCtDQUErQztBQUN0Rjs7O0FBR0Esb0JBQW9COztBQUVwQix1Q0FBdUMsbURBQW1EO0FBQzFGOzs7QUFHQSxzQkFBc0I7O0FBRXRCLHVDQUF1QyxxREFBcUQ7QUFDNUY7OztBQUdBLDBCQUEwQjs7QUFFMUIsdUNBQXVDLHlEQUF5RDtBQUNoRzs7O0FBR0Esc0JBQXNCOztBQUV0Qix1Q0FBdUMscURBQXFEO0FBQzVGOzs7QUFHQSxrQkFBa0I7O0FBRWxCLHVDQUF1QyxpREFBaUQ7QUFDeEY7OztBQUdBLDRCQUE0Qjs7QUFFNUIsdUNBQXVDLDJEQUEyRDtBQUNsRzs7O0FBR0EsMkJBQTJCOztBQUUzQix1Q0FBdUMsMERBQTBEO0FBQ2pHOzs7QUFHQSx5QkFBeUI7O0FBRXpCLHVDQUF1Qyx3REFBd0Q7QUFDL0Y7OztBQUdBLGNBQWM7O0FBRWQsdUNBQXVDLDZDQUE2QztBQUNwRjs7O0FBR0EsZUFBZTs7QUFFZix1Q0FBdUMsOENBQThDO0FBQ3JGOzs7QUFHQSxjQUFjOztBQUVkLHVDQUF1Qyw2Q0FBNkM7QUFDcEY7OztBQUdBLHdCQUF3Qjs7QUFFeEIsdUNBQXVDLHVEQUF1RDtBQUM5Rjs7QUFFQSxnQkFBZ0I7O0FBRWhCLHVDQUF1QywrQ0FBK0M7QUFDdEY7OztBQUdBLDRCQUE0Qjs7QUFFNUIsdUNBQXVDLDJEQUEyRDtBQUNsRzs7O0FBR0EsdUJBQXVCOztBQUV2Qix1Q0FBdUMsc0RBQXNEO0FBQzdGOzs7QUFHQSxlQUFlOztBQUVmLHVDQUF1Qyw4Q0FBOEM7QUFDckY7OztBQUdBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBOzs7QUFHQSxrQkFBa0I7O0FBRWxCO0FBQ0E7OztBQUdBLHlCQUF5Qjs7QUFFekI7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBOzs7QUFHQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQSw2Q0FBNkMsK0NBQStDOztBQUU1RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxxQkFBcUI7QUFDNUQ7O0FBRUEsdUNBQXVDLHdCQUF3QjtBQUMvRDs7Ozs7Ozs7Ozs7QUNwZGE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHlEQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx1REFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsdURBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLHVEQUFTOzs7QUFHL0I7OztBQUdBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBOztBQUVBLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvRUFBb0U7QUFDcEU7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxrQ0FBa0M7QUFDbkU7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsa0NBQWtDO0FBQ25FOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckdhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLHVEQUFTOzs7QUFHckM7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUNyQmE7O0FBRWI7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx5REFBVTs7O0FBR2pDOzs7QUFHQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQ1hhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyx1REFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsdURBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLHVEQUFTOzs7QUFHL0I7QUFDQTtBQUNBOzs7QUFHQSw4REFBOEQ7O0FBRTlEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDhGQUE4RjtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0thOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx5REFBVTtBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQywrREFBYTtBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQyxtRUFBZTtBQUMzQyxjQUFjLG1CQUFPLENBQUMsdURBQVM7OztBQUcvQjs7O0FBR0Esb0RBQW9ELFdBQVcsY0FBYzs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLGNBQWM7QUFDMUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0VBQWtFLFNBQVM7QUFDM0U7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FB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QjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7O0FBR0Esa0JBQWtCOzs7QUFHbEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFD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QUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7O1VDNU1BO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7VUV0QkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2Jvb20vbGliL2luZGV4LmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvYXBwbHlUb0RlZmF1bHRzLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvYXNzZXJ0LmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvYmVuY2guanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9ibG9jay5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2Nsb25lLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvY29udGFpbi5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbC5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2Vycm9yLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXNjYXBlSGVhZGVyQXR0cmlidXRlLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXNjYXBlSHRtbC5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2VzY2FwZUpzb24uanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9lc2NhcGVSZWdleC5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9pZ25vcmUuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2ludGVyc2VjdC5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2lzUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL21lcmdlLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvb25jZS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3JlYWNoLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvcmVhY2hUZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3R5cGVzLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi93YWl0LmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGhhcGkvdG9wby9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ac2lkZXdheS9hZGRyZXNzL2xpYi9kb21haW4uanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ac2lkZXdheS9hZGRyZXNzL2xpYi9lbWFpbC5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2FkZHJlc3MvbGliL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2FkZHJlc3MvbGliL2lwLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQHNpZGV3YXkvYWRkcmVzcy9saWIvdGxkcy5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2FkZHJlc3MvbGliL3VyaS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BzaWRld2F5L2Zvcm11bGEvbGliL2luZGV4LmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQHNpZGV3YXkvcGlucG9pbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9hbm5vdGF0ZS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvYmFzZS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvY2FjaGUuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvY29tcGlsZS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvZXJyb3JzLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9leHRlbmQuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL2luZGV4LmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tYW5pZmVzdC5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvbWVzc2FnZXMuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL21vZGlmeS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvcmVmLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9zY2hlbWFzLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9zdGF0ZS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3RyYWNlLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hbHRlcm5hdGl2ZXMuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2FueS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYm9vbGVhbi5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvZGF0ZS5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2tleXMuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2xpbmsuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL251bWJlci5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvb2JqZWN0LmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdmFsaWRhdG9yLmpzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi92YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9hd3Mtc2xzLXRlbXBsYXRlLy4vc3JjL3ZhbGlkYXRpb24udHMiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiZXZlbnRzXCIiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidXJsXCIiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidXRpbFwiIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG1pZGR5L2NvcmUvaW5kZXguY2pzIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vYXdzLXNscy10ZW1wbGF0ZS93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL2F3cy1zbHMtdGVtcGxhdGUvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgY29kZXM6IG5ldyBNYXAoW1xuICAgICAgICBbMTAwLCAnQ29udGludWUnXSxcbiAgICAgICAgWzEwMSwgJ1N3aXRjaGluZyBQcm90b2NvbHMnXSxcbiAgICAgICAgWzEwMiwgJ1Byb2Nlc3NpbmcnXSxcbiAgICAgICAgWzIwMCwgJ09LJ10sXG4gICAgICAgIFsyMDEsICdDcmVhdGVkJ10sXG4gICAgICAgIFsyMDIsICdBY2NlcHRlZCddLFxuICAgICAgICBbMjAzLCAnTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb24nXSxcbiAgICAgICAgWzIwNCwgJ05vIENvbnRlbnQnXSxcbiAgICAgICAgWzIwNSwgJ1Jlc2V0IENvbnRlbnQnXSxcbiAgICAgICAgWzIwNiwgJ1BhcnRpYWwgQ29udGVudCddLFxuICAgICAgICBbMjA3LCAnTXVsdGktU3RhdHVzJ10sXG4gICAgICAgIFszMDAsICdNdWx0aXBsZSBDaG9pY2VzJ10sXG4gICAgICAgIFszMDEsICdNb3ZlZCBQZXJtYW5lbnRseSddLFxuICAgICAgICBbMzAyLCAnTW92ZWQgVGVtcG9yYXJpbHknXSxcbiAgICAgICAgWzMwMywgJ1NlZSBPdGhlciddLFxuICAgICAgICBbMzA0LCAnTm90IE1vZGlmaWVkJ10sXG4gICAgICAgIFszMDUsICdVc2UgUHJveHknXSxcbiAgICAgICAgWzMwNywgJ1RlbXBvcmFyeSBSZWRpcmVjdCddLFxuICAgICAgICBbNDAwLCAnQmFkIFJlcXVlc3QnXSxcbiAgICAgICAgWzQwMSwgJ1VuYXV0aG9yaXplZCddLFxuICAgICAgICBbNDAyLCAnUGF5bWVudCBSZXF1aXJlZCddLFxuICAgICAgICBbNDAzLCAnRm9yYmlkZGVuJ10sXG4gICAgICAgIFs0MDQsICdOb3QgRm91bmQnXSxcbiAgICAgICAgWzQwNSwgJ01ldGhvZCBOb3QgQWxsb3dlZCddLFxuICAgICAgICBbNDA2LCAnTm90IEFjY2VwdGFibGUnXSxcbiAgICAgICAgWzQwNywgJ1Byb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJ10sXG4gICAgICAgIFs0MDgsICdSZXF1ZXN0IFRpbWUtb3V0J10sXG4gICAgICAgIFs0MDksICdDb25mbGljdCddLFxuICAgICAgICBbNDEwLCAnR29uZSddLFxuICAgICAgICBbNDExLCAnTGVuZ3RoIFJlcXVpcmVkJ10sXG4gICAgICAgIFs0MTIsICdQcmVjb25kaXRpb24gRmFpbGVkJ10sXG4gICAgICAgIFs0MTMsICdSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2UnXSxcbiAgICAgICAgWzQxNCwgJ1JlcXVlc3QtVVJJIFRvbyBMYXJnZSddLFxuICAgICAgICBbNDE1LCAnVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZSddLFxuICAgICAgICBbNDE2LCAnUmVxdWVzdGVkIFJhbmdlIE5vdCBTYXRpc2ZpYWJsZSddLFxuICAgICAgICBbNDE3LCAnRXhwZWN0YXRpb24gRmFpbGVkJ10sXG4gICAgICAgIFs0MTgsICdJXFwnbSBhIHRlYXBvdCddLFxuICAgICAgICBbNDIyLCAnVW5wcm9jZXNzYWJsZSBFbnRpdHknXSxcbiAgICAgICAgWzQyMywgJ0xvY2tlZCddLFxuICAgICAgICBbNDI0LCAnRmFpbGVkIERlcGVuZGVuY3knXSxcbiAgICAgICAgWzQyNSwgJ1RvbyBFYXJseSddLFxuICAgICAgICBbNDI2LCAnVXBncmFkZSBSZXF1aXJlZCddLFxuICAgICAgICBbNDI4LCAnUHJlY29uZGl0aW9uIFJlcXVpcmVkJ10sXG4gICAgICAgIFs0MjksICdUb28gTWFueSBSZXF1ZXN0cyddLFxuICAgICAgICBbNDMxLCAnUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZSddLFxuICAgICAgICBbNDUxLCAnVW5hdmFpbGFibGUgRm9yIExlZ2FsIFJlYXNvbnMnXSxcbiAgICAgICAgWzUwMCwgJ0ludGVybmFsIFNlcnZlciBFcnJvciddLFxuICAgICAgICBbNTAxLCAnTm90IEltcGxlbWVudGVkJ10sXG4gICAgICAgIFs1MDIsICdCYWQgR2F0ZXdheSddLFxuICAgICAgICBbNTAzLCAnU2VydmljZSBVbmF2YWlsYWJsZSddLFxuICAgICAgICBbNTA0LCAnR2F0ZXdheSBUaW1lLW91dCddLFxuICAgICAgICBbNTA1LCAnSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWQnXSxcbiAgICAgICAgWzUwNiwgJ1ZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzJ10sXG4gICAgICAgIFs1MDcsICdJbnN1ZmZpY2llbnQgU3RvcmFnZSddLFxuICAgICAgICBbNTA5LCAnQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkJ10sXG4gICAgICAgIFs1MTAsICdOb3QgRXh0ZW5kZWQnXSxcbiAgICAgICAgWzUxMSwgJ05ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWQnXVxuICAgIF0pXG59O1xuXG5cbmV4cG9ydHMuQm9vbSA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuYm9vbWlmeShIb2VrLmNsb25lKG1lc3NhZ2UpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzQ29kZSA9IDUwMCwgZGF0YSA9IG51bGwsIGN0b3IgPSBleHBvcnRzLkJvb20gfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UgPyBtZXNzYWdlIDogdW5kZWZpbmVkKTsgICAgICAgICAvLyBBdm9pZHMgc2V0dGluZ3MgbnVsbCBtZXNzYWdlXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBjdG9yKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIHN0YWNrIHRvIG91ciBleHRlcm5hbCBBUElcbiAgICAgICAgZXJyb3IuZGF0YSA9IGRhdGE7XG4gICAgICAgIGNvbnN0IGJvb20gPSBpbnRlcm5hbHMuaW5pdGlhbGl6ZShlcnJvciwgc3RhdHVzQ29kZSk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJvb20sICd0eXBlb2YnLCB7IHZhbHVlOiBjdG9yIH0pO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmRlY29yYXRlKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGJvb20sIG9wdGlvbnMuZGVjb3JhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvb207XG4gICAgfVxuXG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG5cbiAgICAgICAgaWYgKHRoaXMgPT09IGV4cG9ydHMuQm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNCb29tKGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbm5vdCB1c2UgJ2luc3RhbmNlb2YnIGFzIGl0IGNyZWF0ZXMgaW5maW5pdGUgcmVjdXJzaW9uXG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaW5zdGFuY2UpO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5pc0Jvb20gPSBmdW5jdGlvbiAoZXJyLCBzdGF0dXNDb2RlKSB7XG5cbiAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgISFlcnIuaXNCb29tICYmICghc3RhdHVzQ29kZSB8fCBlcnIub3V0cHV0LnN0YXR1c0NvZGUgPT09IHN0YXR1c0NvZGUpO1xufTtcblxuXG5leHBvcnRzLmJvb21pZnkgPSBmdW5jdGlvbiAoZXJyLCBvcHRpb25zKSB7XG5cbiAgICBIb2VrLmFzc2VydChlcnIgaW5zdGFuY2VvZiBFcnJvciwgJ0Nhbm5vdCB3cmFwIG5vbi1FcnJvciBvYmplY3QnKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVyci5kYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRlY29yYXRlKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXJyLCBvcHRpb25zLmRlY29yYXRlKTtcbiAgICB9XG5cbiAgICBpZiAoIWVyci5pc0Jvb20pIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5pbml0aWFsaXplKGVyciwgb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDUwMCwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5vdmVycmlkZSA9PT0gZmFsc2UgfHwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICFvcHRpb25zLnN0YXR1c0NvZGUgJiYgIW9wdGlvbnMubWVzc2FnZSkge1xuXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5pbml0aWFsaXplKGVyciwgb3B0aW9ucy5zdGF0dXNDb2RlIHx8IGVyci5vdXRwdXQuc3RhdHVzQ29kZSwgb3B0aW9ucy5tZXNzYWdlKTtcbn07XG5cblxuLy8gNHh4IENsaWVudCBFcnJvcnNcblxuZXhwb3J0cy5iYWRSZXF1ZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDAwLCBkYXRhLCBjdG9yOiBleHBvcnRzLmJhZFJlcXVlc3QgfSk7XG59O1xuXG5cbmV4cG9ydHMudW5hdXRob3JpemVkID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNjaGVtZSwgYXR0cmlidXRlcykgeyAgICAgICAgICAvLyBPciAobWVzc2FnZSwgd3d3QXV0aGVudGljYXRlW10pXG5cbiAgICBjb25zdCBlcnIgPSBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDAxLCBjdG9yOiBleHBvcnRzLnVuYXV0aG9yaXplZCB9KTtcblxuICAgIC8vIGZ1bmN0aW9uIChtZXNzYWdlKVxuXG4gICAgaWYgKCFzY2hlbWUpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICAvLyBmdW5jdGlvbiAobWVzc2FnZSwgd3d3QXV0aGVudGljYXRlW10pXG5cbiAgICBpZiAodHlwZW9mIHNjaGVtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyLm91dHB1dC5oZWFkZXJzWydXV1ctQXV0aGVudGljYXRlJ10gPSBzY2hlbWUuam9pbignLCAnKTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICAvLyBmdW5jdGlvbiAobWVzc2FnZSwgc2NoZW1lLCBhdHRyaWJ1dGVzKVxuXG4gICAgbGV0IHd3d0F1dGhlbnRpY2F0ZSA9IGAke3NjaGVtZX1gO1xuXG4gICAgaWYgKGF0dHJpYnV0ZXMgfHxcbiAgICAgICAgbWVzc2FnZSkge1xuXG4gICAgICAgIGVyci5vdXRwdXQucGF5bG9hZC5hdHRyaWJ1dGVzID0ge307XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgd3d3QXV0aGVudGljYXRlICs9ICcgJyArIEhvZWsuZXNjYXBlSGVhZGVyQXR0cmlidXRlKGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgZXJyLm91dHB1dC5wYXlsb2FkLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3d3QXV0aGVudGljYXRlICs9ICcgJyArIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcCgobmFtZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXJyLm91dHB1dC5wYXlsb2FkLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7bmFtZX09XCIke0hvZWsuZXNjYXBlSGVhZGVyQXR0cmlidXRlKHZhbHVlLnRvU3RyaW5nKCkpfVwiYDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgd3d3QXV0aGVudGljYXRlICs9ICcsJztcbiAgICAgICAgfVxuXG4gICAgICAgIHd3d0F1dGhlbnRpY2F0ZSArPSBgIGVycm9yPVwiJHtIb2VrLmVzY2FwZUhlYWRlckF0dHJpYnV0ZShtZXNzYWdlKX1cImA7XG4gICAgICAgIGVyci5vdXRwdXQucGF5bG9hZC5hdHRyaWJ1dGVzLmVycm9yID0gbWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVyci5pc01pc3NpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGVyci5vdXRwdXQuaGVhZGVyc1snV1dXLUF1dGhlbnRpY2F0ZSddID0gd3d3QXV0aGVudGljYXRlO1xuICAgIHJldHVybiBlcnI7XG59O1xuXG5cbmV4cG9ydHMucGF5bWVudFJlcXVpcmVkID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDAyLCBkYXRhLCBjdG9yOiBleHBvcnRzLnBheW1lbnRSZXF1aXJlZCB9KTtcbn07XG5cblxuZXhwb3J0cy5mb3JiaWRkZW4gPSBmdW5jdGlvbiAobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDMsIGRhdGEsIGN0b3I6IGV4cG9ydHMuZm9yYmlkZGVuIH0pO1xufTtcblxuXG5leHBvcnRzLm5vdEZvdW5kID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDA0LCBkYXRhLCBjdG9yOiBleHBvcnRzLm5vdEZvdW5kIH0pO1xufTtcblxuXG5leHBvcnRzLm1ldGhvZE5vdEFsbG93ZWQgPSBmdW5jdGlvbiAobWVzc2FnZSwgZGF0YSwgYWxsb3cpIHtcblxuICAgIGNvbnN0IGVyciA9IG5ldyBleHBvcnRzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDUsIGRhdGEsIGN0b3I6IGV4cG9ydHMubWV0aG9kTm90QWxsb3dlZCB9KTtcblxuICAgIGlmICh0eXBlb2YgYWxsb3cgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFsbG93ID0gW2FsbG93XTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhbGxvdykpIHtcbiAgICAgICAgZXJyLm91dHB1dC5oZWFkZXJzLkFsbG93ID0gYWxsb3cuam9pbignLCAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyO1xufTtcblxuXG5leHBvcnRzLm5vdEFjY2VwdGFibGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDYsIGRhdGEsIGN0b3I6IGV4cG9ydHMubm90QWNjZXB0YWJsZSB9KTtcbn07XG5cblxuZXhwb3J0cy5wcm94eUF1dGhSZXF1aXJlZCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQwNywgZGF0YSwgY3RvcjogZXhwb3J0cy5wcm94eUF1dGhSZXF1aXJlZCB9KTtcbn07XG5cblxuZXhwb3J0cy5jbGllbnRUaW1lb3V0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDA4LCBkYXRhLCBjdG9yOiBleHBvcnRzLmNsaWVudFRpbWVvdXQgfSk7XG59O1xuXG5cbmV4cG9ydHMuY29uZmxpY3QgPSBmdW5jdGlvbiAobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDksIGRhdGEsIGN0b3I6IGV4cG9ydHMuY29uZmxpY3QgfSk7XG59O1xuXG5cbmV4cG9ydHMucmVzb3VyY2VHb25lID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDEwLCBkYXRhLCBjdG9yOiBleHBvcnRzLnJlc291cmNlR29uZSB9KTtcbn07XG5cblxuZXhwb3J0cy5sZW5ndGhSZXF1aXJlZCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQxMSwgZGF0YSwgY3RvcjogZXhwb3J0cy5sZW5ndGhSZXF1aXJlZCB9KTtcbn07XG5cblxuZXhwb3J0cy5wcmVjb25kaXRpb25GYWlsZWQgPSBmdW5jdGlvbiAobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MTIsIGRhdGEsIGN0b3I6IGV4cG9ydHMucHJlY29uZGl0aW9uRmFpbGVkIH0pO1xufTtcblxuXG5leHBvcnRzLmVudGl0eVRvb0xhcmdlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDEzLCBkYXRhLCBjdG9yOiBleHBvcnRzLmVudGl0eVRvb0xhcmdlIH0pO1xufTtcblxuXG5leHBvcnRzLnVyaVRvb0xvbmcgPSBmdW5jdGlvbiAobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MTQsIGRhdGEsIGN0b3I6IGV4cG9ydHMudXJpVG9vTG9uZyB9KTtcbn07XG5cblxuZXhwb3J0cy51bnN1cHBvcnRlZE1lZGlhVHlwZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQxNSwgZGF0YSwgY3RvcjogZXhwb3J0cy51bnN1cHBvcnRlZE1lZGlhVHlwZSB9KTtcbn07XG5cblxuZXhwb3J0cy5yYW5nZU5vdFNhdGlzZmlhYmxlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDE2LCBkYXRhLCBjdG9yOiBleHBvcnRzLnJhbmdlTm90U2F0aXNmaWFibGUgfSk7XG59O1xuXG5cbmV4cG9ydHMuZXhwZWN0YXRpb25GYWlsZWQgPSBmdW5jdGlvbiAobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MTcsIGRhdGEsIGN0b3I6IGV4cG9ydHMuZXhwZWN0YXRpb25GYWlsZWQgfSk7XG59O1xuXG5cbmV4cG9ydHMudGVhcG90ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDE4LCBkYXRhLCBjdG9yOiBleHBvcnRzLnRlYXBvdCB9KTtcbn07XG5cblxuZXhwb3J0cy5iYWREYXRhID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDIyLCBkYXRhLCBjdG9yOiBleHBvcnRzLmJhZERhdGEgfSk7XG59O1xuXG5cbmV4cG9ydHMubG9ja2VkID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDIzLCBkYXRhLCBjdG9yOiBleHBvcnRzLmxvY2tlZCB9KTtcbn07XG5cblxuZXhwb3J0cy5mYWlsZWREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDI0LCBkYXRhLCBjdG9yOiBleHBvcnRzLmZhaWxlZERlcGVuZGVuY3kgfSk7XG59O1xuXG5leHBvcnRzLnRvb0Vhcmx5ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDI1LCBkYXRhLCBjdG9yOiBleHBvcnRzLnRvb0Vhcmx5IH0pO1xufTtcblxuXG5leHBvcnRzLnByZWNvbmRpdGlvblJlcXVpcmVkID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDI4LCBkYXRhLCBjdG9yOiBleHBvcnRzLnByZWNvbmRpdGlvblJlcXVpcmVkIH0pO1xufTtcblxuXG5leHBvcnRzLnRvb01hbnlSZXF1ZXN0cyA9IGZ1bmN0aW9uIChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQyOSwgZGF0YSwgY3RvcjogZXhwb3J0cy50b29NYW55UmVxdWVzdHMgfSk7XG59O1xuXG5cbmV4cG9ydHMuaWxsZWdhbCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQ1MSwgZGF0YSwgY3RvcjogZXhwb3J0cy5pbGxlZ2FsIH0pO1xufTtcblxuXG4vLyA1eHggU2VydmVyIEVycm9yc1xuXG5leHBvcnRzLmludGVybmFsID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEsIHN0YXR1c0NvZGUgPSA1MDApIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuc2VydmVyRXJyb3IobWVzc2FnZSwgZGF0YSwgc3RhdHVzQ29kZSwgZXhwb3J0cy5pbnRlcm5hbCk7XG59O1xuXG5cbmV4cG9ydHMubm90SW1wbGVtZW50ZWQgPSBmdW5jdGlvbiAobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5zZXJ2ZXJFcnJvcihtZXNzYWdlLCBkYXRhLCA1MDEsIGV4cG9ydHMubm90SW1wbGVtZW50ZWQpO1xufTtcblxuXG5leHBvcnRzLmJhZEdhdGV3YXkgPSBmdW5jdGlvbiAobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5zZXJ2ZXJFcnJvcihtZXNzYWdlLCBkYXRhLCA1MDIsIGV4cG9ydHMuYmFkR2F0ZXdheSk7XG59O1xuXG5cbmV4cG9ydHMuc2VydmVyVW5hdmFpbGFibGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5zZXJ2ZXJFcnJvcihtZXNzYWdlLCBkYXRhLCA1MDMsIGV4cG9ydHMuc2VydmVyVW5hdmFpbGFibGUpO1xufTtcblxuXG5leHBvcnRzLmdhdGV3YXlUaW1lb3V0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuc2VydmVyRXJyb3IobWVzc2FnZSwgZGF0YSwgNTA0LCBleHBvcnRzLmdhdGV3YXlUaW1lb3V0KTtcbn07XG5cblxuZXhwb3J0cy5iYWRJbXBsZW1lbnRhdGlvbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICBjb25zdCBlcnIgPSBpbnRlcm5hbHMuc2VydmVyRXJyb3IobWVzc2FnZSwgZGF0YSwgNTAwLCBleHBvcnRzLmJhZEltcGxlbWVudGF0aW9uKTtcbiAgICBlcnIuaXNEZXZlbG9wZXJFcnJvciA9IHRydWU7XG4gICAgcmV0dXJuIGVycjtcbn07XG5cblxuaW50ZXJuYWxzLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoZXJyLCBzdGF0dXNDb2RlLCBtZXNzYWdlKSB7XG5cbiAgICBjb25zdCBudW1iZXJDb2RlID0gcGFyc2VJbnQoc3RhdHVzQ29kZSwgMTApO1xuICAgIEhvZWsuYXNzZXJ0KCFpc05hTihudW1iZXJDb2RlKSAmJiBudW1iZXJDb2RlID49IDQwMCwgJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIgKDQwMCspOicsIHN0YXR1c0NvZGUpO1xuXG4gICAgZXJyLmlzQm9vbSA9IHRydWU7XG4gICAgZXJyLmlzU2VydmVyID0gbnVtYmVyQ29kZSA+PSA1MDA7XG5cbiAgICBpZiAoIWVyci5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpKSB7XG4gICAgICAgIGVyci5kYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBlcnIub3V0cHV0ID0ge1xuICAgICAgICBzdGF0dXNDb2RlOiBudW1iZXJDb2RlLFxuICAgICAgICBwYXlsb2FkOiB7fSxcbiAgICAgICAgaGVhZGVyczoge31cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ3JlZm9ybWF0JywgeyB2YWx1ZTogaW50ZXJuYWxzLnJlZm9ybWF0LCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cbiAgICBpZiAoIW1lc3NhZ2UgJiZcbiAgICAgICAgIWVyci5tZXNzYWdlKSB7XG5cbiAgICAgICAgZXJyLnJlZm9ybWF0KCk7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnIub3V0cHV0LnBheWxvYWQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGVyciwgJ21lc3NhZ2UnKSB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5nZXRQcm90b3R5cGVPZihlcnIpLCAnbWVzc2FnZScpO1xuICAgICAgICBIb2VrLmFzc2VydCghcHJvcHMgfHwgcHJvcHMuY29uZmlndXJhYmxlICYmICFwcm9wcy5nZXQsICdUaGUgZXJyb3IgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBib29tJyk7XG5cbiAgICAgICAgZXJyLm1lc3NhZ2UgPSBtZXNzYWdlICsgKGVyci5tZXNzYWdlID8gJzogJyArIGVyci5tZXNzYWdlIDogJycpO1xuICAgICAgICBlcnIub3V0cHV0LnBheWxvYWQubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cblxuICAgIGVyci5yZWZvcm1hdCgpO1xuICAgIHJldHVybiBlcnI7XG59O1xuXG5cbmludGVybmFscy5yZWZvcm1hdCA9IGZ1bmN0aW9uIChkZWJ1ZyA9IGZhbHNlKSB7XG5cbiAgICB0aGlzLm91dHB1dC5wYXlsb2FkLnN0YXR1c0NvZGUgPSB0aGlzLm91dHB1dC5zdGF0dXNDb2RlO1xuICAgIHRoaXMub3V0cHV0LnBheWxvYWQuZXJyb3IgPSBpbnRlcm5hbHMuY29kZXMuZ2V0KHRoaXMub3V0cHV0LnN0YXR1c0NvZGUpIHx8ICdVbmtub3duJztcblxuICAgIGlmICh0aGlzLm91dHB1dC5zdGF0dXNDb2RlID09PSA1MDAgJiYgZGVidWcgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQucGF5bG9hZC5tZXNzYWdlID0gJ0FuIGludGVybmFsIHNlcnZlciBlcnJvciBvY2N1cnJlZCc7ICAgICAgICAgICAgICAvLyBIaWRlIGFjdHVhbCBlcnJvciBmcm9tIHVzZXJcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgICAgIHRoaXMub3V0cHV0LnBheWxvYWQubWVzc2FnZSA9IHRoaXMubWVzc2FnZTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zZXJ2ZXJFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBkYXRhLCBzdGF0dXNDb2RlLCBjdG9yKSB7XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICFkYXRhLmlzQm9vbSkge1xuXG4gICAgICAgIHJldHVybiBleHBvcnRzLmJvb21pZnkoZGF0YSwgeyBzdGF0dXNDb2RlLCBtZXNzYWdlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZSwgZGF0YSwgY3RvciB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUnKTtcbmNvbnN0IE1lcmdlID0gcmVxdWlyZSgnLi9tZXJnZScpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCcuL3JlYWNoJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVmYXVsdHMsIHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBBc3NlcnQoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzID09PSAnb2JqZWN0JywgJ0ludmFsaWQgZGVmYXVsdHMgdmFsdWU6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgQXNzZXJ0KCFzb3VyY2UgfHwgc291cmNlID09PSB0cnVlIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzb3VyY2UgdmFsdWU6IG11c3QgYmUgdHJ1ZSwgZmFsc3kgb3IgYW4gb2JqZWN0Jyk7XG4gICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9uczogbXVzdCBiZSBhbiBvYmplY3QnKTtcblxuICAgIGlmICghc291cmNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBzb3VyY2UsIHJldHVybiBudWxsXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hcHBseVRvRGVmYXVsdHNXaXRoU2hhbGxvdyhkZWZhdWx0cywgc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb3B5ID0gQ2xvbmUoZGVmYXVsdHMpO1xuXG4gICAgaWYgKHNvdXJjZSA9PT0gdHJ1ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNvdXJjZSBpcyBzZXQgdG8gdHJ1ZSwgdXNlIGRlZmF1bHRzXG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIGNvbnN0IG51bGxPdmVycmlkZSA9IG9wdGlvbnMubnVsbE92ZXJyaWRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm51bGxPdmVycmlkZSA6IGZhbHNlO1xuICAgIHJldHVybiBNZXJnZShjb3B5LCBzb3VyY2UsIHsgbnVsbE92ZXJyaWRlLCBtZXJnZUFycmF5czogZmFsc2UgfSk7XG59O1xuXG5cbmludGVybmFscy5hcHBseVRvRGVmYXVsdHNXaXRoU2hhbGxvdyA9IGZ1bmN0aW9uIChkZWZhdWx0cywgc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBrZXlzID0gb3B0aW9ucy5zaGFsbG93O1xuICAgIEFzc2VydChBcnJheS5pc0FycmF5KGtleXMpLCAnSW52YWxpZCBrZXlzJyk7XG5cbiAgICBjb25zdCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG1lcmdlID0gc291cmNlID09PSB0cnVlID8gbnVsbCA6IG5ldyBTZXQoKTtcblxuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGtleSA9IEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleSA6IGtleS5zcGxpdCgnLicpOyAgICAgICAgICAgIC8vIFByZS1zcGxpdCBvcHRpbWl6YXRpb25cblxuICAgICAgICBjb25zdCByZWYgPSBSZWFjaChkZWZhdWx0cywga2V5KTtcbiAgICAgICAgaWYgKHJlZiAmJlxuICAgICAgICAgICAgdHlwZW9mIHJlZiA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgc2Vlbi5zZXQocmVmLCBtZXJnZSAmJiBSZWFjaChzb3VyY2UsIGtleSkgfHwgcmVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgbWVyZ2UuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjb3B5ID0gQ2xvbmUoZGVmYXVsdHMsIHt9LCBzZWVuKTtcblxuICAgIGlmICghbWVyZ2UpIHtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgbWVyZ2UpIHtcbiAgICAgICAgaW50ZXJuYWxzLnJlYWNoQ29weShjb3B5LCBzb3VyY2UsIGtleSk7XG4gICAgfVxuXG4gICAgY29uc3QgbnVsbE92ZXJyaWRlID0gb3B0aW9ucy5udWxsT3ZlcnJpZGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnVsbE92ZXJyaWRlIDogZmFsc2U7XG4gICAgcmV0dXJuIE1lcmdlKGNvcHksIHNvdXJjZSwgeyBudWxsT3ZlcnJpZGUsIG1lcmdlQXJyYXlzOiBmYWxzZSB9KTtcbn07XG5cblxuaW50ZXJuYWxzLnJlYWNoQ29weSA9IGZ1bmN0aW9uIChkc3QsIHNyYywgcGF0aCkge1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKCEoc2VnbWVudCBpbiBzcmMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWwgPSBzcmNbc2VnbWVudF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3JjID0gdmFsO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gc3JjO1xuICAgIGxldCByZWYgPSBkc3Q7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gcGF0aFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZbc2VnbWVudF0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZWZbc2VnbWVudF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZiA9IHJlZltzZWdtZW50XTtcbiAgICB9XG5cbiAgICByZWZbcGF0aFtwYXRoLmxlbmd0aCAtIDFdXSA9IHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0RXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCAuLi5hcmdzKSB7XG5cbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgYXJnc1swXSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cbiAgICAgICAgdGhyb3cgYXJnc1swXTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgQXNzZXJ0RXJyb3IoYXJncyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5CZW5jaCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMudHMgPSAwO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG5cbiAgICAgICAgdGhpcy50cyA9IGludGVybmFscy5CZW5jaC5ub3coKTtcbiAgICB9XG5cbiAgICBlbGFwc2VkKCkge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuQmVuY2gubm93KCkgLSB0aGlzLnRzO1xuICAgIH1cblxuICAgIHN0YXRpYyBub3coKSB7XG5cbiAgICAgICAgY29uc3QgdHMgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgICAgICByZXR1cm4gKHRzWzBdICogMWUzKSArICh0c1sxXSAvIDFlNik7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSWdub3JlID0gcmVxdWlyZSgnLi9pZ25vcmUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShJZ25vcmUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUmVhY2ggPSByZXF1aXJlKCcuL3JlYWNoJyk7XG5jb25zdCBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBuZWVkc1Byb3RvSGFjazogbmV3IFNldChbVHlwZXMuc2V0LCBUeXBlcy5tYXAsIFR5cGVzLndlYWtTZXQsIFR5cGVzLndlYWtNYXBdKVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5jbG9uZSA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMgPSB7fSwgX3NlZW4gPSBudWxsKSB7XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgb2JqID09PSBudWxsKSB7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBsZXQgY2xvbmUgPSBpbnRlcm5hbHMuY2xvbmU7XG4gICAgbGV0IHNlZW4gPSBfc2VlbjtcblxuICAgIGlmIChvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hhbGxvdyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5jbG9uZVdpdGhTaGFsbG93KG9iaiwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9uZSA9ICh2YWx1ZSkgPT4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlZW4pIHtcbiAgICAgICAgY29uc3QgbG9va3VwID0gc2Vlbi5nZXQob2JqKTtcbiAgICAgICAgaWYgKGxvb2t1cCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsdC1pbiBvYmplY3QgdHlwZXNcblxuICAgIGNvbnN0IGJhc2VQcm90byA9IFR5cGVzLmdldEludGVybmFsUHJvdG8ob2JqKTtcbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5idWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlciAmJiBCdWZmZXIuZnJvbShvYmopOyAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgfVxuXG4gICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuZGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqLmdldFRpbWUoKSk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMucmVnZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAob2JqKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmljIG9iamVjdHNcblxuICAgIGNvbnN0IG5ld09iaiA9IGludGVybmFscy5iYXNlKG9iaiwgYmFzZVByb3RvLCBvcHRpb25zKTtcbiAgICBpZiAobmV3T2JqID09PSBvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgICBzZWVuLnNldChvYmosIG5ld09iaik7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHNlZW4sIHNpbmNlIG9iaiBjb3VsZCByZWN1cnNlXG4gICAgfVxuXG4gICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuc2V0KSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqKSB7XG4gICAgICAgICAgICBuZXdPYmouYWRkKGNsb25lKHZhbHVlLCBvcHRpb25zLCBzZWVuKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5tYXApIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqKSB7XG4gICAgICAgICAgICBuZXdPYmouc2V0KGtleSwgY2xvbmUodmFsdWUsIG9wdGlvbnMsIHNlZW4pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBVdGlscy5rZXlzKG9iaiwgb3B0aW9ucyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5hcnJheSAmJlxuICAgICAgICAgICAga2V5ID09PSAnbGVuZ3RoJykge1xuXG4gICAgICAgICAgICBuZXdPYmoubGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0IHx8XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQpIHtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZXNjcmlwdG9yLmVudW1lcmFibGUpIHtcbiAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IGNsb25lKG9ialtrZXldLCBvcHRpb25zLCBzZWVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IGNsb25lKG9ialtrZXldLCBvcHRpb25zLCBzZWVuKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjbG9uZShvYmpba2V5XSwgb3B0aW9ucywgc2VlbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iajtcbn07XG5cblxuaW50ZXJuYWxzLmNsb25lV2l0aFNoYWxsb3cgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBrZXlzID0gb3B0aW9ucy5zaGFsbG93O1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBvcHRpb25zLnNoYWxsb3cgPSBmYWxzZTtcblxuICAgIGNvbnN0IHNlZW4gPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IFJlYWNoKHNvdXJjZSwga2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAgIHNlZW4uc2V0KHJlZiwgcmVmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMuY2xvbmUoc291cmNlLCBvcHRpb25zLCBzZWVuKTtcbn07XG5cblxuaW50ZXJuYWxzLmJhc2UgPSBmdW5jdGlvbiAob2JqLCBiYXNlUHJvdG8sIG9wdGlvbnMpIHtcblxuICAgIGlmIChvcHRpb25zLnByb3RvdHlwZSA9PT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgIGlmIChpbnRlcm5hbHMubmVlZHNQcm90b0hhY2suaGFzKGJhc2VQcm90bykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYmFzZVByb3RvLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmFzZVByb3RvID09PSBUeXBlcy5hcnJheSA/IFtdIDoge307XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICBpZiAocHJvdG8gJiZcbiAgICAgICAgcHJvdG8uaXNJbW11dGFibGUpIHtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLmFycmF5KSB7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IFtdO1xuICAgICAgICBpZiAocHJvdG8gIT09IGJhc2VQcm90bykge1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld09iaiwgcHJvdG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxzLm5lZWRzUHJvdG9IYWNrLmhhcyhiYXNlUHJvdG8pKSB7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IG5ldyBwcm90by5jb25zdHJ1Y3RvcigpO1xuICAgICAgICBpZiAocHJvdG8gIT09IGJhc2VQcm90bykge1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld09iaiwgcHJvdG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShwcm90byk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnLi9kZWVwRXF1YWwnKTtcbmNvbnN0IEVzY2FwZVJlZ2V4ID0gcmVxdWlyZSgnLi9lc2NhcGVSZWdleCcpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVmLCB2YWx1ZXMsIG9wdGlvbnMgPSB7fSkgeyAgICAgICAgLy8gb3B0aW9uczogeyBkZWVwLCBvbmNlLCBvbmx5LCBwYXJ0LCBzeW1ib2xzIH1cblxuICAgIC8qXG4gICAgICAgIHN0cmluZyAtPiBzdHJpbmcocylcbiAgICAgICAgYXJyYXkgLT4gaXRlbShzKVxuICAgICAgICBvYmplY3QgLT4ga2V5KHMpXG4gICAgICAgIG9iamVjdCAtPiBvYmplY3QgKGtleTp2YWx1ZSlcbiAgICAqL1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgIH1cblxuICAgIEFzc2VydCghQXJyYXkuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGgsICdWYWx1ZXMgYXJyYXkgY2Fubm90IGJlIGVtcHR5Jyk7XG5cbiAgICAvLyBTdHJpbmdcblxuICAgIGlmICh0eXBlb2YgcmVmID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnN0cmluZyhyZWYsIHZhbHVlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gQXJyYXlcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZikpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hcnJheShyZWYsIHZhbHVlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0XG5cbiAgICBBc3NlcnQodHlwZW9mIHJlZiA9PT0gJ29iamVjdCcsICdSZWZlcmVuY2UgbXVzdCBiZSBzdHJpbmcgb3IgYW4gb2JqZWN0Jyk7XG4gICAgcmV0dXJuIGludGVybmFscy5vYmplY3QocmVmLCB2YWx1ZXMsIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMuYXJyYXkgPSBmdW5jdGlvbiAocmVmLCB2YWx1ZXMsIG9wdGlvbnMpIHtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgIH1cblxuICAgIGlmICghcmVmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMub25seSAmJlxuICAgICAgICBvcHRpb25zLm9uY2UgJiZcbiAgICAgICAgcmVmLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY29tcGFyZTtcblxuICAgIC8vIE1hcCB2YWx1ZXNcblxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuZGVlcCB8fFxuICAgICAgICAgICAgIXZhbHVlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gbWFwLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICArK2V4aXN0aW5nLmFsbG93ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KHZhbHVlLCB7IGFsbG93ZWQ6IDEsIGhpdHM6IDAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21wYXJlID0gY29tcGFyZSB8fCBpbnRlcm5hbHMuY29tcGFyZShvcHRpb25zKTtcblxuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGV4aXN0aW5nXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKytleGlzdGluZy5hbGxvd2VkO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQodmFsdWUsIHsgYWxsb3dlZDogMSwgaGl0czogMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIExvb2t1cCB2YWx1ZXNcblxuICAgIGxldCBoaXRzID0gMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVmKSB7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgaWYgKCFvcHRpb25zLmRlZXAgfHxcbiAgICAgICAgICAgICFpdGVtIHx8XG4gICAgICAgICAgICB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgbWF0Y2ggPSBtYXAuZ2V0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcGFyZSA9IGNvbXBhcmUgfHwgaW50ZXJuYWxzLmNvbXBhcmUob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgZXhpc3RpbmddIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShrZXksIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZXhpc3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgKyttYXRjaC5oaXRzO1xuICAgICAgICAgICAgKytoaXRzO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmNlICYmXG4gICAgICAgICAgICAgICAgbWF0Y2guaGl0cyA+IG1hdGNoLmFsbG93ZWQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHJlc3VsdHNcblxuICAgIGlmIChvcHRpb25zLm9ubHkgJiZcbiAgICAgICAgaGl0cyAhPT0gcmVmLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hcC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAobWF0Y2guaGl0cyA9PT0gbWF0Y2guYWxsb3dlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2guaGl0cyA8IG1hdGNoLmFsbG93ZWQgJiZcbiAgICAgICAgICAgICFvcHRpb25zLnBhcnQpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICEhaGl0cztcbn07XG5cblxuaW50ZXJuYWxzLm9iamVjdCA9IGZ1bmN0aW9uIChyZWYsIHZhbHVlcywgb3B0aW9ucykge1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMub25jZSA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHVzZSBvcHRpb24gb25jZSB3aXRoIG9iamVjdCcpO1xuXG4gICAgY29uc3Qga2V5cyA9IFV0aWxzLmtleXMocmVmLCBvcHRpb25zKTtcbiAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBLZXlzIGxpc3RcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hcnJheShrZXlzLCB2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIEtleSB2YWx1ZSBwYWlyc1xuXG4gICAgY29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWVzKS5maWx0ZXIoKHN5bSkgPT4gdmFsdWVzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHN5bSkpO1xuICAgIGNvbnN0IHRhcmdldHMgPSBbLi4uT2JqZWN0LmtleXModmFsdWVzKSwgLi4uc3ltYm9sc107XG5cbiAgICBjb25zdCBjb21wYXJlID0gaW50ZXJuYWxzLmNvbXBhcmUob3B0aW9ucyk7XG4gICAgY29uc3Qgc2V0ID0gbmV3IFNldCh0YXJnZXRzKTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFzZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb21wYXJlKHZhbHVlc1trZXldLCByZWZba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldC5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICBpZiAoc2V0LnNpemUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGFydCA/IHNldC5zaXplIDwgdGFyZ2V0cy5sZW5ndGggOiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuaW50ZXJuYWxzLnN0cmluZyA9IGZ1bmN0aW9uIChyZWYsIHZhbHVlcywgb3B0aW9ucykge1xuXG4gICAgLy8gRW1wdHkgc3RyaW5nXG5cbiAgICBpZiAocmVmID09PSAnJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZXNbMF0gPT09ICcnIHx8ICAgICAgICAgICAgICAgLy8gJycgY29udGFpbnMgJydcbiAgICAgICAgICAgICFvcHRpb25zLm9uY2UgJiYgIXZhbHVlcy5zb21lKCh2KSA9PiB2ICE9PSAnJyk7ICAgICAgICAgICAgIC8vICcnIGNvbnRhaW5zIG11bHRpcGxlICcnIGlmICFvbmNlXG4gICAgfVxuXG4gICAgLy8gTWFwIHZhbHVlc1xuXG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHBhdHRlcm5zID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICBBc3NlcnQodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ0Nhbm5vdCBjb21wYXJlIHN0cmluZyByZWZlcmVuY2UgdG8gbm9uLXN0cmluZyB2YWx1ZScpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBtYXAuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgICAgICsrZXhpc3RpbmcuYWxsb3dlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQodmFsdWUsIHsgYWxsb3dlZDogMSwgaGl0czogMCB9KTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJucy5wdXNoKEVzY2FwZVJlZ2V4KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vbmNlIHx8XG4gICAgICAgICAgICBvcHRpb25zLm9ubHkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXR0ZXJucy5sZW5ndGgpIHsgICAgICAgICAgICAgICAgICAgICAvLyBOb24tZW1wdHkgc3RyaW5nIGNvbnRhaW5zIHVubGltaXRlZCBlbXB0eSBzdHJpbmdcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTWF0Y2ggcGF0dGVybnNcblxuICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgKCR7cGF0dGVybnMuam9pbignfCcpfSlgLCAnZycpO1xuICAgIGNvbnN0IGxlZnRvdmVycyA9IHJlZi5yZXBsYWNlKHJlZ2V4LCAoJDAsICQxKSA9PiB7XG5cbiAgICAgICAgKyttYXAuZ2V0KCQxKS5oaXRzO1xuICAgICAgICByZXR1cm4gJyc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gc3RyaW5nXG4gICAgfSk7XG5cbiAgICAvLyBWYWxpZGF0ZSByZXN1bHRzXG5cbiAgICBpZiAob3B0aW9ucy5vbmx5ICYmXG4gICAgICAgIGxlZnRvdmVycykge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgYW55ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKG1hdGNoLmhpdHMpIHtcbiAgICAgICAgICAgIGFueSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2guaGl0cyA9PT0gbWF0Y2guYWxsb3dlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2guaGl0cyA8IG1hdGNoLmFsbG93ZWQgJiZcbiAgICAgICAgICAgICFvcHRpb25zLnBhcnQpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWF0Y2guaGl0cyA+IG1hdGNoLmFsbG93ZWRcblxuICAgICAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gISFhbnk7XG59O1xuXG5cbmludGVybmFscy5jb21wYXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGlmICghb3B0aW9ucy5kZWVwKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuc2hhbGxvdztcbiAgICB9XG5cbiAgICBjb25zdCBoYXNPbmx5ID0gb3B0aW9ucy5vbmx5ICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaGFzUGFydCA9IG9wdGlvbnMucGFydCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgZmxhZ3MgPSB7XG4gICAgICAgIHByb3RvdHlwZTogaGFzT25seSA/IG9wdGlvbnMub25seSA6IGhhc1BhcnQgPyAhb3B0aW9ucy5wYXJ0IDogZmFsc2UsXG4gICAgICAgIHBhcnQ6IGhhc09ubHkgPyAhb3B0aW9ucy5vbmx5IDogaGFzUGFydCA/IG9wdGlvbnMucGFydCA6IGZhbHNlXG4gICAgfTtcblxuICAgIHJldHVybiAoYSwgYikgPT4gRGVlcEVxdWFsKGEsIGIsIGZsYWdzKTtcbn07XG5cblxuaW50ZXJuYWxzLnNoYWxsb3cgPSBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcmV0dXJuIGEgPT09IGI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbWlzbWF0Y2hlZDogbnVsbFxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIHJlZiwgb3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBwcm90b3R5cGU6IHRydWUgfSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gISFpbnRlcm5hbHMuaXNEZWVwRXF1YWwob2JqLCByZWYsIG9wdGlvbnMsIFtdKTtcbn07XG5cblxuaW50ZXJuYWxzLmlzRGVlcEVxdWFsID0gZnVuY3Rpb24gKG9iaiwgcmVmLCBvcHRpb25zLCBzZWVuKSB7XG5cbiAgICBpZiAob2JqID09PSByZWYpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3BpZWQgZnJvbSBEZWVwLWVxbCwgY29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyLCBqYWtlQGFsb2dpY2FscGFyYWRveC5jb20sIE1JVCBMaWNlbnNlZCwgaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbFxuICAgICAgICByZXR1cm4gb2JqICE9PSAwIHx8IDEgLyBvYmogPT09IDEgLyByZWY7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBvYmo7XG5cbiAgICBpZiAodHlwZSAhPT0gdHlwZW9mIHJlZikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fFxuICAgICAgICByZWYgPT09IG51bGwpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmRlZXBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgb2JqLnRvU3RyaW5nKCkgIT09IHJlZi50b1N0cmluZygpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnRpbnVlIGFzIG9iamVjdFxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gb2JqICE9PSBvYmogJiYgcmVmICE9PSByZWY7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5hTlxuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlVHlwZSA9IGludGVybmFscy5nZXRTaGFyZWRUeXBlKG9iaiwgcmVmLCAhIW9wdGlvbnMucHJvdG90eXBlKTtcbiAgICBzd2l0Y2ggKGluc3RhbmNlVHlwZSkge1xuICAgICAgICBjYXNlIFR5cGVzLmJ1ZmZlcjpcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIgJiYgQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMuY2FsbChvYmosIHJlZik7ICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgY2FzZSBUeXBlcy5wcm9taXNlOlxuICAgICAgICAgICAgcmV0dXJuIG9iaiA9PT0gcmVmO1xuICAgICAgICBjYXNlIFR5cGVzLnJlZ2V4OlxuICAgICAgICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpID09PSByZWYudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBpbnRlcm5hbHMubWlzbWF0Y2hlZDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gc2Vlbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoc2VlbltpXS5pc1NhbWUob2JqLCByZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJldmlvdXMgY29tcGFyaXNvbiBmYWlsZWQsIGl0IHdvdWxkIGhhdmUgc3RvcHBlZCBleGVjdXRpb25cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlZW4ucHVzaChuZXcgaW50ZXJuYWxzLlNlZW5FbnRyeShvYmosIHJlZikpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICEhaW50ZXJuYWxzLmlzRGVlcEVxdWFsT2JqKGluc3RhbmNlVHlwZSwgb2JqLCByZWYsIG9wdGlvbnMsIHNlZW4pO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgc2Vlbi5wb3AoKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5nZXRTaGFyZWRUeXBlID0gZnVuY3Rpb24gKG9iaiwgcmVmLCBjaGVja1Byb3RvdHlwZSkge1xuXG4gICAgaWYgKGNoZWNrUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMubWlzbWF0Y2hlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBUeXBlcy5nZXRJbnRlcm5hbFByb3RvKG9iaik7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IFR5cGVzLmdldEludGVybmFsUHJvdG8ob2JqKTtcbiAgICBpZiAodHlwZSAhPT0gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhyZWYpKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMubWlzbWF0Y2hlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbn07XG5cblxuaW50ZXJuYWxzLnZhbHVlT2YgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICBjb25zdCBvYmpWYWx1ZU9mID0gb2JqLnZhbHVlT2Y7XG4gICAgaWYgKG9ialZhbHVlT2YgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvYmpWYWx1ZU9mLmNhbGwob2JqKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmhhc093bkVudW1lcmFibGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIGtleSk7XG59O1xuXG5cbmludGVybmFscy5pc1NldFNpbXBsZUVxdWFsID0gZnVuY3Rpb24gKG9iaiwgcmVmKSB7XG5cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIFNldC5wcm90b3R5cGUudmFsdWVzLmNhbGwob2JqKSkge1xuICAgICAgICBpZiAoIVNldC5wcm90b3R5cGUuaGFzLmNhbGwocmVmLCBlbnRyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5pbnRlcm5hbHMuaXNEZWVwRXF1YWxPYmogPSBmdW5jdGlvbiAoaW5zdGFuY2VUeXBlLCBvYmosIHJlZiwgb3B0aW9ucywgc2Vlbikge1xuXG4gICAgY29uc3QgeyBpc0RlZXBFcXVhbCwgdmFsdWVPZiwgaGFzT3duRW51bWVyYWJsZVByb3BlcnR5IH0gPSBpbnRlcm5hbHM7XG4gICAgY29uc3QgeyBrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgfSA9IE9iamVjdDtcblxuICAgIGlmIChpbnN0YW5jZVR5cGUgPT09IFR5cGVzLmFycmF5KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBhcnQpIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGluZGV4IG1hdGNoIGFueSBvdGhlciBpbmRleFxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9ialZhbHVlIG9mIG9iaikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVmVmFsdWUgb2YgcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZXBFcXVhbChvYmpWYWx1ZSwgcmVmVmFsdWUsIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoICE9PSByZWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNEZWVwRXF1YWwob2JqW2ldLCByZWZbaV0sIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMuc2V0KSB7XG4gICAgICAgIGlmIChvYmouc2l6ZSAhPT0gcmVmLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW50ZXJuYWxzLmlzU2V0U2ltcGxlRXF1YWwob2JqLCByZWYpKSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBkZWVwIGVxdWFsaXR5XG5cbiAgICAgICAgICAgIGNvbnN0IHJlZjIgPSBuZXcgU2V0KFNldC5wcm90b3R5cGUudmFsdWVzLmNhbGwocmVmKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9iakVudHJ5IG9mIFNldC5wcm90b3R5cGUudmFsdWVzLmNhbGwob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWYyLmRlbGV0ZShvYmpFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWZFbnRyeSBvZiByZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZXBFcXVhbChvYmpFbnRyeSwgcmVmRW50cnksIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYyLmRlbGV0ZShyZWZFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnN0YW5jZVR5cGUgPT09IFR5cGVzLm1hcCkge1xuICAgICAgICBpZiAob2JqLnNpemUgIT09IHJlZi5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBNYXAucHJvdG90eXBlLmVudHJpZXMuY2FsbChvYmopKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhTWFwLnByb3RvdHlwZS5oYXMuY2FsbChyZWYsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNEZWVwRXF1YWwodmFsdWUsIE1hcC5wcm90b3R5cGUuZ2V0LmNhbGwocmVmLCBrZXkpLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnN0YW5jZVR5cGUgPT09IFR5cGVzLmVycm9yKSB7XG5cbiAgICAgICAgLy8gQWx3YXlzIGNoZWNrIG5hbWUgYW5kIG1lc3NhZ2VcblxuICAgICAgICBpZiAob2JqLm5hbWUgIT09IHJlZi5uYW1lIHx8XG4gICAgICAgICAgICBvYmoubWVzc2FnZSAhPT0gcmVmLm1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgLnZhbHVlT2YoKVxuXG4gICAgY29uc3QgdmFsdWVPZk9iaiA9IHZhbHVlT2Yob2JqKTtcbiAgICBjb25zdCB2YWx1ZU9mUmVmID0gdmFsdWVPZihyZWYpO1xuICAgIGlmICgob2JqICE9PSB2YWx1ZU9mT2JqIHx8IHJlZiAhPT0gdmFsdWVPZlJlZikgJiZcbiAgICAgICAgIWlzRGVlcEVxdWFsKHZhbHVlT2ZPYmosIHZhbHVlT2ZSZWYsIG9wdGlvbnMsIHNlZW4pKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHByb3BlcnRpZXNcblxuICAgIGNvbnN0IG9iaktleXMgPSBrZXlzKG9iaik7XG4gICAgaWYgKCFvcHRpb25zLnBhcnQgJiZcbiAgICAgICAgb2JqS2V5cy5sZW5ndGggIT09IGtleXMocmVmKS5sZW5ndGggJiZcbiAgICAgICAgIW9wdGlvbnMuc2tpcCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgc2tpcHBlZCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygb2JqS2V5cykge1xuICAgICAgICBpZiAob3B0aW9ucy5za2lwICYmXG4gICAgICAgICAgICBvcHRpb25zLnNraXAuaW5jbHVkZXMoa2V5KSkge1xuXG4gICAgICAgICAgICBpZiAocmVmW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICsrc2tpcHBlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhc093bkVudW1lcmFibGVQcm9wZXJ0eShyZWYsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNEZWVwRXF1YWwob2JqW2tleV0sIHJlZltrZXldLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnBhcnQgJiZcbiAgICAgICAgb2JqS2V5cy5sZW5ndGggLSBza2lwcGVkICE9PSBrZXlzKHJlZikubGVuZ3RoKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHN5bWJvbHNcblxuICAgIGlmIChvcHRpb25zLnN5bWJvbHMgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgIGNvbnN0IG9ialN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcbiAgICAgICAgY29uc3QgcmVmU3ltYm9scyA9IG5ldyBTZXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHJlZikpO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIG9ialN5bWJvbHMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5za2lwIHx8XG4gICAgICAgICAgICAgICAgIW9wdGlvbnMuc2tpcC5pbmNsdWRlcyhrZXkpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc093bkVudW1lcmFibGVQcm9wZXJ0eShyZWYsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNEZWVwRXF1YWwob2JqW2tleV0sIHJlZltrZXldLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc093bkVudW1lcmFibGVQcm9wZXJ0eShyZWYsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVmU3ltYm9scy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJlZlN5bWJvbHMpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkocmVmLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmludGVybmFscy5TZWVuRW50cnkgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihvYmosIHJlZikge1xuXG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICB9XG5cbiAgICBpc1NhbWUob2JqLCByZWYpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5vYmogPT09IG9iaiAmJiB0aGlzLnJlZiA9PT0gcmVmO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblxuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcblxuICAgICAgICBjb25zdCBtc2dzID0gYXJnc1xuICAgICAgICAgICAgLmZpbHRlcigoYXJnKSA9PiBhcmcgIT09ICcnKVxuICAgICAgICAgICAgLm1hcCgoYXJnKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyBhcmcgOiBhcmcgaW5zdGFuY2VvZiBFcnJvciA/IGFyZy5tZXNzYWdlIDogU3RyaW5naWZ5KGFyZyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBzdXBlcihtc2dzLmpvaW4oJyAnKSB8fCAnVW5rbm93biBlcnJvcicpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHsgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGV4cG9ydHMuYXNzZXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cbiAgICAvLyBBbGxvd2VkIHZhbHVlIGNoYXJhY3RlcnM6ICEjJCUmJygpKissLS4vOjs8PT4/QFtdXl9ge3x9fiBhbmQgc3BhY2UsIGEteiwgQS1aLCAwLTksIFxcLCBcIlxuXG4gICAgQXNzZXJ0KC9eWyBcXHdcXCEjXFwkJSYnXFwoXFwpXFwqXFwrLFxcLVxcLlxcL1xcOjs8XFw9PlxcP0BcXFtcXF1cXF5gXFx7XFx8XFx9flxcXCJcXFxcXSokLy50ZXN0KGF0dHJpYnV0ZSksICdCYWQgYXR0cmlidXRlIHZhbHVlICgnICsgYXR0cmlidXRlICsgJyknKTtcblxuICAgIHJldHVybiBhdHRyaWJ1dGUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cXFwiL2csICdcXFxcXCInKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzY2FwZSBxdW90ZXMgYW5kIHNsYXNoXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbGV0IGVzY2FwZWQgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGludGVybmFscy5pc1NhZmUoY2hhckNvZGUpKSB7XG4gICAgICAgICAgICBlc2NhcGVkICs9IGlucHV0W2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnRlcm5hbHMuZXNjYXBlSHRtbENoYXIoY2hhckNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVzY2FwZWQ7XG59O1xuXG5cbmludGVybmFscy5lc2NhcGVIdG1sQ2hhciA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuXG4gICAgY29uc3QgbmFtZWRFc2NhcGUgPSBpbnRlcm5hbHMubmFtZWRIdG1sLmdldChjaGFyQ29kZSk7XG4gICAgaWYgKG5hbWVkRXNjYXBlKSB7XG4gICAgICAgIHJldHVybiBuYW1lZEVzY2FwZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhckNvZGUgPj0gMjU2KSB7XG4gICAgICAgIHJldHVybiAnJiMnICsgY2hhckNvZGUgKyAnOyc7XG4gICAgfVxuXG4gICAgY29uc3QgaGV4VmFsdWUgPSBjaGFyQ29kZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKTtcbiAgICByZXR1cm4gYCYjeCR7aGV4VmFsdWV9O2A7XG59O1xuXG5cbmludGVybmFscy5pc1NhZmUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuc2FmZUNoYXJDb2Rlcy5oYXMoY2hhckNvZGUpO1xufTtcblxuXG5pbnRlcm5hbHMubmFtZWRIdG1sID0gbmV3IE1hcChbXG4gICAgWzM4LCAnJmFtcDsnXSxcbiAgICBbNjAsICcmbHQ7J10sXG4gICAgWzYyLCAnJmd0OyddLFxuICAgIFszNCwgJyZxdW90OyddLFxuICAgIFsxNjAsICcmbmJzcDsnXSxcbiAgICBbMTYyLCAnJmNlbnQ7J10sXG4gICAgWzE2MywgJyZwb3VuZDsnXSxcbiAgICBbMTY0LCAnJmN1cnJlbjsnXSxcbiAgICBbMTY5LCAnJmNvcHk7J10sXG4gICAgWzE3NCwgJyZyZWc7J11cbl0pO1xuXG5cbmludGVybmFscy5zYWZlQ2hhckNvZGVzID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHNhZmUgPSBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKGxldCBpID0gMzI7IGkgPCAxMjM7ICsraSkge1xuXG4gICAgICAgIGlmICgoaSA+PSA5NykgfHwgICAgICAgICAgICAgICAgICAgIC8vIGEtelxuICAgICAgICAgICAgKGkgPj0gNjUgJiYgaSA8PSA5MCkgfHwgICAgICAgICAvLyBBLVpcbiAgICAgICAgICAgIChpID49IDQ4ICYmIGkgPD0gNTcpIHx8ICAgICAgICAgLy8gMC05XG4gICAgICAgICAgICBpID09PSAzMiB8fCAgICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlXG4gICAgICAgICAgICBpID09PSA0NiB8fCAgICAgICAgICAgICAgICAgICAgIC8vIC5cbiAgICAgICAgICAgIGkgPT09IDQ0IHx8ICAgICAgICAgICAgICAgICAgICAgLy8gLFxuICAgICAgICAgICAgaSA9PT0gNDUgfHwgICAgICAgICAgICAgICAgICAgICAvLyAtXG4gICAgICAgICAgICBpID09PSA1OCB8fCAgICAgICAgICAgICAgICAgICAgIC8vIDpcbiAgICAgICAgICAgIGkgPT09IDk1KSB7ICAgICAgICAgICAgICAgICAgICAgLy8gX1xuXG4gICAgICAgICAgICBzYWZlLmFkZChpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzYWZlO1xufSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblxuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bPD4mXFx1MjAyOFxcdTIwMjldL2csIGludGVybmFscy5lc2NhcGUpO1xufTtcblxuXG5pbnRlcm5hbHMuZXNjYXBlID0gZnVuY3Rpb24gKGNoYXIpIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMucmVwbGFjZW1lbnRzLmdldChjaGFyKTtcbn07XG5cblxuaW50ZXJuYWxzLnJlcGxhY2VtZW50cyA9IG5ldyBNYXAoW1xuICAgIFsnPCcsICdcXFxcdTAwM2MnXSxcbiAgICBbJz4nLCAnXFxcXHUwMDNlJ10sXG4gICAgWycmJywgJ1xcXFx1MDAyNiddLFxuICAgIFsnXFx1MjAyOCcsICdcXFxcdTIwMjgnXSxcbiAgICBbJ1xcdTIwMjknLCAnXFxcXHUyMDI5J11cbl0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIC8vIEVzY2FwZSBeJC4qKy0/PSE6fFxcLygpW117fSxcblxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW1xcXlxcJFxcLlxcKlxcK1xcLVxcP1xcPVxcIVxcOlxcfFxcXFxcXC9cXChcXClcXFtcXF1cXHtcXH1cXCxdL2csICdcXFxcJCYnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLmZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJyYXksIHRhcmdldCkge1xuXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0IHx8IFtdO1xuXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBhcnJheSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICAgIGludGVybmFscy5mbGF0dGVuKGVudHJ5LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmFwcGx5VG9EZWZhdWx0cyA9IHJlcXVpcmUoJy4vYXBwbHlUb0RlZmF1bHRzJyk7XG5cbmV4cG9ydHMuYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcblxuZXhwb3J0cy5CZW5jaCA9IHJlcXVpcmUoJy4vYmVuY2gnKTtcblxuZXhwb3J0cy5ibG9jayA9IHJlcXVpcmUoJy4vYmxvY2snKTtcblxuZXhwb3J0cy5jbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUnKTtcblxuZXhwb3J0cy5jb250YWluID0gcmVxdWlyZSgnLi9jb250YWluJyk7XG5cbmV4cG9ydHMuZGVlcEVxdWFsID0gcmVxdWlyZSgnLi9kZWVwRXF1YWwnKTtcblxuZXhwb3J0cy5FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3InKTtcblxuZXhwb3J0cy5lc2NhcGVIZWFkZXJBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL2VzY2FwZUhlYWRlckF0dHJpYnV0ZScpO1xuXG5leHBvcnRzLmVzY2FwZUh0bWwgPSByZXF1aXJlKCcuL2VzY2FwZUh0bWwnKTtcblxuZXhwb3J0cy5lc2NhcGVKc29uID0gcmVxdWlyZSgnLi9lc2NhcGVKc29uJyk7XG5cbmV4cG9ydHMuZXNjYXBlUmVnZXggPSByZXF1aXJlKCcuL2VzY2FwZVJlZ2V4Jyk7XG5cbmV4cG9ydHMuZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpO1xuXG5leHBvcnRzLmlnbm9yZSA9IHJlcXVpcmUoJy4vaWdub3JlJyk7XG5cbmV4cG9ydHMuaW50ZXJzZWN0ID0gcmVxdWlyZSgnLi9pbnRlcnNlY3QnKTtcblxuZXhwb3J0cy5pc1Byb21pc2UgPSByZXF1aXJlKCcuL2lzUHJvbWlzZScpO1xuXG5leHBvcnRzLm1lcmdlID0gcmVxdWlyZSgnLi9tZXJnZScpO1xuXG5leHBvcnRzLm9uY2UgPSByZXF1aXJlKCcuL29uY2UnKTtcblxuZXhwb3J0cy5yZWFjaCA9IHJlcXVpcmUoJy4vcmVhY2gnKTtcblxuZXhwb3J0cy5yZWFjaFRlbXBsYXRlID0gcmVxdWlyZSgnLi9yZWFjaFRlbXBsYXRlJyk7XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcblxuZXhwb3J0cy53YWl0ID0gcmVxdWlyZSgnLi93YWl0Jyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmICghYXJyYXkxIHx8XG4gICAgICAgICFhcnJheTIpIHtcblxuICAgICAgICByZXR1cm4gKG9wdGlvbnMuZmlyc3QgPyBudWxsIDogW10pO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbW1vbiA9IFtdO1xuICAgIGNvbnN0IGhhc2ggPSAoQXJyYXkuaXNBcnJheShhcnJheTEpID8gbmV3IFNldChhcnJheTEpIDogYXJyYXkxKTtcbiAgICBjb25zdCBmb3VuZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFycmF5Mikge1xuICAgICAgICBpZiAoaW50ZXJuYWxzLmhhcyhoYXNoLCB2YWx1ZSkgJiZcbiAgICAgICAgICAgICFmb3VuZC5oYXModmFsdWUpKSB7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpcnN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21tb24ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBmb3VuZC5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChvcHRpb25zLmZpcnN0ID8gbnVsbCA6IGNvbW1vbik7XG59O1xuXG5cbmludGVybmFscy5oYXMgPSBmdW5jdGlvbiAocmVmLCBrZXkpIHtcblxuICAgIGlmICh0eXBlb2YgcmVmLmhhcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcmVmLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZba2V5XSAhPT0gdW5kZWZpbmVkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuXG4gICAgcmV0dXJuICEhcHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMubWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydCh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHRhcmdldCB2YWx1ZTogbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICBBc3NlcnQoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzb3VyY2UgdmFsdWU6IG11c3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBvYmplY3QnKTtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBudWxsT3ZlcnJpZGU6IHRydWUsIG1lcmdlQXJyYXlzOiB0cnVlIH0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBBc3NlcnQoQXJyYXkuaXNBcnJheSh0YXJnZXQpLCAnQ2Fubm90IG1lcmdlIGFycmF5IG9udG8gYW4gb2JqZWN0Jyk7XG4gICAgICAgIGlmICghb3B0aW9ucy5tZXJnZUFycmF5cykge1xuICAgICAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11c3Qgbm90IGNoYW5nZSB0YXJnZXQgYXNzaWdubWVudFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKENsb25lKHNvdXJjZVtpXSwgeyBzeW1ib2xzOiBvcHRpb25zLnN5bWJvbHMgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gVXRpbHMua2V5cyhzb3VyY2UsIG9wdGlvbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fFxuICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIHtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgaWYgKHRhcmdldFtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW4gb2NjdXIgZm9yIHNoYWxsb3cgbWVyZ2VzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGFyZ2V0W2tleV0gfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0W2tleV0gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkodGFyZ2V0W2tleV0pICE9PSBBcnJheS5pc0FycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgICAgICAgICAoQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHx8ICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gQ2xvbmUodmFsdWUsIHsgc3ltYm9sczogb3B0aW9ucy5zeW1ib2xzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzLm1lcmdlKHRhcmdldFtrZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgdG8gcHJlc2VydmUgZW1wdHkgc3RyaW5nc1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMubnVsbE92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgd3JhcHBlZDogU3ltYm9sKCd3cmFwcGVkJylcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG5cbiAgICBpZiAobWV0aG9kW2ludGVybmFscy53cmFwcGVkXSkge1xuICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgIH1cblxuICAgIGxldCBvbmNlID0gZmFsc2U7XG4gICAgY29uc3Qgd3JhcHBlZEZuID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBpZiAoIW9uY2UpIHtcbiAgICAgICAgICAgIG9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgbWV0aG9kKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHdyYXBwZWRGbltpbnRlcm5hbHMud3JhcHBlZF0gPSB0cnVlO1xuICAgIHJldHVybiB3cmFwcGVkRm47XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgY2hhaW4sIG9wdGlvbnMpIHtcblxuICAgIGlmIChjaGFpbiA9PT0gZmFsc2UgfHxcbiAgICAgICAgY2hhaW4gPT09IG51bGwgfHxcbiAgICAgICAgY2hhaW4gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zID0geyBzZXBhcmF0b3I6IG9wdGlvbnMgfTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0NoYWluQXJyYXkgPSBBcnJheS5pc0FycmF5KGNoYWluKTtcblxuICAgIEFzc2VydCghaXNDaGFpbkFycmF5IHx8ICFvcHRpb25zLnNlcGFyYXRvciwgJ1NlcGFyYXRvciBvcHRpb24gaXMgbm90IHZhbGlkIGZvciBhcnJheS1iYXNlZCBjaGFpbicpO1xuXG4gICAgY29uc3QgcGF0aCA9IGlzQ2hhaW5BcnJheSA/IGNoYWluIDogY2hhaW4uc3BsaXQob3B0aW9ucy5zZXBhcmF0b3IgfHwgJy4nKTtcbiAgICBsZXQgcmVmID0gb2JqO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICBsZXQga2V5ID0gcGF0aFtpXTtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9wdGlvbnMuaXRlcmFibGVzICYmIGludGVybmFscy5pdGVyYWJsZXMocmVmKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWYpIHx8XG4gICAgICAgICAgICB0eXBlID09PSAnc2V0Jykge1xuXG4gICAgICAgICAgICBjb25zdCBudW1iZXIgPSBOdW1iZXIoa2V5KTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBudW1iZXIgPCAwID8gcmVmLmxlbmd0aCArIG51bWJlciA6IG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmIHx8XG4gICAgICAgICAgICB0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMuZnVuY3Rpb25zID09PSBmYWxzZSB8fCAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICF0eXBlICYmIHJlZltrZXldID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KCFvcHRpb25zLnN0cmljdCB8fCBpICsgMSA9PT0gcGF0aC5sZW5ndGgsICdNaXNzaW5nIHNlZ21lbnQnLCBrZXksICdpbiByZWFjaCBwYXRoICcsIGNoYWluKTtcbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgcmVmID09PSAnb2JqZWN0JyB8fCBvcHRpb25zLmZ1bmN0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2YgcmVmICE9PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBzZWdtZW50Jywga2V5LCAnaW4gcmVhY2ggcGF0aCAnLCBjaGFpbik7XG4gICAgICAgICAgICByZWYgPSBvcHRpb25zLmRlZmF1bHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgcmVmID0gcmVmW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgIHJlZiA9IFsuLi5yZWZdW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAvLyB0eXBlID09PSAnbWFwJ1xuICAgICAgICAgICAgcmVmID0gcmVmLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZjtcbn07XG5cblxuaW50ZXJuYWxzLml0ZXJhYmxlcyA9IGZ1bmN0aW9uIChyZWYpIHtcblxuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuICdzZXQnO1xuICAgIH1cblxuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgcmV0dXJuICdtYXAnO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnLi9yZWFjaCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgdGVtcGxhdGUsIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC97KFtee31dKyl9L2csICgkMCwgY2hhaW4pID0+IHtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IFJlYWNoKG9iaiwgY2hhaW4sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwgPyAnJyA6IHZhbHVlKTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSguLi5hcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gJ1tDYW5ub3QgZGlzcGxheSBvYmplY3Q6ICcgKyBlcnIubWVzc2FnZSArICddJztcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXJyYXk6IEFycmF5LnByb3RvdHlwZSxcbiAgICBidWZmZXI6IEJ1ZmZlciAmJiBCdWZmZXIucHJvdG90eXBlLCAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICBkYXRlOiBEYXRlLnByb3RvdHlwZSxcbiAgICBlcnJvcjogRXJyb3IucHJvdG90eXBlLFxuICAgIGdlbmVyaWM6IE9iamVjdC5wcm90b3R5cGUsXG4gICAgbWFwOiBNYXAucHJvdG90eXBlLFxuICAgIHByb21pc2U6IFByb21pc2UucHJvdG90eXBlLFxuICAgIHJlZ2V4OiBSZWdFeHAucHJvdG90eXBlLFxuICAgIHNldDogU2V0LnByb3RvdHlwZSxcbiAgICB3ZWFrTWFwOiBXZWFrTWFwLnByb3RvdHlwZSxcbiAgICB3ZWFrU2V0OiBXZWFrU2V0LnByb3RvdHlwZVxufTtcblxuXG5pbnRlcm5hbHMudHlwZU1hcCA9IG5ldyBNYXAoW1xuICAgIFsnW29iamVjdCBFcnJvcl0nLCBleHBvcnRzLmVycm9yXSxcbiAgICBbJ1tvYmplY3QgTWFwXScsIGV4cG9ydHMubWFwXSxcbiAgICBbJ1tvYmplY3QgUHJvbWlzZV0nLCBleHBvcnRzLnByb21pc2VdLFxuICAgIFsnW29iamVjdCBTZXRdJywgZXhwb3J0cy5zZXRdLFxuICAgIFsnW29iamVjdCBXZWFrTWFwXScsIGV4cG9ydHMud2Vha01hcF0sXG4gICAgWydbb2JqZWN0IFdlYWtTZXRdJywgZXhwb3J0cy53ZWFrU2V0XVxuXSk7XG5cblxuZXhwb3J0cy5nZXRJbnRlcm5hbFByb3RvID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5hcnJheTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEJ1ZmZlcikgeyAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmRhdGU7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5yZWdleDtcbiAgICB9XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZXJyb3I7XG4gICAgfVxuXG4gICAgY29uc3Qgb2JqTmFtZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICAgIHJldHVybiBpbnRlcm5hbHMudHlwZU1hcC5nZXQob2JqTmFtZSkgfHwgZXhwb3J0cy5nZW5lcmljO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iaiwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICByZXR1cm4gb3B0aW9ucy5zeW1ib2xzICE9PSBmYWxzZSA/IFJlZmxlY3Qub3duS2V5cyhvYmopIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTsgIC8vIERlZmF1bHRzIHRvIHRydWVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtYXhUaW1lcjogMiAqKiAzMSAtIDEgICAgICAgICAgICAgIC8vIH4yNSBkYXlzXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRpbWVvdXQsIHJldHVyblZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICBpZiAodHlwZW9mIHRpbWVvdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHRpbWVvdXQgPSBOdW1iZXIodGltZW91dCk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXQgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHsgICAgICAgICAvLyBUaG91c2FuZHMgb2YgeWVhcnNcbiAgICAgICAgdGltZW91dCA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGltZW91dCAhPT0gJ251bWJlcicgJiYgdGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RpbWVvdXQgbXVzdCBiZSBhIG51bWJlciBvciBiaWdpbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblxuICAgICAgICBjb25zdCBfc2V0VGltZW91dCA9IG9wdGlvbnMgPyBvcHRpb25zLnNldFRpbWVvdXQgOiBzZXRUaW1lb3V0O1xuXG4gICAgICAgIGNvbnN0IGFjdGl2YXRlID0gKCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCB0aW1lID0gTWF0aC5taW4odGltZW91dCwgaW50ZXJuYWxzLm1heFRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVvdXQgLT0gdGltZTtcbiAgICAgICAgICAgIF9zZXRUaW1lb3V0KCgpID0+ICh0aW1lb3V0ID4gMCA/IGFjdGl2YXRlKCkgOiByZXNvbHZlKHJldHVyblZhbHVlKSksIHRpbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aW1lb3V0ICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5Tb3J0ZXIgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuXG4gICAgYWRkKG5vZGVzLCBvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcnVsZXNcblxuICAgICAgICBjb25zdCBiZWZvcmUgPSBbXS5jb25jYXQob3B0aW9ucy5iZWZvcmUgfHwgW10pO1xuICAgICAgICBjb25zdCBhZnRlciA9IFtdLmNvbmNhdChvcHRpb25zLmFmdGVyIHx8IFtdKTtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBvcHRpb25zLmdyb3VwIHx8ICc/JztcbiAgICAgICAgY29uc3Qgc29ydCA9IG9wdGlvbnMuc29ydCB8fCAwOyAgICAgICAgICAgICAgICAgICAvLyBVc2VkIGZvciBtZXJnaW5nIG9ubHlcblxuICAgICAgICBBc3NlcnQoIWJlZm9yZS5pbmNsdWRlcyhncm91cCksIGBJdGVtIGNhbm5vdCBjb21lIGJlZm9yZSBpdHNlbGY6ICR7Z3JvdXB9YCk7XG4gICAgICAgIEFzc2VydCghYmVmb3JlLmluY2x1ZGVzKCc/JyksICdJdGVtIGNhbm5vdCBjb21lIGJlZm9yZSB1bmFzc29jaWF0ZWQgaXRlbXMnKTtcbiAgICAgICAgQXNzZXJ0KCFhZnRlci5pbmNsdWRlcyhncm91cCksIGBJdGVtIGNhbm5vdCBjb21lIGFmdGVyIGl0c2VsZjogJHtncm91cH1gKTtcbiAgICAgICAgQXNzZXJ0KCFhZnRlci5pbmNsdWRlcygnPycpLCAnSXRlbSBjYW5ub3QgY29tZSBhZnRlciB1bmFzc29jaWF0ZWQgaXRlbXMnKTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgc2VxOiB0aGlzLl9pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgICAgICBiZWZvcmUsXG4gICAgICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgICAgICAgICAgZ3JvdXAsXG4gICAgICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluc2VydCBldmVudFxuXG4gICAgICAgIGlmICghb3B0aW9ucy5tYW51YWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5fc29ydCgpO1xuICAgICAgICAgICAgQXNzZXJ0KHZhbGlkLCAnaXRlbScsIGdyb3VwICE9PSAnPycgPyBgYWRkZWQgaW50byBncm91cCAke2dyb3VwfWAgOiAnJywgJ2NyZWF0ZWQgYSBkZXBlbmRlbmNpZXMgZXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH1cblxuICAgIG1lcmdlKG90aGVycykge1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvdGhlcnMpKSB7XG4gICAgICAgICAgICBvdGhlcnMgPSBbb3RoZXJzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qgb3RoZXIgb2Ygb3RoZXJzKSB7XG4gICAgICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3RoZXIuX2l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgaXRlbSkpOyAgICAgIC8vIFNoYWxsb3cgY2xvbmVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29ydCBpdGVtc1xuXG4gICAgICAgIHRoaXMuX2l0ZW1zLnNvcnQoaW50ZXJuYWxzLm1lcmdlU29ydCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zW2ldLnNlcSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMuX3NvcnQoKTtcbiAgICAgICAgQXNzZXJ0KHZhbGlkLCAnbWVyZ2UgY3JlYXRlZCBhIGRlcGVuZGVuY2llcyBlcnJvcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH1cblxuICAgIHNvcnQoKSB7XG5cbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zb3J0KCk7XG4gICAgICAgIEFzc2VydCh2YWxpZCwgJ3NvcnQgY3JlYXRlZCBhIGRlcGVuZGVuY2llcyBlcnJvcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH1cblxuICAgIF9zb3J0KCkge1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBncmFwaFxuXG4gICAgICAgIGNvbnN0IGdyYXBoID0ge307XG4gICAgICAgIGNvbnN0IGdyYXBoQWZ0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgICAgICAgICAgICAvLyBBIHByb3RvdHlwZSBjYW4gYnVuZ2xlIGxvb2t1cHMgdy8gZmFsc2UgcG9zaXRpdmVzXG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBzZXEgPSBpdGVtLnNlcTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmlxdWUgYWNyb3NzIGFsbCBpdGVtc1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBpdGVtLmdyb3VwO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgR3JvdXBzXG5cbiAgICAgICAgICAgIGdyb3Vwc1tncm91cF0gPSBncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgZ3JvdXBzW2dyb3VwXS5wdXNoKHNlcSk7XG5cbiAgICAgICAgICAgIC8vIEJ1aWxkIGludGVybWVkaWFyeSBncmFwaCB1c2luZyAnYmVmb3JlJ1xuXG4gICAgICAgICAgICBncmFwaFtzZXFdID0gaXRlbS5iZWZvcmU7XG5cbiAgICAgICAgICAgIC8vIEJ1aWxkIHNlY29uZCBpbnRlcm1lZGlhcnkgZ3JhcGggd2l0aCAnYWZ0ZXInXG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgYWZ0ZXIgb2YgaXRlbS5hZnRlcikge1xuICAgICAgICAgICAgICAgIGdyYXBoQWZ0ZXJzW2FmdGVyXSA9IGdyYXBoQWZ0ZXJzW2FmdGVyXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBncmFwaEFmdGVyc1thZnRlcl0ucHVzaChzZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhwYW5kIGludGVybWVkaWFyeSBncmFwaFxuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBpbiBncmFwaCkge1xuICAgICAgICAgICAgY29uc3QgZXhwYW5kZWRHcm91cHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBncmFwaE5vZGVJdGVtIGluIGdyYXBoW25vZGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBncmFwaFtub2RlXVtncmFwaE5vZGVJdGVtXTtcbiAgICAgICAgICAgICAgICBncm91cHNbZ3JvdXBdID0gZ3JvdXBzW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBleHBhbmRlZEdyb3Vwcy5wdXNoKC4uLmdyb3Vwc1tncm91cF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncmFwaFtub2RlXSA9IGV4cGFuZGVkR3JvdXBzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWVyZ2UgaW50ZXJtZWRpYXJ5IGdyYXBoIHVzaW5nIGdyYXBoQWZ0ZXJzIGludG8gZmluYWwgZ3JhcGhcblxuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIGluIGdyYXBoQWZ0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXBzW2dyb3VwXSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBncm91cHNbZ3JvdXBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoW25vZGVdLnB1c2goLi4uZ3JhcGhBZnRlcnNbZ3JvdXBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21waWxlIGFuY2VzdG9yc1xuXG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgaW4gZ3JhcGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ3JhcGhbbm9kZV07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzW2NoaWxkXSA9IGFuY2VzdG9yc1tjaGlsZF0gfHwgW107XG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzW2NoaWxkXS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG9wbyBzb3J0XG5cbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IHt9O1xuICAgICAgICBjb25zdCBzb3J0ZWQgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgKytpKSB7ICAgICAgICAgIC8vIExvb3BpbmcgdGhyb3VnaCBpdGVtLnNlcSB2YWx1ZXMgb3V0IG9mIG9yZGVyXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGk7XG5cbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnNbaV0pIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgKytqKSB7ICAvLyBBcyBhYm92ZSwgdGhlc2UgYXJlIGl0ZW0uc2VxIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFtqXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuY2VzdG9yc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JzW2pdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRTZWVDb3VudCA9IGFuY2VzdG9yc1tqXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWVuQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHNob3VsZFNlZUNvdW50OyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkW2FuY2VzdG9yc1tqXVtrXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3NlZW5Db3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVuQ291bnQgPT09IHNob3VsZFNlZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbbmV4dF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNvcnRlZC5wdXNoKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvcnRlZC5sZW5ndGggIT09IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VxSW5kZXggPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICAgICAgICBzZXFJbmRleFtpdGVtLnNlcV0gPSBpdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygc29ydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRJdGVtID0gc2VxSW5kZXhbdmFsdWVdO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHNvcnRlZEl0ZW0ubm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5wdXNoKHNvcnRlZEl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMubWVyZ2VTb3J0ID0gKGEsIGIpID0+IHtcblxuICAgIHJldHVybiBhLnNvcnQgPT09IGIuc29ydCA/IDAgOiAoYS5zb3J0IDwgYi5zb3J0ID8gLTEgOiAxKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtaW5Eb21haW5TZWdtZW50czogMixcbiAgICBub25Bc2NpaVJ4OiAvW15cXHgwMC1cXHg3Zl0vLFxuICAgIGRvbWFpbkNvbnRyb2xSeDogL1tcXHgwMC1cXHgyMEBcXDpcXC9cXFxcIyFcXCQmXFwnXFwoXFwpXFwqXFwrLDs9XFw/XS8sICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250cm9sICsgc3BhY2UgKyBzZXBhcmF0b3JzXG4gICAgdGxkU2VnbWVudFJ4OiAvXlthLXpBLVpdKD86W2EtekEtWjAtOVxcLV0qW2EtekEtWjAtOV0pPyQvLFxuICAgIGRvbWFpblNlZ21lbnRSeDogL15bYS16QS1aMC05XSg/OlthLXpBLVowLTlcXC1dKlthLXpBLVowLTldKT8kLyxcbiAgICBVUkw6IFVybC5VUkwgfHwgVVJMICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbn07XG5cblxuZXhwb3J0cy5hbmFseXplID0gZnVuY3Rpb24gKGRvbWFpbiwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBpZiAoIWRvbWFpbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXRjaCBudWxsIC8gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX05PTl9FTVBUWV9TVFJJTkcnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRvbWFpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0OiBkb21haW4gbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmIChkb21haW4ubGVuZ3RoID4gMjU2KSB7XG4gICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX1RPT19MT05HJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYXNjaWkgPSAhaW50ZXJuYWxzLm5vbkFzY2lpUngudGVzdChkb21haW4pO1xuICAgIGlmICghYXNjaWkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dVbmljb2RlID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9JTlZBTElEX1VOSUNPREVfQ0hBUlMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbWFpbiA9IGRvbWFpbi5ub3JtYWxpemUoJ05GQycpO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbHMuZG9tYWluQ29udHJvbFJ4LnRlc3QoZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9JTlZBTElEX0NIQVJTJyk7XG4gICAgfVxuXG4gICAgZG9tYWluID0gaW50ZXJuYWxzLnB1bnljb2RlKGRvbWFpbik7XG5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTAzNSBzZWN0aW9uIDIuMy4xXG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0Z1bGx5UXVhbGlmaWVkICYmXG4gICAgICAgIGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0gPT09ICcuJykge1xuXG4gICAgICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWluRG9tYWluU2VnbWVudHMgPSBvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzIHx8IGludGVybmFscy5taW5Eb21haW5TZWdtZW50cztcblxuICAgIGNvbnN0IHNlZ21lbnRzID0gZG9tYWluLnNwbGl0KCcuJyk7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA8IG1pbkRvbWFpblNlZ21lbnRzKSB7XG4gICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX1NFR01FTlRTX0NPVU5UJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMpIHtcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX1NFR01FTlRTX0NPVU5UX01BWCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGxkcyA9IG9wdGlvbnMudGxkcztcbiAgICBpZiAodGxkcykge1xuICAgICAgICBjb25zdCB0bGQgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodGxkcy5kZW55ICYmIHRsZHMuZGVueS5oYXModGxkKSB8fFxuICAgICAgICAgICAgdGxkcy5hbGxvdyAmJiAhdGxkcy5hbGxvdy5oYXModGxkKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0RPTUFJTl9GT1JCSURERU5fVExEUycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cbiAgICAgICAgaWYgKCFzZWdtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdET01BSU5fRU1QVFlfU0VHTUVOVCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNjMpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX0xPTkdfU0VHTUVOVCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPCBzZWdtZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy5kb21haW5TZWdtZW50UngudGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRE9NQUlOX0lOVkFMSURfQ0hBUlMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLnRsZFNlZ21lbnRSeC50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdET01BSU5fSU5WQUxJRF9UTERTX0NIQVJTJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuZXhwb3J0cy5pc1ZhbGlkID0gZnVuY3Rpb24gKGRvbWFpbiwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuICFleHBvcnRzLmFuYWx5emUoZG9tYWluLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLnB1bnljb2RlID0gZnVuY3Rpb24gKGRvbWFpbikge1xuXG4gICAgaWYgKGRvbWFpbi5pbmNsdWRlcygnJScpKSB7XG4gICAgICAgIGRvbWFpbiA9IGRvbWFpbi5yZXBsYWNlKC8lL2csICclMjUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5VUkwoYGh0dHA6Ly8ke2RvbWFpbn1gKS5ob3N0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgRG9tYWluID0gcmVxdWlyZSgnLi9kb21haW4nKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG5vbkFzY2lpUng6IC9bXlxceDAwLVxceDdmXS8sXG4gICAgZW5jb2RlcjogbmV3IChVdGlsLlRleHRFbmNvZGVyIHx8IFRleHRFbmNvZGVyKSgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbn07XG5cblxuZXhwb3J0cy5hbmFseXplID0gZnVuY3Rpb24gKGVtYWlsLCBvcHRpb25zKSB7XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmVtYWlsKGVtYWlsLCBvcHRpb25zKTtcbn07XG5cblxuZXhwb3J0cy5pc1ZhbGlkID0gZnVuY3Rpb24gKGVtYWlsLCBvcHRpb25zKSB7XG5cbiAgICByZXR1cm4gIWludGVybmFscy5lbWFpbChlbWFpbCwgb3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5lbWFpbCA9IGZ1bmN0aW9uIChlbWFpbCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQ6IGVtYWlsIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIWVtYWlsKSB7XG4gICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnRU1QVFlfU1RSSU5HJyk7XG4gICAgfVxuXG4gICAgLy8gVW5pY29kZVxuXG4gICAgY29uc3QgYXNjaWkgPSAhaW50ZXJuYWxzLm5vbkFzY2lpUngudGVzdChlbWFpbCk7XG4gICAgaWYgKCFhc2NpaSkge1xuICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1VuaWNvZGUgPT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdGT1JCSURERU5fVU5JQ09ERScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1haWwgPSBlbWFpbC5ub3JtYWxpemUoJ05GQycpO1xuICAgIH1cblxuICAgIC8vIEJhc2ljIHN0cnVjdHVyZVxuXG4gICAgY29uc3QgcGFydHMgPSBlbWFpbC5zcGxpdCgnQCcpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA+IDIgPyBFcnJvcnMuY29kZSgnTVVMVElQTEVfQVRfQ0hBUicpIDogRXJyb3JzLmNvZGUoJ01JU1NJTkdfQVRfQ0hBUicpO1xuICAgIH1cblxuICAgIGNvbnN0IFtsb2NhbCwgZG9tYWluXSA9IHBhcnRzO1xuXG4gICAgaWYgKCFsb2NhbCkge1xuICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0VNUFRZX0xPQ0FMJyk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmlnbm9yZUxlbmd0aCkge1xuICAgICAgICBpZiAoZW1haWwubGVuZ3RoID4gMjU0KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjEjc2VjdGlvbi00LjUuMy4xLjNcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnQUREUkVTU19UT09fTE9ORycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVybmFscy5lbmNvZGVyLmVuY29kZShsb2NhbCkubGVuZ3RoID4gNjQpIHsgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC41LjMuMS4xXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JzLmNvZGUoJ0xPQ0FMX1RPT19MT05HJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBwYXJ0c1xuXG4gICAgcmV0dXJuIGludGVybmFscy5sb2NhbChsb2NhbCwgYXNjaWkpIHx8IERvbWFpbi5hbmFseXplKGRvbWFpbiwgb3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5sb2NhbCA9IGZ1bmN0aW9uIChsb2NhbCwgYXNjaWkpIHtcblxuICAgIGNvbnN0IHNlZ21lbnRzID0gbG9jYWwuc3BsaXQoJy4nKTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgaWYgKCFzZWdtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9ycy5jb2RlKCdFTVBUWV9MT0NBTF9TRUdNRU5UJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXNjaWkpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLmF0ZXh0UngudGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnSU5WQUxJRF9MT0NBTF9DSEFSUycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgY2hhciBvZiBzZWdtZW50KSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmF0ZXh0UngudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBiaW5hcnkgPSBpbnRlcm5hbHMuYmluYXJ5KGNoYXIpO1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuYXRvbVJ4LnRlc3QoYmluYXJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvcnMuY29kZSgnSU5WQUxJRF9MT0NBTF9DSEFSUycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuYmluYXJ5ID0gZnVuY3Rpb24gKGNoYXIpIHtcblxuICAgIHJldHVybiBBcnJheS5mcm9tKGludGVybmFscy5lbmNvZGVyLmVuY29kZShjaGFyKSkubWFwKCh2KSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKHYpKS5qb2luKCcnKTtcbn07XG5cblxuLypcbiAgICBGcm9tIFJGQyA1MzIxOlxuXG4gICAgICAgIE1haWxib3ggICAgICAgICA9ICAgTG9jYWwtcGFydCBcIkBcIiAoIERvbWFpbiAvIGFkZHJlc3MtbGl0ZXJhbCApXG5cbiAgICAgICAgTG9jYWwtcGFydCAgICAgID0gICBEb3Qtc3RyaW5nIC8gUXVvdGVkLXN0cmluZ1xuICAgICAgICBEb3Qtc3RyaW5nICAgICAgPSAgIEF0b20gKihcIi5cIiAgQXRvbSlcbiAgICAgICAgQXRvbSAgICAgICAgICAgID0gICAxKmF0ZXh0XG4gICAgICAgIGF0ZXh0ICAgICAgICAgICA9ICAgQUxQSEEgLyBESUdJVCAvIFwiIVwiIC8gXCIjXCIgLyBcIiRcIiAvIFwiJVwiIC8gXCImXCIgLyBcIidcIiAvIFwiKlwiIC8gXCIrXCIgLyBcIi1cIiAvIFwiL1wiIC8gXCI9XCIgLyBcIj9cIiAvIFwiXlwiIC8gXCJfXCIgLyBcImBcIiAvIFwie1wiIC8gXCJ8XCIgLyBcIn1cIiAvIFwiflwiXG5cbiAgICAgICAgRG9tYWluICAgICAgICAgID0gICBzdWItZG9tYWluICooXCIuXCIgc3ViLWRvbWFpbilcbiAgICAgICAgc3ViLWRvbWFpbiAgICAgID0gICBMZXQtZGlnIFtMZGgtc3RyXVxuICAgICAgICBMZXQtZGlnICAgICAgICAgPSAgIEFMUEhBIC8gRElHSVRcbiAgICAgICAgTGRoLXN0ciAgICAgICAgID0gICAqKCBBTFBIQSAvIERJR0lUIC8gXCItXCIgKSBMZXQtZGlnXG5cbiAgICAgICAgQUxQSEEgICAgICAgICAgID0gICAleDQxLTVBIC8gJXg2MS03QSAgICAgICAgOyBhLXosIEEtWlxuICAgICAgICBESUdJVCAgICAgICAgICAgPSAgICV4MzAtMzkgICAgICAgICAgICAgICAgICA7IDAtOVxuXG4gICAgRnJvbSBSRkMgNjUzMTpcblxuICAgICAgICBzdWItZG9tYWluICAgICAgPS8gIFUtbGFiZWxcbiAgICAgICAgYXRleHQgICAgICAgICAgID0vICBVVEY4LW5vbi1hc2NpaVxuXG4gICAgICAgIFVURjgtbm9uLWFzY2lpICA9ICAgVVRGOC0yIC8gVVRGOC0zIC8gVVRGOC00XG5cbiAgICAgICAgVVRGOC0yICAgICAgICAgID0gICAleEMyLURGIFVURjgtdGFpbFxuICAgICAgICBVVEY4LTMgICAgICAgICAgPSAgICV4RTAgJXhBMC1CRiBVVEY4LXRhaWwgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RTEtRUMgMiggVVRGOC10YWlsICkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RUQgJXg4MC05RiBVVEY4LXRhaWwgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RUUtRUYgMiggVVRGOC10YWlsIClcbiAgICAgICAgVVRGOC00ICAgICAgICAgID0gICAleEYwICV4OTAtQkYgMiggVVRGOC10YWlsICkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RjEtRjMgMyggVVRGOC10YWlsICkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RjQgJXg4MC04RiAyKCBVVEY4LXRhaWwgKVxuXG4gICAgICAgIFVURjgtdGFpbCAgICAgICA9ICAgJXg4MC1CRlxuXG4gICAgTm90ZTogVGhlIGZvbGxvd2luZyBhcmUgbm90IHN1cHBvcnRlZDpcblxuICAgICAgICBSRkMgNTMyMTogYWRkcmVzcy1saXRlcmFsLCBRdW90ZWQtc3RyaW5nXG4gICAgICAgIFJGQyA1MzIyOiBvYnMtKiwgQ0ZXU1xuKi9cblxuXG5pbnRlcm5hbHMuYXRleHRSeCA9IC9eW1xcdyEjXFwkJSYnXFwqXFwrXFwtLz1cXD9cXF5gXFx7XFx8XFx9fl0rJC87ICAgICAgICAgICAgICAgLy8gXyBpbmNsdWRlZCBpbiBcXHdcblxuXG5pbnRlcm5hbHMuYXRvbVJ4ID0gbmV3IFJlZ0V4cChbXG5cbiAgICAvLyAgJXhDMi1ERiBVVEY4LXRhaWxcbiAgICAnKD86W1xcXFx4YzItXFxcXHhkZl1bXFxcXHg4MC1cXFxceGJmXSknLFxuXG4gICAgLy8gICV4RTAgJXhBMC1CRiBVVEY4LXRhaWwgICAgICAgICAgICAgICV4RTEtRUMgMiggVVRGOC10YWlsICkgICAgICAgICAgICAleEVEICV4ODAtOUYgVVRGOC10YWlsICAgICAgICAgICAgICAleEVFLUVGIDIoIFVURjgtdGFpbCApXG4gICAgJyg/OlxcXFx4ZTBbXFxcXHhhMC1cXFxceGJmXVtcXFxceDgwLVxcXFx4YmZdKXwoPzpbXFxcXHhlMS1cXFxceGVjXVtcXFxceDgwLVxcXFx4YmZdezJ9KXwoPzpcXFxceGVkW1xcXFx4ODAtXFxcXHg5Zl1bXFxcXHg4MC1cXFxceGJmXSl8KD86W1xcXFx4ZWUtXFxcXHhlZl1bXFxcXHg4MC1cXFxceGJmXXsyfSknLFxuXG4gICAgLy8gICV4RjAgJXg5MC1CRiAyKCBVVEY4LXRhaWwgKSAgICAgICAgICAgICV4RjEtRjMgMyggVVRGOC10YWlsICkgICAgICAgICAgICAleEY0ICV4ODAtOEYgMiggVVRGOC10YWlsIClcbiAgICAnKD86XFxcXHhmMFtcXFxceDkwLVxcXFx4YmZdW1xcXFx4ODAtXFxcXHhiZl17Mn0pfCg/OltcXFxceGYxLVxcXFx4ZjNdW1xcXFx4ODAtXFxcXHhiZl17M30pfCg/OlxcXFx4ZjRbXFxcXHg4MC1cXFxceDhmXVtcXFxceDgwLVxcXFx4YmZdezJ9KSdcblxuXS5qb2luKCd8JykpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmNvZGVzID0ge1xuICAgIEVNUFRZX1NUUklORzogJ0FkZHJlc3MgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnLFxuICAgIEZPUkJJRERFTl9VTklDT0RFOiAnQWRkcmVzcyBjb250YWlucyBmb3JiaWRkZW4gVW5pY29kZSBjaGFyYWN0ZXJzJyxcbiAgICBNVUxUSVBMRV9BVF9DSEFSOiAnQWRkcmVzcyBjYW5ub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIEAgY2hhcmFjdGVyJyxcbiAgICBNSVNTSU5HX0FUX0NIQVI6ICdBZGRyZXNzIG11c3QgY29udGFpbiBvbmUgQCBjaGFyYWN0ZXInLFxuICAgIEVNUFRZX0xPQ0FMOiAnQWRkcmVzcyBsb2NhbCBwYXJ0IGNhbm5vdCBiZSBlbXB0eScsXG4gICAgQUREUkVTU19UT09fTE9ORzogJ0FkZHJlc3MgdG9vIGxvbmcnLFxuICAgIExPQ0FMX1RPT19MT05HOiAnQWRkcmVzcyBsb2NhbCBwYXJ0IHRvbyBsb25nJyxcbiAgICBFTVBUWV9MT0NBTF9TRUdNRU5UOiAnQWRkcmVzcyBsb2NhbCBwYXJ0IGNvbnRhaW5zIGVtcHR5IGRvdC1zZXBhcmF0ZWQgc2VnbWVudCcsXG4gICAgSU5WQUxJRF9MT0NBTF9DSEFSUzogJ0FkZHJlc3MgbG9jYWwgcGFydCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcicsXG4gICAgRE9NQUlOX05PTl9FTVBUWV9TVFJJTkc6ICdEb21haW4gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnLFxuICAgIERPTUFJTl9UT09fTE9ORzogJ0RvbWFpbiB0b28gbG9uZycsXG4gICAgRE9NQUlOX0lOVkFMSURfVU5JQ09ERV9DSEFSUzogJ0RvbWFpbiBjb250YWlucyBmb3JiaWRkZW4gVW5pY29kZSBjaGFyYWN0ZXJzJyxcbiAgICBET01BSU5fSU5WQUxJRF9DSEFSUzogJ0RvbWFpbiBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcicsXG4gICAgRE9NQUlOX0lOVkFMSURfVExEU19DSEFSUzogJ0RvbWFpbiBjb250YWlucyBpbnZhbGlkIHRsZCBjaGFyYWN0ZXInLFxuICAgIERPTUFJTl9TRUdNRU5UU19DT1VOVDogJ0RvbWFpbiBsYWNrcyB0aGUgbWluaW11bSByZXF1aXJlZCBudW1iZXIgb2Ygc2VnbWVudHMnLFxuICAgIERPTUFJTl9TRUdNRU5UU19DT1VOVF9NQVg6ICdEb21haW4gY29udGFpbnMgdG9vIG1hbnkgc2VnbWVudHMnLFxuICAgIERPTUFJTl9GT1JCSURERU5fVExEUzogJ0RvbWFpbiB1c2VzIGZvcmJpZGRlbiBUTEQnLFxuICAgIERPTUFJTl9FTVBUWV9TRUdNRU5UOiAnRG9tYWluIGNvbnRhaW5zIGVtcHR5IGRvdC1zZXBhcmF0ZWQgc2VnbWVudCcsXG4gICAgRE9NQUlOX0xPTkdfU0VHTUVOVDogJ0RvbWFpbiBjb250YWlucyBkb3Qtc2VwYXJhdGVkIHNlZ21lbnQgdGhhdCBpcyB0b28gbG9uZydcbn07XG5cblxuZXhwb3J0cy5jb2RlID0gZnVuY3Rpb24gKGNvZGUpIHtcblxuICAgIHJldHVybiB7IGNvZGUsIGVycm9yOiBleHBvcnRzLmNvZGVzW2NvZGVdIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgVXJpID0gcmVxdWlyZSgnLi91cmknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnJlZ2V4ID0gZnVuY3Rpb24gKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgLy8gQ0lEUlxuXG4gICAgQXNzZXJ0KG9wdGlvbnMuY2lkciA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zLmNpZHIgPT09ICdzdHJpbmcnLCAnb3B0aW9ucy5jaWRyIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICBjb25zdCBjaWRyID0gb3B0aW9ucy5jaWRyID8gb3B0aW9ucy5jaWRyLnRvTG93ZXJDYXNlKCkgOiAnb3B0aW9uYWwnO1xuICAgIEFzc2VydChbJ3JlcXVpcmVkJywgJ29wdGlvbmFsJywgJ2ZvcmJpZGRlbiddLmluY2x1ZGVzKGNpZHIpLCAnb3B0aW9ucy5jaWRyIG11c3QgYmUgb25lIG9mIHJlcXVpcmVkLCBvcHRpb25hbCwgZm9yYmlkZGVuJyk7XG5cbiAgICAvLyBWZXJzaW9uc1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMudmVyc2lvbiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zLnZlcnNpb24gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy52ZXJzaW9uKSwgJ29wdGlvbnMudmVyc2lvbiBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZycpO1xuICAgIGxldCB2ZXJzaW9ucyA9IG9wdGlvbnMudmVyc2lvbiB8fCBbJ2lwdjQnLCAnaXB2NicsICdpcHZmdXR1cmUnXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmVyc2lvbnMpKSB7XG4gICAgICAgIHZlcnNpb25zID0gW3ZlcnNpb25zXTtcbiAgICB9XG5cbiAgICBBc3NlcnQodmVyc2lvbnMubGVuZ3RoID49IDEsICdvcHRpb25zLnZlcnNpb24gbXVzdCBoYXZlIGF0IGxlYXN0IDEgdmVyc2lvbiBzcGVjaWZpZWQnKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVyc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiB2ZXJzaW9uc1tpXSA9PT0gJ3N0cmluZycsICdvcHRpb25zLnZlcnNpb24gbXVzdCBvbmx5IGNvbnRhaW4gc3RyaW5ncycpO1xuICAgICAgICB2ZXJzaW9uc1tpXSA9IHZlcnNpb25zW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIEFzc2VydChbJ2lwdjQnLCAnaXB2NicsICdpcHZmdXR1cmUnXS5pbmNsdWRlcyh2ZXJzaW9uc1tpXSksICdvcHRpb25zLnZlcnNpb24gY29udGFpbnMgdW5rbm93biB2ZXJzaW9uICcgKyB2ZXJzaW9uc1tpXSArICcgLSBtdXN0IGJlIG9uZSBvZiBpcHY0LCBpcHY2LCBpcHZmdXR1cmUnKTtcbiAgICB9XG5cbiAgICB2ZXJzaW9ucyA9IEFycmF5LmZyb20obmV3IFNldCh2ZXJzaW9ucykpO1xuXG4gICAgLy8gUmVnZXhcblxuICAgIGNvbnN0IHBhcnRzID0gdmVyc2lvbnMubWFwKCh2ZXJzaW9uKSA9PiB7XG5cbiAgICAgICAgLy8gRm9yYmlkZGVuXG5cbiAgICAgICAgaWYgKGNpZHIgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gVXJpLmlwW3ZlcnNpb25dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVxdWlyZWRcblxuICAgICAgICBjb25zdCBjaWRycGFydCA9IGBcXFxcLyR7dmVyc2lvbiA9PT0gJ2lwdjQnID8gVXJpLmlwLnY0Q2lkciA6IFVyaS5pcC52NkNpZHJ9YDtcblxuICAgICAgICBpZiAoY2lkciA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGAke1VyaS5pcFt2ZXJzaW9uXX0ke2NpZHJwYXJ0fWA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbFxuXG4gICAgICAgIHJldHVybiBgJHtVcmkuaXBbdmVyc2lvbl19KD86JHtjaWRycGFydH0pP2A7XG4gICAgfSk7XG5cbiAgICBjb25zdCByYXcgPSBgKD86JHtwYXJ0cy5qb2luKCd8Jyl9KWA7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHtyYXd9JGApO1xuICAgIHJldHVybiB7IGNpZHIsIHZlcnNpb25zLCByZWdleCwgcmF3IH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG4vLyBodHRwOi8vZGF0YS5pYW5hLm9yZy9UTEQvdGxkcy1hbHBoYS1ieS1kb21haW4udHh0XG4vLyAjIFZlcnNpb24gMjAyMjAzMjEwMiwgTGFzdCBVcGRhdGVkIFR1ZSBNYXIgMjIgMDc6MDc6MDEgMjAyMiBVVENcblxuXG5pbnRlcm5hbHMudGxkcyA9IFtcbiAgICAnQUFBJyxcbiAgICAnQUFSUCcsXG4gICAgJ0FCQVJUSCcsXG4gICAgJ0FCQicsXG4gICAgJ0FCQk9UVCcsXG4gICAgJ0FCQlZJRScsXG4gICAgJ0FCQycsXG4gICAgJ0FCTEUnLFxuICAgICdBQk9HQURPJyxcbiAgICAnQUJVREhBQkknLFxuICAgICdBQycsXG4gICAgJ0FDQURFTVknLFxuICAgICdBQ0NFTlRVUkUnLFxuICAgICdBQ0NPVU5UQU5UJyxcbiAgICAnQUNDT1VOVEFOVFMnLFxuICAgICdBQ08nLFxuICAgICdBQ1RPUicsXG4gICAgJ0FEJyxcbiAgICAnQURBQycsXG4gICAgJ0FEUycsXG4gICAgJ0FEVUxUJyxcbiAgICAnQUUnLFxuICAgICdBRUcnLFxuICAgICdBRVJPJyxcbiAgICAnQUVUTkEnLFxuICAgICdBRicsXG4gICAgJ0FGTCcsXG4gICAgJ0FGUklDQScsXG4gICAgJ0FHJyxcbiAgICAnQUdBS0hBTicsXG4gICAgJ0FHRU5DWScsXG4gICAgJ0FJJyxcbiAgICAnQUlHJyxcbiAgICAnQUlSQlVTJyxcbiAgICAnQUlSRk9SQ0UnLFxuICAgICdBSVJURUwnLFxuICAgICdBS0ROJyxcbiAgICAnQUwnLFxuICAgICdBTEZBUk9NRU8nLFxuICAgICdBTElCQUJBJyxcbiAgICAnQUxJUEFZJyxcbiAgICAnQUxMRklOQU5aJyxcbiAgICAnQUxMU1RBVEUnLFxuICAgICdBTExZJyxcbiAgICAnQUxTQUNFJyxcbiAgICAnQUxTVE9NJyxcbiAgICAnQU0nLFxuICAgICdBTUFaT04nLFxuICAgICdBTUVSSUNBTkVYUFJFU1MnLFxuICAgICdBTUVSSUNBTkZBTUlMWScsXG4gICAgJ0FNRVgnLFxuICAgICdBTUZBTScsXG4gICAgJ0FNSUNBJyxcbiAgICAnQU1TVEVSREFNJyxcbiAgICAnQU5BTFlUSUNTJyxcbiAgICAnQU5EUk9JRCcsXG4gICAgJ0FOUVVBTicsXG4gICAgJ0FOWicsXG4gICAgJ0FPJyxcbiAgICAnQU9MJyxcbiAgICAnQVBBUlRNRU5UUycsXG4gICAgJ0FQUCcsXG4gICAgJ0FQUExFJyxcbiAgICAnQVEnLFxuICAgICdBUVVBUkVMTEUnLFxuICAgICdBUicsXG4gICAgJ0FSQUInLFxuICAgICdBUkFNQ08nLFxuICAgICdBUkNISScsXG4gICAgJ0FSTVknLFxuICAgICdBUlBBJyxcbiAgICAnQVJUJyxcbiAgICAnQVJURScsXG4gICAgJ0FTJyxcbiAgICAnQVNEQScsXG4gICAgJ0FTSUEnLFxuICAgICdBU1NPQ0lBVEVTJyxcbiAgICAnQVQnLFxuICAgICdBVEhMRVRBJyxcbiAgICAnQVRUT1JORVknLFxuICAgICdBVScsXG4gICAgJ0FVQ1RJT04nLFxuICAgICdBVURJJyxcbiAgICAnQVVESUJMRScsXG4gICAgJ0FVRElPJyxcbiAgICAnQVVTUE9TVCcsXG4gICAgJ0FVVEhPUicsXG4gICAgJ0FVVE8nLFxuICAgICdBVVRPUycsXG4gICAgJ0FWSUFOQ0EnLFxuICAgICdBVycsXG4gICAgJ0FXUycsXG4gICAgJ0FYJyxcbiAgICAnQVhBJyxcbiAgICAnQVonLFxuICAgICdBWlVSRScsXG4gICAgJ0JBJyxcbiAgICAnQkFCWScsXG4gICAgJ0JBSURVJyxcbiAgICAnQkFOQU1FWCcsXG4gICAgJ0JBTkFOQVJFUFVCTElDJyxcbiAgICAnQkFORCcsXG4gICAgJ0JBTksnLFxuICAgICdCQVInLFxuICAgICdCQVJDRUxPTkEnLFxuICAgICdCQVJDTEFZQ0FSRCcsXG4gICAgJ0JBUkNMQVlTJyxcbiAgICAnQkFSRUZPT1QnLFxuICAgICdCQVJHQUlOUycsXG4gICAgJ0JBU0VCQUxMJyxcbiAgICAnQkFTS0VUQkFMTCcsXG4gICAgJ0JBVUhBVVMnLFxuICAgICdCQVlFUk4nLFxuICAgICdCQicsXG4gICAgJ0JCQycsXG4gICAgJ0JCVCcsXG4gICAgJ0JCVkEnLFxuICAgICdCQ0cnLFxuICAgICdCQ04nLFxuICAgICdCRCcsXG4gICAgJ0JFJyxcbiAgICAnQkVBVFMnLFxuICAgICdCRUFVVFknLFxuICAgICdCRUVSJyxcbiAgICAnQkVOVExFWScsXG4gICAgJ0JFUkxJTicsXG4gICAgJ0JFU1QnLFxuICAgICdCRVNUQlVZJyxcbiAgICAnQkVUJyxcbiAgICAnQkYnLFxuICAgICdCRycsXG4gICAgJ0JIJyxcbiAgICAnQkhBUlRJJyxcbiAgICAnQkknLFxuICAgICdCSUJMRScsXG4gICAgJ0JJRCcsXG4gICAgJ0JJS0UnLFxuICAgICdCSU5HJyxcbiAgICAnQklOR08nLFxuICAgICdCSU8nLFxuICAgICdCSVonLFxuICAgICdCSicsXG4gICAgJ0JMQUNLJyxcbiAgICAnQkxBQ0tGUklEQVknLFxuICAgICdCTE9DS0JVU1RFUicsXG4gICAgJ0JMT0cnLFxuICAgICdCTE9PTUJFUkcnLFxuICAgICdCTFVFJyxcbiAgICAnQk0nLFxuICAgICdCTVMnLFxuICAgICdCTVcnLFxuICAgICdCTicsXG4gICAgJ0JOUFBBUklCQVMnLFxuICAgICdCTycsXG4gICAgJ0JPQVRTJyxcbiAgICAnQk9FSFJJTkdFUicsXG4gICAgJ0JPRkEnLFxuICAgICdCT00nLFxuICAgICdCT05EJyxcbiAgICAnQk9PJyxcbiAgICAnQk9PSycsXG4gICAgJ0JPT0tJTkcnLFxuICAgICdCT1NDSCcsXG4gICAgJ0JPU1RJSycsXG4gICAgJ0JPU1RPTicsXG4gICAgJ0JPVCcsXG4gICAgJ0JPVVRJUVVFJyxcbiAgICAnQk9YJyxcbiAgICAnQlInLFxuICAgICdCUkFERVNDTycsXG4gICAgJ0JSSURHRVNUT05FJyxcbiAgICAnQlJPQURXQVknLFxuICAgICdCUk9LRVInLFxuICAgICdCUk9USEVSJyxcbiAgICAnQlJVU1NFTFMnLFxuICAgICdCUycsXG4gICAgJ0JUJyxcbiAgICAnQlVHQVRUSScsXG4gICAgJ0JVSUxEJyxcbiAgICAnQlVJTERFUlMnLFxuICAgICdCVVNJTkVTUycsXG4gICAgJ0JVWScsXG4gICAgJ0JVWlonLFxuICAgICdCVicsXG4gICAgJ0JXJyxcbiAgICAnQlknLFxuICAgICdCWicsXG4gICAgJ0JaSCcsXG4gICAgJ0NBJyxcbiAgICAnQ0FCJyxcbiAgICAnQ0FGRScsXG4gICAgJ0NBTCcsXG4gICAgJ0NBTEwnLFxuICAgICdDQUxWSU5LTEVJTicsXG4gICAgJ0NBTScsXG4gICAgJ0NBTUVSQScsXG4gICAgJ0NBTVAnLFxuICAgICdDQU5DRVJSRVNFQVJDSCcsXG4gICAgJ0NBTk9OJyxcbiAgICAnQ0FQRVRPV04nLFxuICAgICdDQVBJVEFMJyxcbiAgICAnQ0FQSVRBTE9ORScsXG4gICAgJ0NBUicsXG4gICAgJ0NBUkFWQU4nLFxuICAgICdDQVJEUycsXG4gICAgJ0NBUkUnLFxuICAgICdDQVJFRVInLFxuICAgICdDQVJFRVJTJyxcbiAgICAnQ0FSUycsXG4gICAgJ0NBU0EnLFxuICAgICdDQVNFJyxcbiAgICAnQ0FTSCcsXG4gICAgJ0NBU0lOTycsXG4gICAgJ0NBVCcsXG4gICAgJ0NBVEVSSU5HJyxcbiAgICAnQ0FUSE9MSUMnLFxuICAgICdDQkEnLFxuICAgICdDQk4nLFxuICAgICdDQlJFJyxcbiAgICAnQ0JTJyxcbiAgICAnQ0MnLFxuICAgICdDRCcsXG4gICAgJ0NFTlRFUicsXG4gICAgJ0NFTycsXG4gICAgJ0NFUk4nLFxuICAgICdDRicsXG4gICAgJ0NGQScsXG4gICAgJ0NGRCcsXG4gICAgJ0NHJyxcbiAgICAnQ0gnLFxuICAgICdDSEFORUwnLFxuICAgICdDSEFOTkVMJyxcbiAgICAnQ0hBUklUWScsXG4gICAgJ0NIQVNFJyxcbiAgICAnQ0hBVCcsXG4gICAgJ0NIRUFQJyxcbiAgICAnQ0hJTlRBSScsXG4gICAgJ0NIUklTVE1BUycsXG4gICAgJ0NIUk9NRScsXG4gICAgJ0NIVVJDSCcsXG4gICAgJ0NJJyxcbiAgICAnQ0lQUklBTkknLFxuICAgICdDSVJDTEUnLFxuICAgICdDSVNDTycsXG4gICAgJ0NJVEFERUwnLFxuICAgICdDSVRJJyxcbiAgICAnQ0lUSUMnLFxuICAgICdDSVRZJyxcbiAgICAnQ0lUWUVBVFMnLFxuICAgICdDSycsXG4gICAgJ0NMJyxcbiAgICAnQ0xBSU1TJyxcbiAgICAnQ0xFQU5JTkcnLFxuICAgICdDTElDSycsXG4gICAgJ0NMSU5JQycsXG4gICAgJ0NMSU5JUVVFJyxcbiAgICAnQ0xPVEhJTkcnLFxuICAgICdDTE9VRCcsXG4gICAgJ0NMVUInLFxuICAgICdDTFVCTUVEJyxcbiAgICAnQ00nLFxuICAgICdDTicsXG4gICAgJ0NPJyxcbiAgICAnQ09BQ0gnLFxuICAgICdDT0RFUycsXG4gICAgJ0NPRkZFRScsXG4gICAgJ0NPTExFR0UnLFxuICAgICdDT0xPR05FJyxcbiAgICAnQ09NJyxcbiAgICAnQ09NQ0FTVCcsXG4gICAgJ0NPTU1CQU5LJyxcbiAgICAnQ09NTVVOSVRZJyxcbiAgICAnQ09NUEFOWScsXG4gICAgJ0NPTVBBUkUnLFxuICAgICdDT01QVVRFUicsXG4gICAgJ0NPTVNFQycsXG4gICAgJ0NPTkRPUycsXG4gICAgJ0NPTlNUUlVDVElPTicsXG4gICAgJ0NPTlNVTFRJTkcnLFxuICAgICdDT05UQUNUJyxcbiAgICAnQ09OVFJBQ1RPUlMnLFxuICAgICdDT09LSU5HJyxcbiAgICAnQ09PS0lOR0NIQU5ORUwnLFxuICAgICdDT09MJyxcbiAgICAnQ09PUCcsXG4gICAgJ0NPUlNJQ0EnLFxuICAgICdDT1VOVFJZJyxcbiAgICAnQ09VUE9OJyxcbiAgICAnQ09VUE9OUycsXG4gICAgJ0NPVVJTRVMnLFxuICAgICdDUEEnLFxuICAgICdDUicsXG4gICAgJ0NSRURJVCcsXG4gICAgJ0NSRURJVENBUkQnLFxuICAgICdDUkVESVRVTklPTicsXG4gICAgJ0NSSUNLRVQnLFxuICAgICdDUk9XTicsXG4gICAgJ0NSUycsXG4gICAgJ0NSVUlTRScsXG4gICAgJ0NSVUlTRVMnLFxuICAgICdDVScsXG4gICAgJ0NVSVNJTkVMTEEnLFxuICAgICdDVicsXG4gICAgJ0NXJyxcbiAgICAnQ1gnLFxuICAgICdDWScsXG4gICAgJ0NZTVJVJyxcbiAgICAnQ1lPVScsXG4gICAgJ0NaJyxcbiAgICAnREFCVVInLFxuICAgICdEQUQnLFxuICAgICdEQU5DRScsXG4gICAgJ0RBVEEnLFxuICAgICdEQVRFJyxcbiAgICAnREFUSU5HJyxcbiAgICAnREFUU1VOJyxcbiAgICAnREFZJyxcbiAgICAnRENMSycsXG4gICAgJ0REUycsXG4gICAgJ0RFJyxcbiAgICAnREVBTCcsXG4gICAgJ0RFQUxFUicsXG4gICAgJ0RFQUxTJyxcbiAgICAnREVHUkVFJyxcbiAgICAnREVMSVZFUlknLFxuICAgICdERUxMJyxcbiAgICAnREVMT0lUVEUnLFxuICAgICdERUxUQScsXG4gICAgJ0RFTU9DUkFUJyxcbiAgICAnREVOVEFMJyxcbiAgICAnREVOVElTVCcsXG4gICAgJ0RFU0knLFxuICAgICdERVNJR04nLFxuICAgICdERVYnLFxuICAgICdESEwnLFxuICAgICdESUFNT05EUycsXG4gICAgJ0RJRVQnLFxuICAgICdESUdJVEFMJyxcbiAgICAnRElSRUNUJyxcbiAgICAnRElSRUNUT1JZJyxcbiAgICAnRElTQ09VTlQnLFxuICAgICdESVNDT1ZFUicsXG4gICAgJ0RJU0gnLFxuICAgICdESVknLFxuICAgICdESicsXG4gICAgJ0RLJyxcbiAgICAnRE0nLFxuICAgICdETlAnLFxuICAgICdETycsXG4gICAgJ0RPQ1MnLFxuICAgICdET0NUT1InLFxuICAgICdET0cnLFxuICAgICdET01BSU5TJyxcbiAgICAnRE9UJyxcbiAgICAnRE9XTkxPQUQnLFxuICAgICdEUklWRScsXG4gICAgJ0RUVicsXG4gICAgJ0RVQkFJJyxcbiAgICAnRFVOTE9QJyxcbiAgICAnRFVQT05UJyxcbiAgICAnRFVSQkFOJyxcbiAgICAnRFZBRycsXG4gICAgJ0RWUicsXG4gICAgJ0RaJyxcbiAgICAnRUFSVEgnLFxuICAgICdFQVQnLFxuICAgICdFQycsXG4gICAgJ0VDTycsXG4gICAgJ0VERUtBJyxcbiAgICAnRURVJyxcbiAgICAnRURVQ0FUSU9OJyxcbiAgICAnRUUnLFxuICAgICdFRycsXG4gICAgJ0VNQUlMJyxcbiAgICAnRU1FUkNLJyxcbiAgICAnRU5FUkdZJyxcbiAgICAnRU5HSU5FRVInLFxuICAgICdFTkdJTkVFUklORycsXG4gICAgJ0VOVEVSUFJJU0VTJyxcbiAgICAnRVBTT04nLFxuICAgICdFUVVJUE1FTlQnLFxuICAgICdFUicsXG4gICAgJ0VSSUNTU09OJyxcbiAgICAnRVJOSScsXG4gICAgJ0VTJyxcbiAgICAnRVNRJyxcbiAgICAnRVNUQVRFJyxcbiAgICAnRVQnLFxuICAgICdFVElTQUxBVCcsXG4gICAgJ0VVJyxcbiAgICAnRVVST1ZJU0lPTicsXG4gICAgJ0VVUycsXG4gICAgJ0VWRU5UUycsXG4gICAgJ0VYQ0hBTkdFJyxcbiAgICAnRVhQRVJUJyxcbiAgICAnRVhQT1NFRCcsXG4gICAgJ0VYUFJFU1MnLFxuICAgICdFWFRSQVNQQUNFJyxcbiAgICAnRkFHRScsXG4gICAgJ0ZBSUwnLFxuICAgICdGQUlSV0lORFMnLFxuICAgICdGQUlUSCcsXG4gICAgJ0ZBTUlMWScsXG4gICAgJ0ZBTicsXG4gICAgJ0ZBTlMnLFxuICAgICdGQVJNJyxcbiAgICAnRkFSTUVSUycsXG4gICAgJ0ZBU0hJT04nLFxuICAgICdGQVNUJyxcbiAgICAnRkVERVgnLFxuICAgICdGRUVEQkFDSycsXG4gICAgJ0ZFUlJBUkknLFxuICAgICdGRVJSRVJPJyxcbiAgICAnRkknLFxuICAgICdGSUFUJyxcbiAgICAnRklERUxJVFknLFxuICAgICdGSURPJyxcbiAgICAnRklMTScsXG4gICAgJ0ZJTkFMJyxcbiAgICAnRklOQU5DRScsXG4gICAgJ0ZJTkFOQ0lBTCcsXG4gICAgJ0ZJUkUnLFxuICAgICdGSVJFU1RPTkUnLFxuICAgICdGSVJNREFMRScsXG4gICAgJ0ZJU0gnLFxuICAgICdGSVNISU5HJyxcbiAgICAnRklUJyxcbiAgICAnRklUTkVTUycsXG4gICAgJ0ZKJyxcbiAgICAnRksnLFxuICAgICdGTElDS1InLFxuICAgICdGTElHSFRTJyxcbiAgICAnRkxJUicsXG4gICAgJ0ZMT1JJU1QnLFxuICAgICdGTE9XRVJTJyxcbiAgICAnRkxZJyxcbiAgICAnRk0nLFxuICAgICdGTycsXG4gICAgJ0ZPTycsXG4gICAgJ0ZPT0QnLFxuICAgICdGT09ETkVUV09SSycsXG4gICAgJ0ZPT1RCQUxMJyxcbiAgICAnRk9SRCcsXG4gICAgJ0ZPUkVYJyxcbiAgICAnRk9SU0FMRScsXG4gICAgJ0ZPUlVNJyxcbiAgICAnRk9VTkRBVElPTicsXG4gICAgJ0ZPWCcsXG4gICAgJ0ZSJyxcbiAgICAnRlJFRScsXG4gICAgJ0ZSRVNFTklVUycsXG4gICAgJ0ZSTCcsXG4gICAgJ0ZST0dBTlMnLFxuICAgICdGUk9OVERPT1InLFxuICAgICdGUk9OVElFUicsXG4gICAgJ0ZUUicsXG4gICAgJ0ZVSklUU1UnLFxuICAgICdGVU4nLFxuICAgICdGVU5EJyxcbiAgICAnRlVSTklUVVJFJyxcbiAgICAnRlVUQk9MJyxcbiAgICAnRllJJyxcbiAgICAnR0EnLFxuICAgICdHQUwnLFxuICAgICdHQUxMRVJZJyxcbiAgICAnR0FMTE8nLFxuICAgICdHQUxMVVAnLFxuICAgICdHQU1FJyxcbiAgICAnR0FNRVMnLFxuICAgICdHQVAnLFxuICAgICdHQVJERU4nLFxuICAgICdHQVknLFxuICAgICdHQicsXG4gICAgJ0dCSVonLFxuICAgICdHRCcsXG4gICAgJ0dETicsXG4gICAgJ0dFJyxcbiAgICAnR0VBJyxcbiAgICAnR0VOVCcsXG4gICAgJ0dFTlRJTkcnLFxuICAgICdHRU9SR0UnLFxuICAgICdHRicsXG4gICAgJ0dHJyxcbiAgICAnR0dFRScsXG4gICAgJ0dIJyxcbiAgICAnR0knLFxuICAgICdHSUZUJyxcbiAgICAnR0lGVFMnLFxuICAgICdHSVZFUycsXG4gICAgJ0dJVklORycsXG4gICAgJ0dMJyxcbiAgICAnR0xBU1MnLFxuICAgICdHTEUnLFxuICAgICdHTE9CQUwnLFxuICAgICdHTE9CTycsXG4gICAgJ0dNJyxcbiAgICAnR01BSUwnLFxuICAgICdHTUJIJyxcbiAgICAnR01PJyxcbiAgICAnR01YJyxcbiAgICAnR04nLFxuICAgICdHT0RBRERZJyxcbiAgICAnR09MRCcsXG4gICAgJ0dPTERQT0lOVCcsXG4gICAgJ0dPTEYnLFxuICAgICdHT08nLFxuICAgICdHT09EWUVBUicsXG4gICAgJ0dPT0cnLFxuICAgICdHT09HTEUnLFxuICAgICdHT1AnLFxuICAgICdHT1QnLFxuICAgICdHT1YnLFxuICAgICdHUCcsXG4gICAgJ0dRJyxcbiAgICAnR1InLFxuICAgICdHUkFJTkdFUicsXG4gICAgJ0dSQVBISUNTJyxcbiAgICAnR1JBVElTJyxcbiAgICAnR1JFRU4nLFxuICAgICdHUklQRScsXG4gICAgJ0dST0NFUlknLFxuICAgICdHUk9VUCcsXG4gICAgJ0dTJyxcbiAgICAnR1QnLFxuICAgICdHVScsXG4gICAgJ0dVQVJESUFOJyxcbiAgICAnR1VDQ0knLFxuICAgICdHVUdFJyxcbiAgICAnR1VJREUnLFxuICAgICdHVUlUQVJTJyxcbiAgICAnR1VSVScsXG4gICAgJ0dXJyxcbiAgICAnR1knLFxuICAgICdIQUlSJyxcbiAgICAnSEFNQlVSRycsXG4gICAgJ0hBTkdPVVQnLFxuICAgICdIQVVTJyxcbiAgICAnSEJPJyxcbiAgICAnSERGQycsXG4gICAgJ0hERkNCQU5LJyxcbiAgICAnSEVBTFRIJyxcbiAgICAnSEVBTFRIQ0FSRScsXG4gICAgJ0hFTFAnLFxuICAgICdIRUxTSU5LSScsXG4gICAgJ0hFUkUnLFxuICAgICdIRVJNRVMnLFxuICAgICdIR1RWJyxcbiAgICAnSElQSE9QJyxcbiAgICAnSElTQU1JVFNVJyxcbiAgICAnSElUQUNISScsXG4gICAgJ0hJVicsXG4gICAgJ0hLJyxcbiAgICAnSEtUJyxcbiAgICAnSE0nLFxuICAgICdITicsXG4gICAgJ0hPQ0tFWScsXG4gICAgJ0hPTERJTkdTJyxcbiAgICAnSE9MSURBWScsXG4gICAgJ0hPTUVERVBPVCcsXG4gICAgJ0hPTUVHT09EUycsXG4gICAgJ0hPTUVTJyxcbiAgICAnSE9NRVNFTlNFJyxcbiAgICAnSE9OREEnLFxuICAgICdIT1JTRScsXG4gICAgJ0hPU1BJVEFMJyxcbiAgICAnSE9TVCcsXG4gICAgJ0hPU1RJTkcnLFxuICAgICdIT1QnLFxuICAgICdIT1RFTEVTJyxcbiAgICAnSE9URUxTJyxcbiAgICAnSE9UTUFJTCcsXG4gICAgJ0hPVVNFJyxcbiAgICAnSE9XJyxcbiAgICAnSFInLFxuICAgICdIU0JDJyxcbiAgICAnSFQnLFxuICAgICdIVScsXG4gICAgJ0hVR0hFUycsXG4gICAgJ0hZQVRUJyxcbiAgICAnSFlVTkRBSScsXG4gICAgJ0lCTScsXG4gICAgJ0lDQkMnLFxuICAgICdJQ0UnLFxuICAgICdJQ1UnLFxuICAgICdJRCcsXG4gICAgJ0lFJyxcbiAgICAnSUVFRScsXG4gICAgJ0lGTScsXG4gICAgJ0lLQU5PJyxcbiAgICAnSUwnLFxuICAgICdJTScsXG4gICAgJ0lNQU1BVCcsXG4gICAgJ0lNREInLFxuICAgICdJTU1PJyxcbiAgICAnSU1NT0JJTElFTicsXG4gICAgJ0lOJyxcbiAgICAnSU5DJyxcbiAgICAnSU5EVVNUUklFUycsXG4gICAgJ0lORklOSVRJJyxcbiAgICAnSU5GTycsXG4gICAgJ0lORycsXG4gICAgJ0lOSycsXG4gICAgJ0lOU1RJVFVURScsXG4gICAgJ0lOU1VSQU5DRScsXG4gICAgJ0lOU1VSRScsXG4gICAgJ0lOVCcsXG4gICAgJ0lOVEVSTkFUSU9OQUwnLFxuICAgICdJTlRVSVQnLFxuICAgICdJTlZFU1RNRU5UUycsXG4gICAgJ0lPJyxcbiAgICAnSVBJUkFOR0EnLFxuICAgICdJUScsXG4gICAgJ0lSJyxcbiAgICAnSVJJU0gnLFxuICAgICdJUycsXG4gICAgJ0lTTUFJTEknLFxuICAgICdJU1QnLFxuICAgICdJU1RBTkJVTCcsXG4gICAgJ0lUJyxcbiAgICAnSVRBVScsXG4gICAgJ0lUVicsXG4gICAgJ0pBR1VBUicsXG4gICAgJ0pBVkEnLFxuICAgICdKQ0InLFxuICAgICdKRScsXG4gICAgJ0pFRVAnLFxuICAgICdKRVRaVCcsXG4gICAgJ0pFV0VMUlknLFxuICAgICdKSU8nLFxuICAgICdKTEwnLFxuICAgICdKTScsXG4gICAgJ0pNUCcsXG4gICAgJ0pOSicsXG4gICAgJ0pPJyxcbiAgICAnSk9CUycsXG4gICAgJ0pPQlVSRycsXG4gICAgJ0pPVCcsXG4gICAgJ0pPWScsXG4gICAgJ0pQJyxcbiAgICAnSlBNT1JHQU4nLFxuICAgICdKUFJTJyxcbiAgICAnSlVFR09TJyxcbiAgICAnSlVOSVBFUicsXG4gICAgJ0tBVUZFTicsXG4gICAgJ0tEREknLFxuICAgICdLRScsXG4gICAgJ0tFUlJZSE9URUxTJyxcbiAgICAnS0VSUllMT0dJU1RJQ1MnLFxuICAgICdLRVJSWVBST1BFUlRJRVMnLFxuICAgICdLRkgnLFxuICAgICdLRycsXG4gICAgJ0tIJyxcbiAgICAnS0knLFxuICAgICdLSUEnLFxuICAgICdLSU0nLFxuICAgICdLSU5ERVInLFxuICAgICdLSU5ETEUnLFxuICAgICdLSVRDSEVOJyxcbiAgICAnS0lXSScsXG4gICAgJ0tNJyxcbiAgICAnS04nLFxuICAgICdLT0VMTicsXG4gICAgJ0tPTUFUU1UnLFxuICAgICdLT1NIRVInLFxuICAgICdLUCcsXG4gICAgJ0tQTUcnLFxuICAgICdLUE4nLFxuICAgICdLUicsXG4gICAgJ0tSRCcsXG4gICAgJ0tSRUQnLFxuICAgICdLVU9LR1JPVVAnLFxuICAgICdLVycsXG4gICAgJ0tZJyxcbiAgICAnS1lPVE8nLFxuICAgICdLWicsXG4gICAgJ0xBJyxcbiAgICAnTEFDQUlYQScsXG4gICAgJ0xBTUJPUkdISU5JJyxcbiAgICAnTEFNRVInLFxuICAgICdMQU5DQVNURVInLFxuICAgICdMQU5DSUEnLFxuICAgICdMQU5EJyxcbiAgICAnTEFORFJPVkVSJyxcbiAgICAnTEFOWEVTUycsXG4gICAgJ0xBU0FMTEUnLFxuICAgICdMQVQnLFxuICAgICdMQVRJTk8nLFxuICAgICdMQVRST0JFJyxcbiAgICAnTEFXJyxcbiAgICAnTEFXWUVSJyxcbiAgICAnTEInLFxuICAgICdMQycsXG4gICAgJ0xEUycsXG4gICAgJ0xFQVNFJyxcbiAgICAnTEVDTEVSQycsXG4gICAgJ0xFRlJBSycsXG4gICAgJ0xFR0FMJyxcbiAgICAnTEVHTycsXG4gICAgJ0xFWFVTJyxcbiAgICAnTEdCVCcsXG4gICAgJ0xJJyxcbiAgICAnTElETCcsXG4gICAgJ0xJRkUnLFxuICAgICdMSUZFSU5TVVJBTkNFJyxcbiAgICAnTElGRVNUWUxFJyxcbiAgICAnTElHSFRJTkcnLFxuICAgICdMSUtFJyxcbiAgICAnTElMTFknLFxuICAgICdMSU1JVEVEJyxcbiAgICAnTElNTycsXG4gICAgJ0xJTkNPTE4nLFxuICAgICdMSU5ERScsXG4gICAgJ0xJTksnLFxuICAgICdMSVBTWScsXG4gICAgJ0xJVkUnLFxuICAgICdMSVZJTkcnLFxuICAgICdMSycsXG4gICAgJ0xMQycsXG4gICAgJ0xMUCcsXG4gICAgJ0xPQU4nLFxuICAgICdMT0FOUycsXG4gICAgJ0xPQ0tFUicsXG4gICAgJ0xPQ1VTJyxcbiAgICAnTE9GVCcsXG4gICAgJ0xPTCcsXG4gICAgJ0xPTkRPTicsXG4gICAgJ0xPVFRFJyxcbiAgICAnTE9UVE8nLFxuICAgICdMT1ZFJyxcbiAgICAnTFBMJyxcbiAgICAnTFBMRklOQU5DSUFMJyxcbiAgICAnTFInLFxuICAgICdMUycsXG4gICAgJ0xUJyxcbiAgICAnTFREJyxcbiAgICAnTFREQScsXG4gICAgJ0xVJyxcbiAgICAnTFVOREJFQ0snLFxuICAgICdMVVhFJyxcbiAgICAnTFVYVVJZJyxcbiAgICAnTFYnLFxuICAgICdMWScsXG4gICAgJ01BJyxcbiAgICAnTUFDWVMnLFxuICAgICdNQURSSUQnLFxuICAgICdNQUlGJyxcbiAgICAnTUFJU09OJyxcbiAgICAnTUFLRVVQJyxcbiAgICAnTUFOJyxcbiAgICAnTUFOQUdFTUVOVCcsXG4gICAgJ01BTkdPJyxcbiAgICAnTUFQJyxcbiAgICAnTUFSS0VUJyxcbiAgICAnTUFSS0VUSU5HJyxcbiAgICAnTUFSS0VUUycsXG4gICAgJ01BUlJJT1RUJyxcbiAgICAnTUFSU0hBTExTJyxcbiAgICAnTUFTRVJBVEknLFxuICAgICdNQVRURUwnLFxuICAgICdNQkEnLFxuICAgICdNQycsXG4gICAgJ01DS0lOU0VZJyxcbiAgICAnTUQnLFxuICAgICdNRScsXG4gICAgJ01FRCcsXG4gICAgJ01FRElBJyxcbiAgICAnTUVFVCcsXG4gICAgJ01FTEJPVVJORScsXG4gICAgJ01FTUUnLFxuICAgICdNRU1PUklBTCcsXG4gICAgJ01FTicsXG4gICAgJ01FTlUnLFxuICAgICdNRVJDS01TRCcsXG4gICAgJ01HJyxcbiAgICAnTUgnLFxuICAgICdNSUFNSScsXG4gICAgJ01JQ1JPU09GVCcsXG4gICAgJ01JTCcsXG4gICAgJ01JTkknLFxuICAgICdNSU5UJyxcbiAgICAnTUlUJyxcbiAgICAnTUlUU1VCSVNISScsXG4gICAgJ01LJyxcbiAgICAnTUwnLFxuICAgICdNTEInLFxuICAgICdNTFMnLFxuICAgICdNTScsXG4gICAgJ01NQScsXG4gICAgJ01OJyxcbiAgICAnTU8nLFxuICAgICdNT0JJJyxcbiAgICAnTU9CSUxFJyxcbiAgICAnTU9EQScsXG4gICAgJ01PRScsXG4gICAgJ01PSScsXG4gICAgJ01PTScsXG4gICAgJ01PTkFTSCcsXG4gICAgJ01PTkVZJyxcbiAgICAnTU9OU1RFUicsXG4gICAgJ01PUk1PTicsXG4gICAgJ01PUlRHQUdFJyxcbiAgICAnTU9TQ09XJyxcbiAgICAnTU9UTycsXG4gICAgJ01PVE9SQ1lDTEVTJyxcbiAgICAnTU9WJyxcbiAgICAnTU9WSUUnLFxuICAgICdNUCcsXG4gICAgJ01RJyxcbiAgICAnTVInLFxuICAgICdNUycsXG4gICAgJ01TRCcsXG4gICAgJ01UJyxcbiAgICAnTVROJyxcbiAgICAnTVRSJyxcbiAgICAnTVUnLFxuICAgICdNVVNFVU0nLFxuICAgICdNVVNJQycsXG4gICAgJ01VVFVBTCcsXG4gICAgJ01WJyxcbiAgICAnTVcnLFxuICAgICdNWCcsXG4gICAgJ01ZJyxcbiAgICAnTVonLFxuICAgICdOQScsXG4gICAgJ05BQicsXG4gICAgJ05BR09ZQScsXG4gICAgJ05BTUUnLFxuICAgICdOQVRVUkEnLFxuICAgICdOQVZZJyxcbiAgICAnTkJBJyxcbiAgICAnTkMnLFxuICAgICdORScsXG4gICAgJ05FQycsXG4gICAgJ05FVCcsXG4gICAgJ05FVEJBTksnLFxuICAgICdORVRGTElYJyxcbiAgICAnTkVUV09SSycsXG4gICAgJ05FVVNUQVInLFxuICAgICdORVcnLFxuICAgICdORVdTJyxcbiAgICAnTkVYVCcsXG4gICAgJ05FWFRESVJFQ1QnLFxuICAgICdORVhVUycsXG4gICAgJ05GJyxcbiAgICAnTkZMJyxcbiAgICAnTkcnLFxuICAgICdOR08nLFxuICAgICdOSEsnLFxuICAgICdOSScsXG4gICAgJ05JQ08nLFxuICAgICdOSUtFJyxcbiAgICAnTklLT04nLFxuICAgICdOSU5KQScsXG4gICAgJ05JU1NBTicsXG4gICAgJ05JU1NBWScsXG4gICAgJ05MJyxcbiAgICAnTk8nLFxuICAgICdOT0tJQScsXG4gICAgJ05PUlRIV0VTVEVSTk1VVFVBTCcsXG4gICAgJ05PUlRPTicsXG4gICAgJ05PVycsXG4gICAgJ05PV1JVWicsXG4gICAgJ05PV1RWJyxcbiAgICAnTlAnLFxuICAgICdOUicsXG4gICAgJ05SQScsXG4gICAgJ05SVycsXG4gICAgJ05UVCcsXG4gICAgJ05VJyxcbiAgICAnTllDJyxcbiAgICAnTlonLFxuICAgICdPQkknLFxuICAgICdPQlNFUlZFUicsXG4gICAgJ09GRklDRScsXG4gICAgJ09LSU5BV0EnLFxuICAgICdPTEFZQU4nLFxuICAgICdPTEFZQU5HUk9VUCcsXG4gICAgJ09MRE5BVlknLFxuICAgICdPTExPJyxcbiAgICAnT00nLFxuICAgICdPTUVHQScsXG4gICAgJ09ORScsXG4gICAgJ09ORycsXG4gICAgJ09OTCcsXG4gICAgJ09OTElORScsXG4gICAgJ09PTycsXG4gICAgJ09QRU4nLFxuICAgICdPUkFDTEUnLFxuICAgICdPUkFOR0UnLFxuICAgICdPUkcnLFxuICAgICdPUkdBTklDJyxcbiAgICAnT1JJR0lOUycsXG4gICAgJ09TQUtBJyxcbiAgICAnT1RTVUtBJyxcbiAgICAnT1RUJyxcbiAgICAnT1ZIJyxcbiAgICAnUEEnLFxuICAgICdQQUdFJyxcbiAgICAnUEFOQVNPTklDJyxcbiAgICAnUEFSSVMnLFxuICAgICdQQVJTJyxcbiAgICAnUEFSVE5FUlMnLFxuICAgICdQQVJUUycsXG4gICAgJ1BBUlRZJyxcbiAgICAnUEFTU0FHRU5TJyxcbiAgICAnUEFZJyxcbiAgICAnUENDVycsXG4gICAgJ1BFJyxcbiAgICAnUEVUJyxcbiAgICAnUEYnLFxuICAgICdQRklaRVInLFxuICAgICdQRycsXG4gICAgJ1BIJyxcbiAgICAnUEhBUk1BQ1knLFxuICAgICdQSEQnLFxuICAgICdQSElMSVBTJyxcbiAgICAnUEhPTkUnLFxuICAgICdQSE9UTycsXG4gICAgJ1BIT1RPR1JBUEhZJyxcbiAgICAnUEhPVE9TJyxcbiAgICAnUEhZU0lPJyxcbiAgICAnUElDUycsXG4gICAgJ1BJQ1RFVCcsXG4gICAgJ1BJQ1RVUkVTJyxcbiAgICAnUElEJyxcbiAgICAnUElOJyxcbiAgICAnUElORycsXG4gICAgJ1BJTksnLFxuICAgICdQSU9ORUVSJyxcbiAgICAnUElaWkEnLFxuICAgICdQSycsXG4gICAgJ1BMJyxcbiAgICAnUExBQ0UnLFxuICAgICdQTEFZJyxcbiAgICAnUExBWVNUQVRJT04nLFxuICAgICdQTFVNQklORycsXG4gICAgJ1BMVVMnLFxuICAgICdQTScsXG4gICAgJ1BOJyxcbiAgICAnUE5DJyxcbiAgICAnUE9ITCcsXG4gICAgJ1BPS0VSJyxcbiAgICAnUE9MSVRJRScsXG4gICAgJ1BPUk4nLFxuICAgICdQT1NUJyxcbiAgICAnUFInLFxuICAgICdQUkFNRVJJQ0EnLFxuICAgICdQUkFYSScsXG4gICAgJ1BSRVNTJyxcbiAgICAnUFJJTUUnLFxuICAgICdQUk8nLFxuICAgICdQUk9EJyxcbiAgICAnUFJPRFVDVElPTlMnLFxuICAgICdQUk9GJyxcbiAgICAnUFJPR1JFU1NJVkUnLFxuICAgICdQUk9NTycsXG4gICAgJ1BST1BFUlRJRVMnLFxuICAgICdQUk9QRVJUWScsXG4gICAgJ1BST1RFQ1RJT04nLFxuICAgICdQUlUnLFxuICAgICdQUlVERU5USUFMJyxcbiAgICAnUFMnLFxuICAgICdQVCcsXG4gICAgJ1BVQicsXG4gICAgJ1BXJyxcbiAgICAnUFdDJyxcbiAgICAnUFknLFxuICAgICdRQScsXG4gICAgJ1FQT04nLFxuICAgICdRVUVCRUMnLFxuICAgICdRVUVTVCcsXG4gICAgJ1JBQ0lORycsXG4gICAgJ1JBRElPJyxcbiAgICAnUkUnLFxuICAgICdSRUFEJyxcbiAgICAnUkVBTEVTVEFURScsXG4gICAgJ1JFQUxUT1InLFxuICAgICdSRUFMVFknLFxuICAgICdSRUNJUEVTJyxcbiAgICAnUkVEJyxcbiAgICAnUkVEU1RPTkUnLFxuICAgICdSRURVTUJSRUxMQScsXG4gICAgJ1JFSEFCJyxcbiAgICAnUkVJU0UnLFxuICAgICdSRUlTRU4nLFxuICAgICdSRUlUJyxcbiAgICAnUkVMSUFOQ0UnLFxuICAgICdSRU4nLFxuICAgICdSRU5UJyxcbiAgICAnUkVOVEFMUycsXG4gICAgJ1JFUEFJUicsXG4gICAgJ1JFUE9SVCcsXG4gICAgJ1JFUFVCTElDQU4nLFxuICAgICdSRVNUJyxcbiAgICAnUkVTVEFVUkFOVCcsXG4gICAgJ1JFVklFVycsXG4gICAgJ1JFVklFV1MnLFxuICAgICdSRVhST1RIJyxcbiAgICAnUklDSCcsXG4gICAgJ1JJQ0hBUkRMSScsXG4gICAgJ1JJQ09IJyxcbiAgICAnUklMJyxcbiAgICAnUklPJyxcbiAgICAnUklQJyxcbiAgICAnUk8nLFxuICAgICdST0NIRVInLFxuICAgICdST0NLUycsXG4gICAgJ1JPREVPJyxcbiAgICAnUk9HRVJTJyxcbiAgICAnUk9PTScsXG4gICAgJ1JTJyxcbiAgICAnUlNWUCcsXG4gICAgJ1JVJyxcbiAgICAnUlVHQlknLFxuICAgICdSVUhSJyxcbiAgICAnUlVOJyxcbiAgICAnUlcnLFxuICAgICdSV0UnLFxuICAgICdSWVVLWVUnLFxuICAgICdTQScsXG4gICAgJ1NBQVJMQU5EJyxcbiAgICAnU0FGRScsXG4gICAgJ1NBRkVUWScsXG4gICAgJ1NBS1VSQScsXG4gICAgJ1NBTEUnLFxuICAgICdTQUxPTicsXG4gICAgJ1NBTVNDTFVCJyxcbiAgICAnU0FNU1VORycsXG4gICAgJ1NBTkRWSUsnLFxuICAgICdTQU5EVklLQ09ST01BTlQnLFxuICAgICdTQU5PRkknLFxuICAgICdTQVAnLFxuICAgICdTQVJMJyxcbiAgICAnU0FTJyxcbiAgICAnU0FWRScsXG4gICAgJ1NBWE8nLFxuICAgICdTQicsXG4gICAgJ1NCSScsXG4gICAgJ1NCUycsXG4gICAgJ1NDJyxcbiAgICAnU0NBJyxcbiAgICAnU0NCJyxcbiAgICAnU0NIQUVGRkxFUicsXG4gICAgJ1NDSE1JRFQnLFxuICAgICdTQ0hPTEFSU0hJUFMnLFxuICAgICdTQ0hPT0wnLFxuICAgICdTQ0hVTEUnLFxuICAgICdTQ0hXQVJaJyxcbiAgICAnU0NJRU5DRScsXG4gICAgJ1NDT1QnLFxuICAgICdTRCcsXG4gICAgJ1NFJyxcbiAgICAnU0VBUkNIJyxcbiAgICAnU0VBVCcsXG4gICAgJ1NFQ1VSRScsXG4gICAgJ1NFQ1VSSVRZJyxcbiAgICAnU0VFSycsXG4gICAgJ1NFTEVDVCcsXG4gICAgJ1NFTkVSJyxcbiAgICAnU0VSVklDRVMnLFxuICAgICdTRVMnLFxuICAgICdTRVZFTicsXG4gICAgJ1NFVycsXG4gICAgJ1NFWCcsXG4gICAgJ1NFWFknLFxuICAgICdTRlInLFxuICAgICdTRycsXG4gICAgJ1NIJyxcbiAgICAnU0hBTkdSSUxBJyxcbiAgICAnU0hBUlAnLFxuICAgICdTSEFXJyxcbiAgICAnU0hFTEwnLFxuICAgICdTSElBJyxcbiAgICAnU0hJS1NIQScsXG4gICAgJ1NIT0VTJyxcbiAgICAnU0hPUCcsXG4gICAgJ1NIT1BQSU5HJyxcbiAgICAnU0hPVUpJJyxcbiAgICAnU0hPVycsXG4gICAgJ1NIT1dUSU1FJyxcbiAgICAnU0knLFxuICAgICdTSUxLJyxcbiAgICAnU0lOQScsXG4gICAgJ1NJTkdMRVMnLFxuICAgICdTSVRFJyxcbiAgICAnU0onLFxuICAgICdTSycsXG4gICAgJ1NLSScsXG4gICAgJ1NLSU4nLFxuICAgICdTS1knLFxuICAgICdTS1lQRScsXG4gICAgJ1NMJyxcbiAgICAnU0xJTkcnLFxuICAgICdTTScsXG4gICAgJ1NNQVJUJyxcbiAgICAnU01JTEUnLFxuICAgICdTTicsXG4gICAgJ1NOQ0YnLFxuICAgICdTTycsXG4gICAgJ1NPQ0NFUicsXG4gICAgJ1NPQ0lBTCcsXG4gICAgJ1NPRlRCQU5LJyxcbiAgICAnU09GVFdBUkUnLFxuICAgICdTT0hVJyxcbiAgICAnU09MQVInLFxuICAgICdTT0xVVElPTlMnLFxuICAgICdTT05HJyxcbiAgICAnU09OWScsXG4gICAgJ1NPWScsXG4gICAgJ1NQQScsXG4gICAgJ1NQQUNFJyxcbiAgICAnU1BPUlQnLFxuICAgICdTUE9UJyxcbiAgICAnU1InLFxuICAgICdTUkwnLFxuICAgICdTUycsXG4gICAgJ1NUJyxcbiAgICAnU1RBREEnLFxuICAgICdTVEFQTEVTJyxcbiAgICAnU1RBUicsXG4gICAgJ1NUQVRFQkFOSycsXG4gICAgJ1NUQVRFRkFSTScsXG4gICAgJ1NUQycsXG4gICAgJ1NUQ0dST1VQJyxcbiAgICAnU1RPQ0tIT0xNJyxcbiAgICAnU1RPUkFHRScsXG4gICAgJ1NUT1JFJyxcbiAgICAnU1RSRUFNJyxcbiAgICAnU1RVRElPJyxcbiAgICAnU1RVRFknLFxuICAgICdTVFlMRScsXG4gICAgJ1NVJyxcbiAgICAnU1VDS1MnLFxuICAgICdTVVBQTElFUycsXG4gICAgJ1NVUFBMWScsXG4gICAgJ1NVUFBPUlQnLFxuICAgICdTVVJGJyxcbiAgICAnU1VSR0VSWScsXG4gICAgJ1NVWlVLSScsXG4gICAgJ1NWJyxcbiAgICAnU1dBVENIJyxcbiAgICAnU1dJU1MnLFxuICAgICdTWCcsXG4gICAgJ1NZJyxcbiAgICAnU1lETkVZJyxcbiAgICAnU1lTVEVNUycsXG4gICAgJ1NaJyxcbiAgICAnVEFCJyxcbiAgICAnVEFJUEVJJyxcbiAgICAnVEFMSycsXG4gICAgJ1RBT0JBTycsXG4gICAgJ1RBUkdFVCcsXG4gICAgJ1RBVEFNT1RPUlMnLFxuICAgICdUQVRBUicsXG4gICAgJ1RBVFRPTycsXG4gICAgJ1RBWCcsXG4gICAgJ1RBWEknLFxuICAgICdUQycsXG4gICAgJ1RDSScsXG4gICAgJ1REJyxcbiAgICAnVERLJyxcbiAgICAnVEVBTScsXG4gICAgJ1RFQ0gnLFxuICAgICdURUNITk9MT0dZJyxcbiAgICAnVEVMJyxcbiAgICAnVEVNQVNFSycsXG4gICAgJ1RFTk5JUycsXG4gICAgJ1RFVkEnLFxuICAgICdURicsXG4gICAgJ1RHJyxcbiAgICAnVEgnLFxuICAgICdUSEQnLFxuICAgICdUSEVBVEVSJyxcbiAgICAnVEhFQVRSRScsXG4gICAgJ1RJQUEnLFxuICAgICdUSUNLRVRTJyxcbiAgICAnVElFTkRBJyxcbiAgICAnVElGRkFOWScsXG4gICAgJ1RJUFMnLFxuICAgICdUSVJFUycsXG4gICAgJ1RJUk9MJyxcbiAgICAnVEonLFxuICAgICdUSk1BWFgnLFxuICAgICdUSlgnLFxuICAgICdUSycsXG4gICAgJ1RLTUFYWCcsXG4gICAgJ1RMJyxcbiAgICAnVE0nLFxuICAgICdUTUFMTCcsXG4gICAgJ1ROJyxcbiAgICAnVE8nLFxuICAgICdUT0RBWScsXG4gICAgJ1RPS1lPJyxcbiAgICAnVE9PTFMnLFxuICAgICdUT1AnLFxuICAgICdUT1JBWScsXG4gICAgJ1RPU0hJQkEnLFxuICAgICdUT1RBTCcsXG4gICAgJ1RPVVJTJyxcbiAgICAnVE9XTicsXG4gICAgJ1RPWU9UQScsXG4gICAgJ1RPWVMnLFxuICAgICdUUicsXG4gICAgJ1RSQURFJyxcbiAgICAnVFJBRElORycsXG4gICAgJ1RSQUlOSU5HJyxcbiAgICAnVFJBVkVMJyxcbiAgICAnVFJBVkVMQ0hBTk5FTCcsXG4gICAgJ1RSQVZFTEVSUycsXG4gICAgJ1RSQVZFTEVSU0lOU1VSQU5DRScsXG4gICAgJ1RSVVNUJyxcbiAgICAnVFJWJyxcbiAgICAnVFQnLFxuICAgICdUVUJFJyxcbiAgICAnVFVJJyxcbiAgICAnVFVORVMnLFxuICAgICdUVVNIVScsXG4gICAgJ1RWJyxcbiAgICAnVFZTJyxcbiAgICAnVFcnLFxuICAgICdUWicsXG4gICAgJ1VBJyxcbiAgICAnVUJBTksnLFxuICAgICdVQlMnLFxuICAgICdVRycsXG4gICAgJ1VLJyxcbiAgICAnVU5JQ09NJyxcbiAgICAnVU5JVkVSU0lUWScsXG4gICAgJ1VOTycsXG4gICAgJ1VPTCcsXG4gICAgJ1VQUycsXG4gICAgJ1VTJyxcbiAgICAnVVknLFxuICAgICdVWicsXG4gICAgJ1ZBJyxcbiAgICAnVkFDQVRJT05TJyxcbiAgICAnVkFOQScsXG4gICAgJ1ZBTkdVQVJEJyxcbiAgICAnVkMnLFxuICAgICdWRScsXG4gICAgJ1ZFR0FTJyxcbiAgICAnVkVOVFVSRVMnLFxuICAgICdWRVJJU0lHTicsXG4gICAgJ1ZFUlNJQ0hFUlVORycsXG4gICAgJ1ZFVCcsXG4gICAgJ1ZHJyxcbiAgICAnVkknLFxuICAgICdWSUFKRVMnLFxuICAgICdWSURFTycsXG4gICAgJ1ZJRycsXG4gICAgJ1ZJS0lORycsXG4gICAgJ1ZJTExBUycsXG4gICAgJ1ZJTicsXG4gICAgJ1ZJUCcsXG4gICAgJ1ZJUkdJTicsXG4gICAgJ1ZJU0EnLFxuICAgICdWSVNJT04nLFxuICAgICdWSVZBJyxcbiAgICAnVklWTycsXG4gICAgJ1ZMQUFOREVSRU4nLFxuICAgICdWTicsXG4gICAgJ1ZPREtBJyxcbiAgICAnVk9MS1NXQUdFTicsXG4gICAgJ1ZPTFZPJyxcbiAgICAnVk9URScsXG4gICAgJ1ZPVElORycsXG4gICAgJ1ZPVE8nLFxuICAgICdWT1lBR0UnLFxuICAgICdWVScsXG4gICAgJ1ZVRUxPUycsXG4gICAgJ1dBTEVTJyxcbiAgICAnV0FMTUFSVCcsXG4gICAgJ1dBTFRFUicsXG4gICAgJ1dBTkcnLFxuICAgICdXQU5HR09VJyxcbiAgICAnV0FUQ0gnLFxuICAgICdXQVRDSEVTJyxcbiAgICAnV0VBVEhFUicsXG4gICAgJ1dFQVRIRVJDSEFOTkVMJyxcbiAgICAnV0VCQ0FNJyxcbiAgICAnV0VCRVInLFxuICAgICdXRUJTSVRFJyxcbiAgICAnV0VEJyxcbiAgICAnV0VERElORycsXG4gICAgJ1dFSUJPJyxcbiAgICAnV0VJUicsXG4gICAgJ1dGJyxcbiAgICAnV0hPU1dITycsXG4gICAgJ1dJRU4nLFxuICAgICdXSUtJJyxcbiAgICAnV0lMTElBTUhJTEwnLFxuICAgICdXSU4nLFxuICAgICdXSU5ET1dTJyxcbiAgICAnV0lORScsXG4gICAgJ1dJTk5FUlMnLFxuICAgICdXTUUnLFxuICAgICdXT0xURVJTS0xVV0VSJyxcbiAgICAnV09PRFNJREUnLFxuICAgICdXT1JLJyxcbiAgICAnV09SS1MnLFxuICAgICdXT1JMRCcsXG4gICAgJ1dPVycsXG4gICAgJ1dTJyxcbiAgICAnV1RDJyxcbiAgICAnV1RGJyxcbiAgICAnWEJPWCcsXG4gICAgJ1hFUk9YJyxcbiAgICAnWEZJTklUWScsXG4gICAgJ1hJSFVBTicsXG4gICAgJ1hJTicsXG4gICAgJ1hOLS0xMUI0QzNEJyxcbiAgICAnWE4tLTFDSzJFMUInLFxuICAgICdYTi0tMVFRVzIzQScsXG4gICAgJ1hOLS0yU0NSSjlDJyxcbiAgICAnWE4tLTMwUlI3WScsXG4gICAgJ1hOLS0zQlNUMDBNJyxcbiAgICAnWE4tLTNEUzQ0M0cnLFxuICAgICdYTi0tM0UwQjcwN0UnLFxuICAgICdYTi0tM0hDUko5QycsXG4gICAgJ1hOLS0zUFhVOEsnLFxuICAgICdYTi0tNDJDMkQ5QScsXG4gICAgJ1hOLS00NUJSNUNZTCcsXG4gICAgJ1hOLS00NUJSSjlDJyxcbiAgICAnWE4tLTQ1UTExQycsXG4gICAgJ1hOLS00REJSSzBDRScsXG4gICAgJ1hOLS00R0JSSU0nLFxuICAgICdYTi0tNTRCN0ZUQTBDQycsXG4gICAgJ1hOLS01NVFXNDJHJyxcbiAgICAnWE4tLTU1UVg1RCcsXG4gICAgJ1hOLS01U1UzNEo5MzZCR1NHJyxcbiAgICAnWE4tLTVUWk01RycsXG4gICAgJ1hOLS02RlJaODJHJyxcbiAgICAnWE4tLTZRUTk4NkIzWEwnLFxuICAgICdYTi0tODBBRFhIS1MnLFxuICAgICdYTi0tODBBTzIxQScsXG4gICAgJ1hOLS04MEFRRUNEUjFBJyxcbiAgICAnWE4tLTgwQVNFSERCJyxcbiAgICAnWE4tLTgwQVNXRycsXG4gICAgJ1hOLS04WTBBMDYzQScsXG4gICAgJ1hOLS05MEEzQUMnLFxuICAgICdYTi0tOTBBRScsXG4gICAgJ1hOLS05MEFJUycsXG4gICAgJ1hOLS05REJRMkEnLFxuICAgICdYTi0tOUVUNTJVJyxcbiAgICAnWE4tLTlLUlQwMEEnLFxuICAgICdYTi0tQjRXNjA1RkVSRCcsXG4gICAgJ1hOLS1CQ0sxQjlBNURSRTRDJyxcbiAgICAnWE4tLUMxQVZHJyxcbiAgICAnWE4tLUMyQlI3RycsXG4gICAgJ1hOLS1DQ0syQjNCJyxcbiAgICAnWE4tLUNDS1dDWEVURCcsXG4gICAgJ1hOLS1DRzRCS0knLFxuICAgICdYTi0tQ0xDSEMwRUEwQjJHMkE5R0NEJyxcbiAgICAnWE4tLUNaUjY5NEInLFxuICAgICdYTi0tQ1pSUzBUJyxcbiAgICAnWE4tLUNaUlUyRCcsXG4gICAgJ1hOLS1EMUFDSjNCJyxcbiAgICAnWE4tLUQxQUxGJyxcbiAgICAnWE4tLUUxQTRDJyxcbiAgICAnWE4tLUVDS1ZEVEM5RCcsXG4gICAgJ1hOLS1FRlZZODhIJyxcbiAgICAnWE4tLUZDVDQyOUsnLFxuICAgICdYTi0tRkhCRUknLFxuICAgICdYTi0tRklRMjI4QzVIUycsXG4gICAgJ1hOLS1GSVE2NEInLFxuICAgICdYTi0tRklRUzhTJyxcbiAgICAnWE4tLUZJUVo5UycsXG4gICAgJ1hOLS1GSlE3MjBBJyxcbiAgICAnWE4tLUZMVzM1MUUnLFxuICAgICdYTi0tRlBDUko5QzNEJyxcbiAgICAnWE4tLUZaQzJDOUUyQycsXG4gICAgJ1hOLS1GWllTOEQ2OVVWR00nLFxuICAgICdYTi0tRzJYWDQ4QycsXG4gICAgJ1hOLS1HQ0tSM0YwRicsXG4gICAgJ1hOLS1HRUNSSjlDJyxcbiAgICAnWE4tLUdLM0FUMUUnLFxuICAgICdYTi0tSDJCUkVHM0VWRScsXG4gICAgJ1hOLS1IMkJSSjlDJyxcbiAgICAnWE4tLUgyQlJKOUM4QycsXG4gICAgJ1hOLS1IWFQ4MTRFJyxcbiAgICAnWE4tLUkxQjZCMUE2QTJFJyxcbiAgICAnWE4tLUlNUjUxM04nLFxuICAgICdYTi0tSU8wQTdJJyxcbiAgICAnWE4tLUoxQUVGJyxcbiAgICAnWE4tLUoxQU1IJyxcbiAgICAnWE4tLUo2VzE5M0cnLFxuICAgICdYTi0tSkxRNDgwTjJSRycsXG4gICAgJ1hOLS1KTFE2MVU5VzdCJyxcbiAgICAnWE4tLUpWUjE4OU0nLFxuICAgICdYTi0tS0NSWDc3RDFYNEEnLFxuICAgICdYTi0tS1BSVzEzRCcsXG4gICAgJ1hOLS1LUFJZNTdEJyxcbiAgICAnWE4tLUtQVVQzSScsXG4gICAgJ1hOLS1MMUFDQycsXG4gICAgJ1hOLS1MR0JCQVQxQUQ4SicsXG4gICAgJ1hOLS1NR0I5QVdCRicsXG4gICAgJ1hOLS1NR0JBM0EzRUpUJyxcbiAgICAnWE4tLU1HQkEzQTRGMTZBJyxcbiAgICAnWE4tLU1HQkE3QzBCQk4wQScsXG4gICAgJ1hOLS1NR0JBQUtDN0RWRicsXG4gICAgJ1hOLS1NR0JBQU03QThIJyxcbiAgICAnWE4tLU1HQkFCMkJEJyxcbiAgICAnWE4tLU1HQkFIMUEzSEpLUkQnLFxuICAgICdYTi0tTUdCQUk5QVpHUVA2SicsXG4gICAgJ1hOLS1NR0JBWUg3R1BBJyxcbiAgICAnWE4tLU1HQkJIMUEnLFxuICAgICdYTi0tTUdCQkgxQTcxRScsXG4gICAgJ1hOLS1NR0JDMEE5QVpDRycsXG4gICAgJ1hOLS1NR0JDQTdEWkRPJyxcbiAgICAnWE4tLU1HQkNQUTZHUEExQScsXG4gICAgJ1hOLS1NR0JFUlA0QTVENEFSJyxcbiAgICAnWE4tLU1HQkdVODJBJyxcbiAgICAnWE4tLU1HQkk0RUNFWFAnLFxuICAgICdYTi0tTUdCUEwyRkgnLFxuICAgICdYTi0tTUdCVDNESEQnLFxuICAgICdYTi0tTUdCVFgyQicsXG4gICAgJ1hOLS1NR0JYNENEMEFCJyxcbiAgICAnWE4tLU1JWDg5MUYnLFxuICAgICdYTi0tTUsxQlU0NEMnLFxuICAgICdYTi0tTVhUUTFNJyxcbiAgICAnWE4tLU5HQkM1QVpEJyxcbiAgICAnWE4tLU5HQkU5RTBBJyxcbiAgICAnWE4tLU5HQlJYJyxcbiAgICAnWE4tLU5PREUnLFxuICAgICdYTi0tTlFWN0YnLFxuICAgICdYTi0tTlFWN0ZTMDBFTUEnLFxuICAgICdYTi0tTllRWTI2QScsXG4gICAgJ1hOLS1PM0NXNEgnLFxuICAgICdYTi0tT0dCUEY4RkwnLFxuICAgICdYTi0tT1RVNzk2RCcsXG4gICAgJ1hOLS1QMUFDRicsXG4gICAgJ1hOLS1QMUFJJyxcbiAgICAnWE4tLVBHQlMwREgnLFxuICAgICdYTi0tUFNTWTJVJyxcbiAgICAnWE4tLVE3Q0U2QScsXG4gICAgJ1hOLS1ROUpZQjRDJyxcbiAgICAnWE4tLVFDS0ExUE1DJyxcbiAgICAnWE4tLVFYQTZBJyxcbiAgICAnWE4tLVFYQU0nLFxuICAgICdYTi0tUkhRVjk2RycsXG4gICAgJ1hOLS1ST1ZVODhCJyxcbiAgICAnWE4tLVJWQzFFMEFNM0UnLFxuICAgICdYTi0tUzlCUko5QycsXG4gICAgJ1hOLS1TRVM1NTRHJyxcbiAgICAnWE4tLVQ2MEI1NkEnLFxuICAgICdYTi0tVENLV0UnLFxuICAgICdYTi0tVElRNDlYUVlKJyxcbiAgICAnWE4tLVVOVVA0WScsXG4gICAgJ1hOLS1WRVJNR0VOU0JFUkFURVItQ1RCJyxcbiAgICAnWE4tLVZFUk1HRU5TQkVSQVRVTkctUFdCJyxcbiAgICAnWE4tLVZIUVVWJyxcbiAgICAnWE4tLVZVUTg2MUInLFxuICAgICdYTi0tVzRSODVFTDhGSFU1RE5SQScsXG4gICAgJ1hOLS1XNFJTNDBMJyxcbiAgICAnWE4tLVdHQkgxQycsXG4gICAgJ1hOLS1XR0JMNkEnLFxuICAgICdYTi0tWEhRNTIxQicsXG4gICAgJ1hOLS1YS0MyQUwzSFlFMkEnLFxuICAgICdYTi0tWEtDMkRMM0E1RUUwSCcsXG4gICAgJ1hOLS1ZOUEzQVEnLFxuICAgICdYTi0tWUZSTzRJNjdPJyxcbiAgICAnWE4tLVlHQkkyQU1NWCcsXG4gICAgJ1hOLS1aRlIxNjRCJyxcbiAgICAnWFhYJyxcbiAgICAnWFlaJyxcbiAgICAnWUFDSFRTJyxcbiAgICAnWUFIT08nLFxuICAgICdZQU1BWFVOJyxcbiAgICAnWUFOREVYJyxcbiAgICAnWUUnLFxuICAgICdZT0RPQkFTSEknLFxuICAgICdZT0dBJyxcbiAgICAnWU9LT0hBTUEnLFxuICAgICdZT1UnLFxuICAgICdZT1VUVUJFJyxcbiAgICAnWVQnLFxuICAgICdZVU4nLFxuICAgICdaQScsXG4gICAgJ1pBUFBPUycsXG4gICAgJ1pBUkEnLFxuICAgICdaRVJPJyxcbiAgICAnWklQJyxcbiAgICAnWk0nLFxuICAgICdaT05FJyxcbiAgICAnWlVFUklDSCcsXG4gICAgJ1pXJ1xuXTtcblxuXG4vLyBLZWVwIGFzIHVwcGVyLWNhc2UgdG8gbWFrZSB1cGRhdGluZyBmcm9tIHNvdXJjZSBlYXNpZXJcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2V0KGludGVybmFscy50bGRzLm1hcCgodGxkKSA9PiB0bGQudG9Mb3dlckNhc2UoKSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IEVzY2FwZVJlZ2V4ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXNjYXBlUmVnZXgnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCByZmMzOTg2ID0ge307XG5cbiAgICBjb25zdCBoZXhEaWdpdCA9ICdcXFxcZEEtRmEtZic7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIRVhESUcgPSBESUdJVCAvIFwiQVwiIC8gXCJCXCIgLyBcIkNcIiAvIFwiRFwiIC8gXCJFXCIgLyBcIkZcIlxuICAgIGNvbnN0IGhleERpZ2l0T25seSA9ICdbJyArIGhleERpZ2l0ICsgJ10nO1xuXG4gICAgY29uc3QgdW5yZXNlcnZlZCA9ICdcXFxcdy1cXFxcLn4nOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bnJlc2VydmVkID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXG4gICAgY29uc3Qgc3ViRGVsaW1zID0gJyFcXFxcJCZcXCdcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PSc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3ViLWRlbGltcyA9IFwiIVwiIC8gXCIkXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIoXCIgLyBcIilcIiAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcbiAgICBjb25zdCBwY3RFbmNvZGVkID0gJyUnICsgaGV4RGlnaXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGN0LWVuY29kZWQgPSBcIiVcIiBIRVhESUcgSEVYRElHXG4gICAgY29uc3QgcGNoYXIgPSB1bnJlc2VydmVkICsgcGN0RW5jb2RlZCArIHN1YkRlbGltcyArICc6QCc7ICAgICAgICAgICAgICAgICAgIC8vIHBjaGFyID0gdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIC8gXCJAXCJcbiAgICBjb25zdCBwY2hhck9ubHkgPSAnWycgKyBwY2hhciArICddJztcbiAgICBjb25zdCBkZWNPY3RlY3QgPSAnKD86MHswLDJ9XFxcXGR8MD9bMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pJzsgICAgIC8vIGRlYy1vY3RldCA9IERJR0lUIC8gJXgzMS0zOSBESUdJVCAvIFwiMVwiIDJESUdJVCAvIFwiMlwiICV4MzAtMzQgRElHSVQgLyBcIjI1XCIgJXgzMC0zNSAgOyAwLTkgLyAxMC05OSAvIDEwMC0xOTkgLyAyMDAtMjQ5IC8gMjUwLTI1NVxuXG4gICAgcmZjMzk4Ni5pcHY0YWRkcmVzcyA9ICcoPzonICsgZGVjT2N0ZWN0ICsgJ1xcXFwuKXszfScgKyBkZWNPY3RlY3Q7ICAgICAgICAgICAgLy8gSVB2NGFkZHJlc3MgPSBkZWMtb2N0ZXQgXCIuXCIgZGVjLW9jdGV0IFwiLlwiIGRlYy1vY3RldCBcIi5cIiBkZWMtb2N0ZXRcblxuICAgIC8qXG4gICAgICAgIGgxNiA9IDEqNEhFWERJRyA7IDE2IGJpdHMgb2YgYWRkcmVzcyByZXByZXNlbnRlZCBpbiBoZXhhZGVjaW1hbFxuICAgICAgICBsczMyID0gKCBoMTYgXCI6XCIgaDE2ICkgLyBJUHY0YWRkcmVzcyA7IGxlYXN0LXNpZ25pZmljYW50IDMyIGJpdHMgb2YgYWRkcmVzc1xuICAgICAgICBJUHY2YWRkcmVzcyA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDYoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgICAgICAgICAgICAgXCI6OlwiIDUoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjIoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAyKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICAgICAgICAgICAgICAgIC8gWyAqMyggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgIGgxNiBcIjpcIiAgIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICo1KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGgxNlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjYoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIlxuICAgICovXG5cbiAgICBjb25zdCBoMTYgPSBoZXhEaWdpdE9ubHkgKyAnezEsNH0nO1xuICAgIGNvbnN0IGxzMzIgPSAnKD86JyArIGgxNiArICc6JyArIGgxNiArICd8JyArIHJmYzM5ODYuaXB2NGFkZHJlc3MgKyAnKSc7XG4gICAgY29uc3QgSVB2NlNpeEhleCA9ICcoPzonICsgaDE2ICsgJzopezZ9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NkZpdmVIZXggPSAnOjooPzonICsgaDE2ICsgJzopezV9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NkZvdXJIZXggPSAnKD86JyArIGgxNiArICcpPzo6KD86JyArIGgxNiArICc6KXs0fScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZUaHJlZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsMX0nICsgaDE2ICsgJyk/OjooPzonICsgaDE2ICsgJzopezN9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NlR3b0hleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsMn0nICsgaDE2ICsgJyk/OjooPzonICsgaDE2ICsgJzopezJ9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2Nk9uZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsM30nICsgaDE2ICsgJyk/OjonICsgaDE2ICsgJzonICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsNH0nICsgaDE2ICsgJyk/OjonICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleDIgPSAnKD86KD86JyArIGgxNiArICc6KXswLDV9JyArIGgxNiArICcpPzo6JyArIGgxNjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleDMgPSAnKD86KD86JyArIGgxNiArICc6KXswLDZ9JyArIGgxNiArICcpPzo6JztcblxuICAgIHJmYzM5ODYuaXB2NENpZHIgPSAnKD86XFxcXGR8WzEtMl1cXFxcZHwzWzAtMl0pJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSVB2NCBjaWRyID0gRElHSVQgLyAleDMxLTMyIERJR0lUIC8gXCIzXCIgJXgzMC0zMiAgOyAwLTkgLyAxMC0yOSAvIDMwLTMyXG4gICAgcmZjMzk4Ni5pcHY2Q2lkciA9ICcoPzowezAsMn1cXFxcZHwwP1sxLTldXFxcXGR8MVswMV1cXFxcZHwxMlswLThdKSc7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElQdjYgY2lkciA9IERJR0lUIC8gJXgzMS0zOSBESUdJVCAvIFwiMVwiICV4MC0xIERJR0lUIC8gXCIxMlwiICV4MC04OyAgIDAtOSAvIDEwLTk5IC8gMTAwLTExOSAvIDEyMC0xMjhcbiAgICByZmMzOTg2LmlwdjZhZGRyZXNzID0gJyg/OicgKyBJUHY2U2l4SGV4ICsgJ3wnICsgSVB2NkZpdmVIZXggKyAnfCcgKyBJUHY2Rm91ckhleCArICd8JyArIElQdjZUaHJlZUhleCArICd8JyArIElQdjZUd29IZXggKyAnfCcgKyBJUHY2T25lSGV4ICsgJ3wnICsgSVB2Nk5vbmVIZXggKyAnfCcgKyBJUHY2Tm9uZUhleDIgKyAnfCcgKyBJUHY2Tm9uZUhleDMgKyAnKSc7XG4gICAgcmZjMzk4Ni5pcHZGdXR1cmUgPSAndicgKyBoZXhEaWdpdE9ubHkgKyAnK1xcXFwuWycgKyB1bnJlc2VydmVkICsgc3ViRGVsaW1zICsgJzpdKyc7ICAgICAgLy8gSVB2RnV0dXJlID0gXCJ2XCIgMSpIRVhESUcgXCIuXCIgMSooIHVucmVzZXJ2ZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuXG4gICAgcmZjMzk4Ni5zY2hlbWUgPSAnW2EtekEtWl1bYS16QS1aXFxcXGQrLVxcXFwuXSonOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY2hlbWUgPSBBTFBIQSAqKCBBTFBIQSAvIERJR0lUIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIClcbiAgICByZmMzOTg2LnNjaGVtZVJlZ2V4ID0gbmV3IFJlZ0V4cChyZmMzOTg2LnNjaGVtZSk7XG5cbiAgICBjb25zdCB1c2VyaW5mbyA9ICdbJyArIHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJzpdKic7ICAgICAgICAgICAgICAgICAgICAgLy8gdXNlcmluZm8gPSAqKCB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuICAgIGNvbnN0IElQTGl0ZXJhbCA9ICdcXFxcWyg/OicgKyByZmMzOTg2LmlwdjZhZGRyZXNzICsgJ3wnICsgcmZjMzk4Ni5pcHZGdXR1cmUgKyAnKVxcXFxdJzsgICAgLy8gSVAtbGl0ZXJhbCA9IFwiW1wiICggSVB2NmFkZHJlc3MgLyBJUHZGdXR1cmUgICkgXCJdXCJcbiAgICBjb25zdCByZWdOYW1lID0gJ1snICsgdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnXXsxLDI1NX0nOyAgICAgICAgICAgICAgICAgLy8gcmVnLW5hbWUgPSAqKCB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIClcbiAgICBjb25zdCBob3N0ID0gJyg/OicgKyBJUExpdGVyYWwgKyAnfCcgKyByZmMzOTg2LmlwdjRhZGRyZXNzICsgJ3wnICsgcmVnTmFtZSArICcpJzsgICAgICAgLy8gaG9zdCA9IElQLWxpdGVyYWwgLyBJUHY0YWRkcmVzcyAvIHJlZy1uYW1lXG4gICAgY29uc3QgcG9ydCA9ICdcXFxcZConOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9ydCA9ICpESUdJVFxuICAgIGNvbnN0IGF1dGhvcml0eSA9ICcoPzonICsgdXNlcmluZm8gKyAnQCk/JyArIGhvc3QgKyAnKD86OicgKyBwb3J0ICsgJyk/JzsgICAgICAgICAgICAgICAvLyBhdXRob3JpdHkgICA9IFsgdXNlcmluZm8gXCJAXCIgXSBob3N0IFsgXCI6XCIgcG9ydCBdXG4gICAgY29uc3QgYXV0aG9yaXR5Q2FwdHVyZSA9ICcoPzonICsgdXNlcmluZm8gKyAnQCk/KCcgKyBob3N0ICsgJykoPzo6JyArIHBvcnQgKyAnKT8nO1xuXG4gICAgLypcbiAgICAgICAgc2VnbWVudCAgICAgICA9ICpwY2hhclxuICAgICAgICBzZWdtZW50LW56ICAgID0gMSpwY2hhclxuICAgICAgICBwYXRoICAgICAgICAgID0gcGF0aC1hYmVtcHR5ICAgIDsgYmVnaW5zIHdpdGggXCIvXCIgJ3wnIGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgIC8gcGF0aC1hYnNvbHV0ZSAgIDsgYmVnaW5zIHdpdGggXCIvXCIgYnV0IG5vdCBcIi8vXCJcbiAgICAgICAgICAgICAgICAgICAgLyBwYXRoLW5vc2NoZW1lICAgOyBiZWdpbnMgd2l0aCBhIG5vbi1jb2xvbiBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIC8gcGF0aC1yb290bGVzcyAgIDsgYmVnaW5zIHdpdGggYSBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIC8gcGF0aC1lbXB0eSAgICAgIDsgemVybyBjaGFyYWN0ZXJzXG4gICAgICAgIHBhdGgtYWJlbXB0eSAgPSAqKCBcIi9cIiBzZWdtZW50IClcbiAgICAgICAgcGF0aC1hYnNvbHV0ZSA9IFwiL1wiIFsgc2VnbWVudC1ueiAqKCBcIi9cIiBzZWdtZW50ICkgXVxuICAgICAgICBwYXRoLXJvb3RsZXNzID0gc2VnbWVudC1ueiAqKCBcIi9cIiBzZWdtZW50IClcbiAgICAqL1xuXG4gICAgY29uc3Qgc2VnbWVudCA9IHBjaGFyT25seSArICcqJztcbiAgICBjb25zdCBzZWdtZW50TnogPSBwY2hhck9ubHkgKyAnKyc7XG4gICAgY29uc3Qgc2VnbWVudE56TmMgPSAnWycgKyB1bnJlc2VydmVkICsgcGN0RW5jb2RlZCArIHN1YkRlbGltcyArICdAJyArICddKyc7XG4gICAgY29uc3QgcGF0aEVtcHR5ID0gJyc7XG4gICAgY29uc3QgcGF0aEFiRW1wdHkgPSAnKD86XFxcXC8nICsgc2VnbWVudCArICcpKic7XG4gICAgY29uc3QgcGF0aEFic29sdXRlID0gJ1xcXFwvKD86JyArIHNlZ21lbnROeiArIHBhdGhBYkVtcHR5ICsgJyk/JztcbiAgICBjb25zdCBwYXRoUm9vdGxlc3MgPSBzZWdtZW50TnogKyBwYXRoQWJFbXB0eTtcbiAgICBjb25zdCBwYXRoTm9TY2hlbWUgPSBzZWdtZW50TnpOYyArIHBhdGhBYkVtcHR5O1xuICAgIGNvbnN0IHBhdGhBYk5vQXV0aG9yaXR5ID0gJyg/OlxcXFwvXFxcXC9cXFxcLycgKyBzZWdtZW50ICsgcGF0aEFiRW1wdHkgKyAnKSc7ICAgICAvLyBVc2VkIGJ5IGZpbGU6Ly8vXG5cbiAgICAvLyBoaWVyLXBhcnQgPSBcIi8vXCIgYXV0aG9yaXR5IHBhdGhcblxuICAgIHJmYzM5ODYuaGllclBhcnQgPSAnKD86JyArICcoPzpcXFxcL1xcXFwvJyArIGF1dGhvcml0eSArIHBhdGhBYkVtcHR5ICsgJyknICsgJ3wnICsgcGF0aEFic29sdXRlICsgJ3wnICsgcGF0aFJvb3RsZXNzICsgJ3wnICsgcGF0aEFiTm9BdXRob3JpdHkgKyAnKSc7XG4gICAgcmZjMzk4Ni5oaWVyUGFydENhcHR1cmUgPSAnKD86JyArICcoPzpcXFxcL1xcXFwvJyArIGF1dGhvcml0eUNhcHR1cmUgKyBwYXRoQWJFbXB0eSArICcpJyArICd8JyArIHBhdGhBYnNvbHV0ZSArICd8JyArIHBhdGhSb290bGVzcyArICcpJztcblxuICAgIC8vIHJlbGF0aXZlLXBhcnQgPSBcIi8vXCIgYXV0aG9yaXR5IHBhdGgtYWJlbXB0eSAvIHBhdGgtYWJzb2x1dGUgLyBwYXRoLW5vc2NoZW1lIC8gcGF0aC1lbXB0eVxuXG4gICAgcmZjMzk4Ni5yZWxhdGl2ZVJlZiA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5ICsgcGF0aEFiRW1wdHkgKyAnKScgKyAnfCcgKyBwYXRoQWJzb2x1dGUgKyAnfCcgKyBwYXRoTm9TY2hlbWUgKyAnfCcgKyBwYXRoRW1wdHkgKyAnKSc7XG4gICAgcmZjMzk4Ni5yZWxhdGl2ZVJlZkNhcHR1cmUgPSAnKD86JyArICcoPzpcXFxcL1xcXFwvJyArIGF1dGhvcml0eUNhcHR1cmUgKyBwYXRoQWJFbXB0eSArICcpJyArICd8JyArIHBhdGhBYnNvbHV0ZSArICd8JyArIHBhdGhOb1NjaGVtZSArICd8JyArIHBhdGhFbXB0eSArICcpJztcblxuICAgIC8vIHF1ZXJ5ID0gKiggcGNoYXIgLyBcIi9cIiAvIFwiP1wiIClcbiAgICAvLyBxdWVyeSA9ICooIHBjaGFyIC8gXCJbXCIgLyBcIl1cIiAvIFwiL1wiIC8gXCI/XCIgKVxuXG4gICAgcmZjMzk4Ni5xdWVyeSA9ICdbJyArIHBjaGFyICsgJ1xcXFwvXFxcXD9dKig/PSN8JCknOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0ZpbmlzaCBtYXRjaGluZyBlaXRoZXIgYXQgdGhlIGZyYWdtZW50IHBhcnQgJ3wnIGVuZCBvZiB0aGUgbGluZS5cbiAgICByZmMzOTg2LnF1ZXJ5V2l0aFNxdWFyZUJyYWNrZXRzID0gJ1snICsgcGNoYXIgKyAnXFxcXFtcXFxcXVxcXFwvXFxcXD9dKig/PSN8JCknO1xuXG4gICAgLy8gZnJhZ21lbnQgPSAqKCBwY2hhciAvIFwiL1wiIC8gXCI/XCIgKVxuXG4gICAgcmZjMzk4Ni5mcmFnbWVudCA9ICdbJyArIHBjaGFyICsgJ1xcXFwvXFxcXD9dKic7XG5cbiAgICByZXR1cm4gcmZjMzk4Njtcbn07XG5cbmludGVybmFscy5yZmMzOTg2ID0gaW50ZXJuYWxzLmdlbmVyYXRlKCk7XG5cblxuZXhwb3J0cy5pcCA9IHtcbiAgICB2NENpZHI6IGludGVybmFscy5yZmMzOTg2LmlwdjRDaWRyLFxuICAgIHY2Q2lkcjogaW50ZXJuYWxzLnJmYzM5ODYuaXB2NkNpZHIsXG4gICAgaXB2NDogaW50ZXJuYWxzLnJmYzM5ODYuaXB2NGFkZHJlc3MsXG4gICAgaXB2NjogaW50ZXJuYWxzLnJmYzM5ODYuaXB2NmFkZHJlc3MsXG4gICAgaXB2ZnV0dXJlOiBpbnRlcm5hbHMucmZjMzk4Ni5pcHZGdXR1cmVcbn07XG5cblxuaW50ZXJuYWxzLmNyZWF0ZVJlZ2V4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHJmYyA9IGludGVybmFscy5yZmMzOTg2O1xuXG4gICAgLy8gQ29uc3RydWN0IGV4cHJlc3Npb25cblxuICAgIGNvbnN0IHF1ZXJ5ID0gb3B0aW9ucy5hbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMgPyByZmMucXVlcnlXaXRoU3F1YXJlQnJhY2tldHMgOiByZmMucXVlcnk7XG4gICAgY29uc3Qgc3VmZml4ID0gJyg/OlxcXFw/JyArIHF1ZXJ5ICsgJyk/JyArICcoPzojJyArIHJmYy5mcmFnbWVudCArICcpPyc7XG5cbiAgICAvLyByZWxhdGl2ZS1yZWYgPSByZWxhdGl2ZS1wYXJ0IFsgXCI/XCIgcXVlcnkgXSBbIFwiI1wiIGZyYWdtZW50IF1cblxuICAgIGNvbnN0IHJlbGF0aXZlID0gb3B0aW9ucy5kb21haW4gPyByZmMucmVsYXRpdmVSZWZDYXB0dXJlIDogcmZjLnJlbGF0aXZlUmVmO1xuXG4gICAgaWYgKG9wdGlvbnMucmVsYXRpdmVPbmx5KSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMud3JhcChyZWxhdGl2ZSArIHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIHNjaGVtZXNcblxuICAgIGxldCBjdXN0b21TY2hlbWUgPSAnJztcbiAgICBpZiAob3B0aW9ucy5zY2hlbWUpIHtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMuc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBvcHRpb25zLnNjaGVtZSA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLnNjaGVtZSksICdzY2hlbWUgbXVzdCBiZSBhIFJlZ0V4cCwgU3RyaW5nLCBvciBBcnJheScpO1xuXG4gICAgICAgIGNvbnN0IHNjaGVtZXMgPSBbXS5jb25jYXQob3B0aW9ucy5zY2hlbWUpO1xuICAgICAgICBBc3NlcnQoc2NoZW1lcy5sZW5ndGggPj0gMSwgJ3NjaGVtZSBtdXN0IGhhdmUgYXQgbGVhc3QgMSBzY2hlbWUgc3BlY2lmaWVkJyk7XG5cbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgYXJyYXkgaW50byBhIHN0cmluZyB0byBiZSB1c2VkIHRvIG1hdGNoIHRoZSBzY2hlbWVzXG5cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IHNjaGVtZXNbaV07XG4gICAgICAgICAgICBBc3NlcnQoc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnLCAnc2NoZW1lIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgUmVnRXhwIG9yIFN0cmluZycpO1xuXG4gICAgICAgICAgICBpZiAoc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9ucy5wdXNoKHNjaGVtZS5zb3VyY2UudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQocmZjLnNjaGVtZVJlZ2V4LnRlc3Qoc2NoZW1lKSwgJ3NjaGVtZSBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBhIHZhbGlkIHNjaGVtZScpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnMucHVzaChFc2NhcGVSZWdleChzY2hlbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1c3RvbVNjaGVtZSA9IHNlbGVjdGlvbnMuam9pbignfCcpO1xuICAgIH1cblxuICAgIC8vIFVSSSA9IHNjaGVtZSBcIjpcIiBoaWVyLXBhcnQgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXVxuXG4gICAgY29uc3Qgc2NoZW1lID0gY3VzdG9tU2NoZW1lID8gJyg/OicgKyBjdXN0b21TY2hlbWUgKyAnKScgOiByZmMuc2NoZW1lO1xuICAgIGNvbnN0IGFic29sdXRlID0gJyg/OicgKyBzY2hlbWUgKyAnOicgKyAob3B0aW9ucy5kb21haW4gPyByZmMuaGllclBhcnRDYXB0dXJlIDogcmZjLmhpZXJQYXJ0KSArICcpJztcbiAgICBjb25zdCBwcmVmaXggPSBvcHRpb25zLmFsbG93UmVsYXRpdmUgPyAnKD86JyArIGFic29sdXRlICsgJ3wnICsgcmVsYXRpdmUgKyAnKScgOiBhYnNvbHV0ZTtcbiAgICByZXR1cm4gaW50ZXJuYWxzLndyYXAocHJlZml4ICsgc3VmZml4LCBjdXN0b21TY2hlbWUpO1xufTtcblxuXG5pbnRlcm5hbHMud3JhcCA9IGZ1bmN0aW9uIChyYXcsIHNjaGVtZSkge1xuXG4gICAgcmF3ID0gYCg/PS4pKD8haHR0cHM/XFw6Lyg/OiR8W14vXSkpKD8haHR0cHM/XFw6Ly8vKSg/IWh0dHBzP1xcOlteL10pJHtyYXd9YDsgICAgIC8vIFJlcXVpcmUgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBhbmQgZXhwbGljaXRseSBmb3JiaWQgJ2h0dHA6Lycgb3IgSFRUUCB3aXRoIGVtcHR5IGRvbWFpblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmF3LFxuICAgICAgICByZWdleDogbmV3IFJlZ0V4cChgXiR7cmF3fSRgKSxcbiAgICAgICAgc2NoZW1lXG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLnVyaVJlZ2V4ID0gaW50ZXJuYWxzLmNyZWF0ZVJlZ2V4KHt9KTtcblxuXG5leHBvcnRzLnJlZ2V4ID0gZnVuY3Rpb24gKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKG9wdGlvbnMuc2NoZW1lIHx8XG4gICAgICAgIG9wdGlvbnMuYWxsb3dSZWxhdGl2ZSB8fFxuICAgICAgICBvcHRpb25zLnJlbGF0aXZlT25seSB8fFxuICAgICAgICBvcHRpb25zLmFsbG93UXVlcnlTcXVhcmVCcmFja2V0cyB8fFxuICAgICAgICBvcHRpb25zLmRvbWFpbikge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY3JlYXRlUmVnZXgob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy51cmlSZWdleDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBvcGVyYXRvcnM6IFsnIScsICdeJywgJyonLCAnLycsICclJywgJysnLCAnLScsICc8JywgJzw9JywgJz4nLCAnPj0nLCAnPT0nLCAnIT0nLCAnJiYnLCAnfHwnLCAnPz8nXSxcbiAgICBvcGVyYXRvckNoYXJhY3RlcnM6IFsnIScsICdeJywgJyonLCAnLycsICclJywgJysnLCAnLScsICc8JywgJz0nLCAnPicsICcmJywgJ3wnLCAnPyddLFxuICAgIG9wZXJhdG9yc09yZGVyOiBbWydeJ10sIFsnKicsICcvJywgJyUnXSwgWycrJywgJy0nXSwgWyc8JywgJzw9JywgJz4nLCAnPj0nXSwgWyc9PScsICchPSddLCBbJyYmJ10sIFsnfHwnLCAnPz8nXV0sXG4gICAgb3BlcmF0b3JzUHJlZml4OiBbJyEnLCAnbiddLFxuXG4gICAgbGl0ZXJhbHM6IHtcbiAgICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICAgJ2AnOiAnYCcsXG4gICAgICAgICdcXCcnOiAnXFwnJyxcbiAgICAgICAgJ1snOiAnXSdcbiAgICB9LFxuXG4gICAgbnVtYmVyUng6IC9eKD86WzAtOV0qXFwuP1swLTldKil7MX0kLyxcbiAgICB0b2tlblJ4OiAvXltcXHdcXCRcXCNcXC5cXEBcXDpcXHtcXH1dKyQvLFxuXG4gICAgc3ltYm9sOiBTeW1ib2woJ2Zvcm11bGEnKSxcbiAgICBzZXR0aW5nczogU3ltYm9sKCdzZXR0aW5ncycpXG59O1xuXG5cbmV4cG9ydHMuUGFyc2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBpZiAoIW9wdGlvbnNbaW50ZXJuYWxzLnNldHRpbmdzXSAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb25zdGFudHMpIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBjb25zdGFudCBpbiBvcHRpb25zLmNvbnN0YW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy5jb25zdGFudHNbY29uc3RhbnRdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhWydib29sZWFuJywgJ251bWJlcicsICdzdHJpbmcnXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnN0YW50ICR7Y29uc3RhbnR9IGNvbnRhaW5zIGludmFsaWQgJHt0eXBlb2YgdmFsdWV9IHZhbHVlIHR5cGVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldHRpbmdzID0gb3B0aW9uc1tpbnRlcm5hbHMuc2V0dGluZ3NdID8gb3B0aW9ucyA6IE9iamVjdC5hc3NpZ24oeyBbaW50ZXJuYWxzLnNldHRpbmdzXTogdHJ1ZSwgY29uc3RhbnRzOiB7fSwgZnVuY3Rpb25zOiB7fSB9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zaW5nbGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3BhcnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyc2Uoc3RyaW5nKTtcbiAgICB9XG5cbiAgICBfcGFyc2Uoc3RyaW5nKSB7XG5cbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50ID0gJyc7XG4gICAgICAgIGxldCBwYXJlbnRoZXNpcyA9IDA7XG4gICAgICAgIGxldCBsaXRlcmFsID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgZmx1c2ggPSAoaW5uZXIpID0+IHtcblxuICAgICAgICAgICAgaWYgKHBhcmVudGhlc2lzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtdWxhIG1pc3NpbmcgY2xvc2luZyBwYXJlbnRoZXNpcycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gcGFydHMubGVuZ3RoID8gcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAoIWxpdGVyYWwgJiZcbiAgICAgICAgICAgICAgICAhY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICFpbm5lcikge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGFzdCAmJlxuICAgICAgICAgICAgICAgIGxhc3QudHlwZSA9PT0gJ3JlZmVyZW5jZScgJiZcbiAgICAgICAgICAgICAgICBpbm5lciA9PT0gJyknKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uXG5cbiAgICAgICAgICAgICAgICBsYXN0LnR5cGUgPSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgICAgIGxhc3QudmFsdWUgPSB0aGlzLl9zdWJGb3JtdWxhKGN1cnJlbnQsIGxhc3QudmFsdWUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbm5lciA9PT0gJyknKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZ21lbnRcbiAgICAgICAgICAgICAgICBjb25zdCBzdWIgPSBuZXcgZXhwb3J0cy5QYXJzZXIoY3VycmVudCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdzZWdtZW50JywgdmFsdWU6IHN1YiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbCA9PT0gJ10nKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ3JlZmVyZW5jZScsIHZhbHVlOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogY3VycmVudCB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpdGVyYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGludGVybmFscy5vcGVyYXRvckNoYXJhY3RlcnMuaW5jbHVkZXMoY3VycmVudCkpIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhdG9yXG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgbGFzdC50eXBlID09PSAnb3BlcmF0b3InICYmXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5vcGVyYXRvcnMuaW5jbHVkZXMobGFzdC52YWx1ZSArIGN1cnJlbnQpKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyAyIGNoYXJhY3RlcnMgb3BlcmF0b3JcblxuICAgICAgICAgICAgICAgICAgICBsYXN0LnZhbHVlICs9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ29wZXJhdG9yJywgdmFsdWU6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudC5tYXRjaChpbnRlcm5hbHMubnVtYmVyUngpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTnVtYmVyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdjb25zdGFudCcsIHZhbHVlOiBwYXJzZUZsb2F0KGN1cnJlbnQpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5jb25zdGFudHNbY3VycmVudF0gIT09IHVuZGVmaW5lZCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RhbnRcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ2NvbnN0YW50JywgdmFsdWU6IHRoaXMuc2V0dGluZ3MuY29uc3RhbnRzW2N1cnJlbnRdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Lm1hdGNoKGludGVybmFscy50b2tlblJ4KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgaW52YWxpZCB0b2tlbjogJHtjdXJyZW50fWApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAncmVmZXJlbmNlJywgdmFsdWU6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygc3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGlmIChjID09PSBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICArK3BhcmVudGhlc2lzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1wYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIGluIGludGVybmFscy5saXRlcmFscykge1xuICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBpbnRlcm5hbHMubGl0ZXJhbHNbY107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgICsrcGFyZW50aGVzaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnRlcm5hbHMub3BlcmF0b3JDaGFyYWN0ZXJzLmluY2x1ZGVzKGMpKSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gYztcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoKCk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBwcmVmaXggLSB0byBpbnRlcm5hbCBuZWdhdGl2ZSBvcGVyYXRvclxuXG4gICAgICAgIHBhcnRzID0gcGFydHMubWFwKChwYXJ0LCBpKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgIT09ICdvcGVyYXRvcicgfHxcbiAgICAgICAgICAgICAgICBwYXJ0LnZhbHVlICE9PSAnLScgfHxcbiAgICAgICAgICAgICAgICBpICYmIHBhcnRzW2kgLSAxXS50eXBlICE9PSAnb3BlcmF0b3InKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ29wZXJhdG9yJywgdmFsdWU6ICduJyB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSB0b2tlbnMgb3JkZXJcblxuICAgICAgICBsZXQgb3BlcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSAnb3BlcmF0b3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5vcGVyYXRvcnNQcmVmaXguaW5jbHVkZXMocGFydC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgY29udGFpbnMgYW4gb3BlcmF0b3IgaW4gaW52YWxpZCBwb3NpdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLm9wZXJhdG9ycy5pbmNsdWRlcyhwYXJ0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgYW4gdW5rbm93biBvcGVyYXRvciAke3BhcnQudmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgbWlzc2luZyBleHBlY3RlZCBvcGVyYXRvcicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGVyYXRvciA9ICFvcGVyYXRvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybXVsYSBjb250YWlucyBpbnZhbGlkIHRyYWlsaW5nIG9wZXJhdG9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZGVudGlmeSBzaW5nbGUgcGFydFxuXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIFsncmVmZXJlbmNlJywgJ2xpdGVyYWwnLCAnY29uc3RhbnQnXS5pbmNsdWRlcyhwYXJ0c1swXS50eXBlKSkge1xuXG4gICAgICAgICAgICB0aGlzLnNpbmdsZSA9IHsgdHlwZTogcGFydHNbMF0udHlwZSA9PT0gJ3JlZmVyZW5jZScgPyAncmVmZXJlbmNlJyA6ICd2YWx1ZScsIHZhbHVlOiBwYXJ0c1swXS52YWx1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvY2VzcyBwYXJ0c1xuXG4gICAgICAgIHRoaXMuX3BhcnRzID0gcGFydHMubWFwKChwYXJ0KSA9PiB7XG5cbiAgICAgICAgICAgIC8vIE9wZXJhdG9yc1xuXG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSAnb3BlcmF0b3InKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5vcGVyYXRvcnNQcmVmaXguaW5jbHVkZXMocGFydC52YWx1ZSkgPyBwYXJ0IDogcGFydC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTGl0ZXJhbHMsIGNvbnN0YW50cywgc2VnbWVudHNcblxuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSAhPT0gJ3JlZmVyZW5jZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVmZXJlbmNlc1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50b2tlblJ4ICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuc2V0dGluZ3MudG9rZW5SeC50ZXN0KHBhcnQudmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgaW52YWxpZCByZWZlcmVuY2UgJHtwYXJ0LnZhbHVlfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5yZWZlcmVuY2UocGFydC52YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMucmVmZXJlbmNlKHBhcnQudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfc3ViRm9ybXVsYShzdHJpbmcsIG5hbWUpIHtcblxuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLnNldHRpbmdzLmZ1bmN0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb250YWlucyB1bmtub3duIGZ1bmN0aW9uICR7bmFtZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhcmdzID0gW107XG4gICAgICAgIGlmIChzdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICBsZXQgcGFyZW50aGVzaXMgPSAwO1xuICAgICAgICAgICAgbGV0IGxpdGVyYWwgPSBmYWxzZTtcblxuICAgICAgICAgICAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGZ1bmN0aW9uICR7bmFtZX0gd2l0aCBpbnZhbGlkIGFyZ3VtZW50cyAke3N0cmluZ31gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gc3RyaW5nW2ldO1xuICAgICAgICAgICAgICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjIGluIGludGVybmFscy5saXRlcmFscyAmJlxuICAgICAgICAgICAgICAgICAgICAhcGFyZW50aGVzaXMpIHtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBpbnRlcm5hbHMubGl0ZXJhbHNbY107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcsJyAmJlxuICAgICAgICAgICAgICAgICAgICAhcGFyZW50aGVzaXMpIHtcblxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3BhcmVudGhlc2lzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1wYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MgPSBhcmdzLm1hcCgoYXJnKSA9PiBuZXcgZXhwb3J0cy5QYXJzZXIoYXJnLCB0aGlzLnNldHRpbmdzKSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGlubmVyVmFsdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJWYWx1ZXMucHVzaChhcmcuZXZhbHVhdGUoY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmNhbGwoY29udGV4dCwgLi4uaW5uZXJWYWx1ZXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcblxuICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMuX3BhcnRzLnNsaWNlKCk7XG5cbiAgICAgICAgLy8gUHJlZml4IG9wZXJhdG9yc1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgJiZcbiAgICAgICAgICAgICAgICBwYXJ0LnR5cGUgPT09ICdvcGVyYXRvcicpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGludGVybmFscy5ldmFsdWF0ZShjdXJyZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBwYXJ0c1tpXSA9IGludGVybmFscy5zaW5nbGUocGFydC52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGVmdC1yaWdodCBvcGVyYXRvcnNcblxuICAgICAgICBpbnRlcm5hbHMub3BlcmF0b3JzT3JkZXIuZm9yRWFjaCgoc2V0KSA9PiB7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0LmluY2x1ZGVzKHBhcnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRvciA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gaW50ZXJuYWxzLmV2YWx1YXRlKHBhcnRzW2kgLSAxXSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaW50ZXJuYWxzLmV2YWx1YXRlKHBhcnRzW2kgKyAxXSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuY2FsY3VsYXRlKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzW2kgLSAxXSA9IHJlc3VsdCA9PT0gMCA/IDAgOiByZXN1bHQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgLTBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXZhbHVhdGUocGFydHNbMF0sIGNvbnRleHQpO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5QYXJzZXIucHJvdG90eXBlW2ludGVybmFscy5zeW1ib2xdID0gdHJ1ZTtcblxuXG5pbnRlcm5hbHMucmVmZXJlbmNlID0gZnVuY3Rpb24gKG5hbWUpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuXG4gICAgICAgIHJldHVybiBjb250ZXh0ICYmIGNvbnRleHRbbmFtZV0gIT09IHVuZGVmaW5lZCA/IGNvbnRleHRbbmFtZV0gOiBudWxsO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChwYXJ0LCBjb250ZXh0KSB7XG5cbiAgICBpZiAocGFydCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHBhcnQoY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRbaW50ZXJuYWxzLnN5bWJvbF0pIHtcbiAgICAgICAgcmV0dXJuIHBhcnQuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnQ7XG59O1xuXG5cbmludGVybmFscy5zaW5nbGUgPSBmdW5jdGlvbiAob3BlcmF0b3IsIHZhbHVlKSB7XG5cbiAgICBpZiAob3BlcmF0b3IgPT09ICchJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuXG4gICAgLy8gb3BlcmF0b3IgPT09ICduJ1xuXG4gICAgY29uc3QgbmVnYXRpdmUgPSAtdmFsdWU7XG4gICAgaWYgKG5lZ2F0aXZlID09PSAwKSB7ICAgICAgIC8vIE92ZXJyaWRlIC0wXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZWdhdGl2ZTtcbn07XG5cblxuaW50ZXJuYWxzLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcblxuICAgIGlmIChvcGVyYXRvciA9PT0gJz8/Jykge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmV4aXN0cyhsZWZ0KSA/IGxlZnQgOiByaWdodDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxlZnQgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiByaWdodCA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICcrJykge1xuICAgICAgICAgICAgbGVmdCA9IGludGVybmFscy5leGlzdHMobGVmdCkgPyBsZWZ0IDogJyc7XG4gICAgICAgICAgICByaWdodCA9IGludGVybmFscy5leGlzdHMocmlnaHQpID8gcmlnaHQgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJ14nOiByZXR1cm4gTWF0aC5wb3cobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgY2FzZSAnKic6IHJldHVybiBsZWZ0ICogcmlnaHQ7XG4gICAgICAgICAgICBjYXNlICcvJzogcmV0dXJuIGxlZnQgLyByaWdodDtcbiAgICAgICAgICAgIGNhc2UgJyUnOiByZXR1cm4gbGVmdCAlIHJpZ2h0O1xuICAgICAgICAgICAgY2FzZSAnKyc6IHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICBjYXNlICctJzogcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPCc6IHJldHVybiBsZWZ0IDwgcmlnaHQ7XG4gICAgICAgIGNhc2UgJzw9JzogcmV0dXJuIGxlZnQgPD0gcmlnaHQ7XG4gICAgICAgIGNhc2UgJz4nOiByZXR1cm4gbGVmdCA+IHJpZ2h0O1xuICAgICAgICBjYXNlICc+PSc6IHJldHVybiBsZWZ0ID49IHJpZ2h0O1xuICAgICAgICBjYXNlICc9PSc6IHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgICAgICAgY2FzZSAnIT0nOiByZXR1cm4gbGVmdCAhPT0gcmlnaHQ7XG4gICAgICAgIGNhc2UgJyYmJzogcmV0dXJuIGxlZnQgJiYgcmlnaHQ7XG4gICAgICAgIGNhc2UgJ3x8JzogcmV0dXJuIGxlZnQgfHwgcmlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbmludGVybmFscy5leGlzdHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5sb2NhdGlvbiA9IGZ1bmN0aW9uIChkZXB0aCA9IDApIHtcblxuICAgIGNvbnN0IG9yaWcgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IChpZ25vcmUsIHN0YWNrKSA9PiBzdGFjaztcblxuICAgIGNvbnN0IGNhcHR1cmUgPSB7fTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShjYXB0dXJlLCB0aGlzKTtcbiAgICBjb25zdCBsaW5lID0gY2FwdHVyZS5zdGFja1tkZXB0aCArIDFdO1xuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBvcmlnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZW5hbWU6IGxpbmUuZ2V0RmlsZU5hbWUoKSxcbiAgICAgICAgbGluZTogbGluZS5nZXRMaW5lTnVtYmVyKClcbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBhbm5vdGF0aW9uczogU3ltYm9sKCdhbm5vdGF0aW9ucycpXG59O1xuXG5cbmV4cG9ydHMuZXJyb3IgPSBmdW5jdGlvbiAoc3RyaXBDb2xvckNvZGVzKSB7XG5cbiAgICBpZiAoIXRoaXMuX29yaWdpbmFsIHx8XG4gICAgICAgIHR5cGVvZiB0aGlzLl9vcmlnaW5hbCAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kZXRhaWxzWzBdLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgY29uc3QgcmVkRmdFc2NhcGUgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzMxbSc7XG4gICAgY29uc3QgcmVkQmdFc2NhcGUgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzQxbSc7XG4gICAgY29uc3QgZW5kQ29sb3IgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzBtJztcblxuICAgIGNvbnN0IG9iaiA9IENsb25lKHRoaXMuX29yaWdpbmFsKTtcblxuICAgIGZvciAobGV0IGkgPSB0aGlzLmRldGFpbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgICAgICAgIC8vIFJldmVyc2Ugb3JkZXIgdG8gcHJvY2VzcyBkZWVwZXN0IGNoaWxkIGZpcnN0XG4gICAgICAgIGNvbnN0IHBvcyA9IGkgKyAxO1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuZGV0YWlsc1tpXTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGVycm9yLnBhdGg7XG4gICAgICAgIGxldCBub2RlID0gb2JqO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZyA9IHBhdGhbal07XG5cbiAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jbG9uZSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGpvaSBzY2hlbWFzIGFyZSBub3QgY2xvbmVkIGJ5IGhvZWssIHdlIGhhdmUgdG8gdGFrZSB0aGlzIGV4dHJhIHN0ZXBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGogKyAxIDwgcGF0aC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZVtzZWddICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVbc2VnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZkFubm90YXRpb25zID0gbm9kZVtpbnRlcm5hbHMuYW5ub3RhdGlvbnNdIHx8IHsgZXJyb3JzOiB7fSwgbWlzc2luZzoge30gfTtcbiAgICAgICAgICAgICAgICBub2RlW2ludGVybmFscy5hbm5vdGF0aW9uc10gPSByZWZBbm5vdGF0aW9ucztcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2VnIHx8IGVycm9yLmNvbnRleHQua2V5O1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVbc2VnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0gPSByZWZBbm5vdGF0aW9ucy5lcnJvcnNbY2FjaGVLZXldIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICByZWZBbm5vdGF0aW9ucy5lcnJvcnNbY2FjaGVLZXldLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLm1pc3NpbmdbY2FjaGVLZXldID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVwbGFjZXJzID0ge1xuICAgICAgICBrZXk6IC9fXFwka2V5XFwkXyhbLCBcXGRdKylfXFwkZW5kXFwkX1wiL2csXG4gICAgICAgIG1pc3Npbmc6IC9cIl9cXCRtaXNzXFwkXyhbXnxdKylcXHwoXFxkKylfXFwkZW5kXFwkX1wiOiBcIl9fbWlzc2luZ19fXCIvZyxcbiAgICAgICAgYXJyYXlJbmRleDogL1xccypcIl9cXCRpZHhcXCRfKFssIFxcZF0rKV9cXCRlbmRcXCRfXCIsP1xcbiguKikvZyxcbiAgICAgICAgc3BlY2lhbHM6IC9cIlxcWyhOYU58U3ltYm9sLip8LT9JbmZpbml0eXxmdW5jdGlvbi4qfFxcKC4qKV1cIi9nXG4gICAgfTtcblxuICAgIGxldCBtZXNzYWdlID0gaW50ZXJuYWxzLnNhZmVTdHJpbmdpZnkob2JqLCAyKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMua2V5LCAoJDAsICQxKSA9PiBgXCIgJHtyZWRGZ0VzY2FwZX1bJHskMX1dJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMubWlzc2luZywgKCQwLCAkMSwgJDIpID0+IGAke3JlZEJnRXNjYXBlfVwiJHskMX1cIiR7ZW5kQ29sb3J9JHtyZWRGZ0VzY2FwZX0gWyR7JDJ9XTogLS0gbWlzc2luZyAtLSR7ZW5kQ29sb3J9YClcbiAgICAgICAgLnJlcGxhY2UocmVwbGFjZXJzLmFycmF5SW5kZXgsICgkMCwgJDEsICQyKSA9PiBgXFxuJHskMn0gJHtyZWRGZ0VzY2FwZX1bJHskMX1dJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMuc3BlY2lhbHMsICgkMCwgJDEpID0+ICQxKTtcblxuICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcbiR7cmVkRmdFc2NhcGV9YDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXRhaWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGkgKyAxO1xuICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG5bJHtwb3N9XSAke3RoaXMuZGV0YWlsc1tpXS5tZXNzYWdlfWA7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgKyBlbmRDb2xvcjtcblxuICAgIHJldHVybiBtZXNzYWdlO1xufTtcblxuXG4vLyBJbnNwaXJlZCBieSBqc29uLXN0cmluZ2lmeS1zYWZlXG5cbmludGVybmFscy5zYWZlU3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaiwgc3BhY2VzKSB7XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBpbnRlcm5hbHMuc2VyaWFsaXplcigpLCBzcGFjZXMpO1xufTtcblxuXG5pbnRlcm5hbHMuc2VyaWFsaXplciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuXG4gICAgY29uc3QgY3ljbGVSZXBsYWNlciA9IChrZXksIHZhbHVlKSA9PiB7XG5cbiAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXIgfl0nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXIgfi4nICsga2V5cy5zbGljZSgwLCBzdGFjay5pbmRleE9mKHZhbHVlKSkuam9pbignLicpICsgJ10nO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgICBpZiAofnRoaXNQb3MpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSB0aGlzUG9zICsgMTtcbiAgICAgICAgICAgICAgICBrZXlzLmxlbmd0aCA9IHRoaXNQb3MgKyAxO1xuICAgICAgICAgICAgICAgIGtleXNbdGhpc1Bvc10gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjeWNsZVJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSB2YWx1ZVtpbnRlcm5hbHMuYW5ub3RhdGlvbnNdO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRlZCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5lcnJvcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWQucHVzaChgXyRpZHgkXyR7YW5ub3RhdGlvbnMuZXJyb3JzW2ldLnNvcnQoKS5qb2luKCcsICcpfV8kZW5kJF9gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkLnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhbm5vdGF0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVycm9yS2V5IGluIGFubm90YXRpb25zLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYCR7ZXJyb3JLZXl9XyRrZXkkXyR7YW5ub3RhdGlvbnMuZXJyb3JzW2Vycm9yS2V5XS5zb3J0KCkuam9pbignLCAnKX1fJGVuZCRfYF0gPSB2YWx1ZVtlcnJvcktleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtlcnJvcktleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1pc3NpbmdLZXkgaW4gYW5ub3RhdGlvbnMubWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYF8kbWlzcyRfJHttaXNzaW5nS2V5fXwke2Fubm90YXRpb25zLm1pc3NpbmdbbWlzc2luZ0tleV19XyRlbmQkX2BdID0gJ19fbWlzc2luZ19fJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSAtSW5maW5pdHkgfHxcbiAgICAgICAgICAgIE51bWJlci5pc05hTih2YWx1ZSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXG4gICAgICAgICAgICByZXR1cm4gJ1snICsgdmFsdWUudG9TdHJpbmcoKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBEZWVwRXF1YWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWwnKTtcbmNvbnN0IE1lcmdlID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvbWVyZ2UnKTtcblxuY29uc3QgQ2FjaGUgPSByZXF1aXJlKCcuL2NhY2hlJyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgQ29tcGlsZSA9IHJlcXVpcmUoJy4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IEV4dGVuZCA9IHJlcXVpcmUoJy4vZXh0ZW5kJyk7XG5jb25zdCBNYW5pZmVzdCA9IHJlcXVpcmUoJy4vbWFuaWZlc3QnKTtcbmNvbnN0IE1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuY29uc3QgTW9kaWZ5ID0gcmVxdWlyZSgnLi9tb2RpZnknKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5jb25zdCBUcmFjZSA9IHJlcXVpcmUoJy4vdHJhY2UnKTtcbmNvbnN0IFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vdmFsaWRhdG9yJyk7XG5jb25zdCBWYWx1ZXMgPSByZXF1aXJlKCcuL3ZhbHVlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5CYXNlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuXG4gICAgICAgIC8vIE5hbWluZzogcHVibGljLCBfcHJpdmF0ZSwgJF9leHRlbnNpb24sICRfbXV0YXRle2FjdGlvbn1cblxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgIHRoaXMuJF9yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbiA9IHt9O1xuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgIH1cblxuICAgIF9yZXNldCgpIHtcblxuICAgICAgICB0aGlzLl9pZHMgPSBuZXcgTW9kaWZ5LklkcygpO1xuICAgICAgICB0aGlzLl9wcmVmZXJlbmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlZnMgPSBuZXcgUmVmLk1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3ZhbGlkcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ludmFsaWRzID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9mbGFncyA9IHt9O1xuICAgICAgICB0aGlzLl9ydWxlcyA9IFtdO1xuICAgICAgICB0aGlzLl9zaW5nbGVSdWxlcyA9IG5ldyBNYXAoKTsgICAgICAgICAgICAgIC8vIFRoZSBydWxlIG9wdGlvbnMgcGFzc2VkIGZvciBub24tbXVsdGkgcnVsZXNcblxuICAgICAgICB0aGlzLiRfdGVybXMgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhc2ggb2YgYXJyYXlzIG9mIGltbXV0YWJsZSBvYmplY3RzIChleHRlbmRlZCBieSBvdGhlciB0eXBlcylcblxuICAgICAgICB0aGlzLiRfdGVtcCA9IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJ1bnRpbWUgc3RhdGUgKG5vdCBjbG9uZWQpXG4gICAgICAgICAgICBydWxlc2V0OiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVsbDogdXNlIGxhc3QsIGZhbHNlOiBlcnJvciwgbnVtYmVyOiBzdGFydCBwb3NpdGlvblxuICAgICAgICAgICAgd2hlbnM6IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJ1bnRpbWUgY2FjaGUgb2YgZ2VuZXJhdGVkIHdoZW5zXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTWFuaWZlc3RcblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgTWFuaWZlc3QuZGVzY3JpYmUgPT09ICdmdW5jdGlvbicsICdNYW5pZmVzdCBmdW5jdGlvbmFsaXR5IGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiBNYW5pZmVzdC5kZXNjcmliZSh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBSdWxlc1xuXG4gICAgYWxsb3coLi4udmFsdWVzKSB7XG5cbiAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCAnYWxsb3cnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcyh2YWx1ZXMsICdfdmFsaWRzJyk7XG4gICAgfVxuXG4gICAgYWx0ZXIodGFyZ2V0cykge1xuXG4gICAgICAgIEFzc2VydCh0YXJnZXRzICYmIHR5cGVvZiB0YXJnZXRzID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh0YXJnZXRzKSwgJ0ludmFsaWQgdGFyZ2V0cyBhcmd1bWVudCcpO1xuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHNldCBhbHRlcmF0aW9ucyBpbnNpZGUgYSBydWxlc2V0Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouJF90ZXJtcy5hbHRlcmF0aW9ucyA9IG9iai4kX3Rlcm1zLmFsdGVyYXRpb25zIHx8IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBpbiB0YXJnZXRzKSB7XG4gICAgICAgICAgICBjb25zdCBhZGp1c3RlciA9IHRhcmdldHNbdGFyZ2V0XTtcbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgYWRqdXN0ZXIgPT09ICdmdW5jdGlvbicsICdBbHRlcmF0aW9uIGFkanVzdGVyIGZvcicsIHRhcmdldCwgJ211c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgb2JqLiRfdGVybXMuYWx0ZXJhdGlvbnMucHVzaCh7IHRhcmdldCwgYWRqdXN0ZXIgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBhcnRpZmFjdChpZCkge1xuXG4gICAgICAgIEFzc2VydChpZCAhPT0gdW5kZWZpbmVkLCAnQXJ0aWZhY3QgY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuICAgICAgICBBc3NlcnQoIXRoaXMuX2NhY2hlLCAnQ2Fubm90IHNldCBhbiBhcnRpZmFjdCB3aXRoIGEgcnVsZSBjYWNoZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnYXJ0aWZhY3QnLCBpZCk7XG4gICAgfVxuXG4gICAgY2FzdCh0bykge1xuXG4gICAgICAgIEFzc2VydCh0byA9PT0gZmFsc2UgfHwgdHlwZW9mIHRvID09PSAnc3RyaW5nJywgJ0ludmFsaWQgdG8gdmFsdWUnKTtcbiAgICAgICAgQXNzZXJ0KHRvID09PSBmYWxzZSB8fCB0aGlzLl9kZWZpbml0aW9uLmNhc3RbdG9dLCAnVHlwZScsIHRoaXMudHlwZSwgJ2RvZXMgbm90IHN1cHBvcnQgY2FzdGluZyB0bycsIHRvKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Nhc3QnLCB0byA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgfVxuXG4gICAgZGVmYXVsdCh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0KCdkZWZhdWx0JywgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGRlc2NyaXB0aW9uKGRlc2MpIHtcblxuICAgICAgICBBc3NlcnQoZGVzYyAmJiB0eXBlb2YgZGVzYyA9PT0gJ3N0cmluZycsICdEZXNjcmlwdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnZGVzY3JpcHRpb24nLCBkZXNjKTtcbiAgICB9XG5cbiAgICBlbXB0eShzY2hlbWEpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBvYmouJF9jb21waWxlKHNjaGVtYSwgeyBvdmVycmlkZTogZmFsc2UgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqLiRfc2V0RmxhZygnZW1wdHknLCBzY2hlbWEsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGVycm9yKGVycikge1xuXG4gICAgICAgIEFzc2VydChlcnIsICdNaXNzaW5nIGVycm9yJyk7XG4gICAgICAgIEFzc2VydChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXJyID09PSAnZnVuY3Rpb24nLCAnTXVzdCBwcm92aWRlIGEgdmFsaWQgRXJyb3Igb2JqZWN0IG9yIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG5cbiAgICBleGFtcGxlKGV4YW1wbGUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydChleGFtcGxlICE9PSB1bmRlZmluZWQsICdNaXNzaW5nIGV4YW1wbGUnKTtcbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydvdmVycmlkZSddKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ2V4YW1wbGVzJywgZXhhbXBsZSwgeyBzaW5nbGU6IHRydWUsIG92ZXJyaWRlOiBvcHRpb25zLm92ZXJyaWRlIH0pO1xuICAgIH1cblxuICAgIGV4dGVybmFsKG1ldGhvZCwgZGVzY3JpcHRpb24pIHtcblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIEFzc2VydCghZGVzY3JpcHRpb24sICdDYW5ub3QgY29tYmluZSBvcHRpb25zIHdpdGggZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gbWV0aG9kLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgbWV0aG9kID0gbWV0aG9kLm1ldGhvZDtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nLCAnTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBBc3NlcnQoZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCB8fCBkZXNjcmlwdGlvbiAmJiB0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnLCAnRGVzY3JpcHRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ2V4dGVybmFscycsIHsgbWV0aG9kLCBkZXNjcmlwdGlvbiB9LCB7IHNpbmdsZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBmYWlsb3Zlcih2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0KCdmYWlsb3ZlcicsIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmb3JiaWRkZW4oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2UoJ2ZvcmJpZGRlbicpO1xuICAgIH1cblxuICAgIGlkKGlkKSB7XG5cbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdpZCcsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIGlkID09PSAnc3RyaW5nJywgJ2lkIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIEFzc2VydCgvXlteXFwuXSskLy50ZXN0KGlkKSwgJ2lkIGNhbm5vdCBjb250YWluIHBlcmlvZCBjaGFyYWN0ZXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2lkJywgaWQpO1xuICAgIH1cblxuICAgIGludmFsaWQoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcyh2YWx1ZXMsICdfaW52YWxpZHMnKTtcbiAgICB9XG5cbiAgICBsYWJlbChuYW1lKSB7XG5cbiAgICAgICAgQXNzZXJ0KG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnTGFiZWwgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnbGFiZWwnLCBuYW1lKTtcbiAgICB9XG5cbiAgICBtZXRhKG1ldGEpIHtcblxuICAgICAgICBBc3NlcnQobWV0YSAhPT0gdW5kZWZpbmVkLCAnTWV0YSBjYW5ub3QgYmUgdW5kZWZpbmVkJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdtZXRhcycsIG1ldGEsIHsgc2luZ2xlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIG5vdGUoLi4ubm90ZXMpIHtcblxuICAgICAgICBBc3NlcnQobm90ZXMubGVuZ3RoLCAnTWlzc2luZyBub3RlcycpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vdGUgb2Ygbm90ZXMpIHtcbiAgICAgICAgICAgIEFzc2VydChub3RlICYmIHR5cGVvZiBub3RlID09PSAnc3RyaW5nJywgJ05vdGVzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcignbm90ZXMnLCBub3Rlcyk7XG4gICAgfVxuXG4gICAgb25seShtb2RlID0gdHJ1ZSkge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbW9kZSA9PT0gJ2Jvb2xlYW4nLCAnSW52YWxpZCBtb2RlOicsIG1vZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnb25seScsIG1vZGUpO1xuICAgIH1cblxuICAgIG9wdGlvbmFsKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlKCdvcHRpb25hbCcpO1xuICAgIH1cblxuICAgIHByZWZzKHByZWZzKSB7XG5cbiAgICAgICAgQXNzZXJ0KHByZWZzLCAnTWlzc2luZyBwcmVmZXJlbmNlcycpO1xuICAgICAgICBBc3NlcnQocHJlZnMuY29udGV4dCA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIGNvbnRleHQnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLmV4dGVybmFscyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIGV4dGVybmFscycpO1xuICAgICAgICBBc3NlcnQocHJlZnMud2FybmluZ3MgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSB3YXJuaW5ncycpO1xuICAgICAgICBBc3NlcnQocHJlZnMuZGVidWcgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBkZWJ1ZycpO1xuXG4gICAgICAgIENvbW1vbi5jaGVja1ByZWZlcmVuY2VzKHByZWZzKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fcHJlZmVyZW5jZXMgPSBDb21tb24ucHJlZmVyZW5jZXMob2JqLl9wcmVmZXJlbmNlcywgcHJlZnMpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHByZXNlbmNlKG1vZGUpIHtcblxuICAgICAgICBBc3NlcnQoWydvcHRpb25hbCcsICdyZXF1aXJlZCcsICdmb3JiaWRkZW4nXS5pbmNsdWRlcyhtb2RlKSwgJ1Vua25vd24gcHJlc2VuY2UgbW9kZScsIG1vZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncHJlc2VuY2UnLCBtb2RlKTtcbiAgICB9XG5cbiAgICByYXcoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Jlc3VsdCcsIGVuYWJsZWQgPyAncmF3JyA6IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmVzdWx0KG1vZGUpIHtcblxuICAgICAgICBBc3NlcnQoWydyYXcnLCAnc3RyaXAnXS5pbmNsdWRlcyhtb2RlKSwgJ1Vua25vd24gcmVzdWx0IG1vZGUnLCBtb2RlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Jlc3VsdCcsIG1vZGUpO1xuICAgIH1cblxuICAgIHJlcXVpcmVkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlKCdyZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIHN0cmljdChlbmFibGVkKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGNvbnN0IGNvbnZlcnQgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyBmYWxzZSA6ICFlbmFibGVkO1xuICAgICAgICBvYmouX3ByZWZlcmVuY2VzID0gQ29tbW9uLnByZWZlcmVuY2VzKG9iai5fcHJlZmVyZW5jZXMsIHsgY29udmVydCB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdHJpcChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVzdWx0JywgZW5hYmxlZCA/ICdzdHJpcCcgOiB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHRhZyguLi50YWdzKSB7XG5cbiAgICAgICAgQXNzZXJ0KHRhZ3MubGVuZ3RoLCAnTWlzc2luZyB0YWdzJyk7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIEFzc2VydCh0YWcgJiYgdHlwZW9mIHRhZyA9PT0gJ3N0cmluZycsICdUYWdzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcigndGFncycsIHRhZ3MpO1xuICAgIH1cblxuICAgIHVuaXQobmFtZSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ1VuaXQgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndW5pdCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhbGlkKC4uLnZhbHVlcykge1xuXG4gICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHZhbHVlcywgJ3ZhbGlkJyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5hbGxvdyguLi52YWx1ZXMpO1xuICAgICAgICBvYmouJF9zZXRGbGFnKCdvbmx5JywgISFvYmouX3ZhbGlkcywgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgd2hlbihjb25kaXRpb24sIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKCFvYmouJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgb2JqLiRfdGVybXMud2hlbnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdoZW4gPSBDb21waWxlLndoZW4ob2JqLCBjb25kaXRpb24sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIVsnYW55JywgJ2xpbmsnXS5pbmNsdWRlcyhvYmoudHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSB3aGVuLmlzID8gW3doZW5dIDogd2hlbi5zd2l0Y2g7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29uZGl0aW9ucykge1xuICAgICAgICAgICAgICAgIEFzc2VydCghaXRlbS50aGVuIHx8IGl0ZW0udGhlbi50eXBlID09PSAnYW55JyB8fCBpdGVtLnRoZW4udHlwZSA9PT0gb2JqLnR5cGUsICdDYW5ub3QgY29tYmluZScsIG9iai50eXBlLCAnd2l0aCcsIGl0ZW0udGhlbiAmJiBpdGVtLnRoZW4udHlwZSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFpdGVtLm90aGVyd2lzZSB8fCBpdGVtLm90aGVyd2lzZS50eXBlID09PSAnYW55JyB8fCBpdGVtLm90aGVyd2lzZS50eXBlID09PSBvYmoudHlwZSwgJ0Nhbm5vdCBjb21iaW5lJywgb2JqLnR5cGUsICd3aXRoJywgaXRlbS5vdGhlcndpc2UgJiYgaXRlbS5vdGhlcndpc2UudHlwZSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3Rlcm1zLndoZW5zLnB1c2god2hlbik7XG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgLy8gSGVscGVyc1xuXG4gICAgY2FjaGUoY2FjaGUpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHNldCBjYWNoaW5nIGluc2lkZSBhIHJ1bGVzZXQnKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9jYWNoZSwgJ0Nhbm5vdCBvdmVycmlkZSBzY2hlbWEgY2FjaGUnKTtcbiAgICAgICAgQXNzZXJ0KHRoaXMuX2ZsYWdzLmFydGlmYWN0ID09PSB1bmRlZmluZWQsICdDYW5ub3QgY2FjaGUgYSBydWxlIHdpdGggYW4gYXJ0aWZhY3QnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fY2FjaGUgPSBjYWNoZSB8fCBDYWNoZS5wcm92aWRlci5wcm92aXNpb24oKTtcbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYXNzaWduKG9iaik7XG4gICAgfVxuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc291cmNlKSwgJ0ludmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuICAgICAgICBBc3NlcnQodGhpcy50eXBlID09PSAnYW55JyB8fCBzb3VyY2UudHlwZSA9PT0gJ2FueScgfHwgc291cmNlLnR5cGUgPT09IHRoaXMudHlwZSwgJ0Nhbm5vdCBtZXJnZSB0eXBlJywgdGhpcy50eXBlLCAnd2l0aCBhbm90aGVyIHR5cGU6Jywgc291cmNlLnR5cGUpO1xuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IGNvbmNhdGVuYXRlIG9udG8gYSBzY2hlbWEgd2l0aCBvcGVuIHJ1bGVzZXQnKTtcbiAgICAgICAgQXNzZXJ0KCFzb3VyY2UuX2luUnVsZXNldCgpLCAnQ2Fubm90IGNvbmNhdGVuYXRlIGEgc2NoZW1hIHdpdGggb3BlbiBydWxlc2V0Jyk7XG5cbiAgICAgICAgbGV0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnYW55JyAmJlxuICAgICAgICAgICAgc291cmNlLnR5cGUgIT09ICdhbnknKSB7XG5cbiAgICAgICAgICAgIC8vIENoYW5nZSBvYmogdG8gbWF0Y2ggc291cmNlIHR5cGVcblxuICAgICAgICAgICAgY29uc3QgdG1wT2JqID0gc291cmNlLmNsb25lKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3R5cGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcE9ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmogPSB0bXBPYmo7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouX2lkcy5jb25jYXQoc291cmNlLl9pZHMpO1xuICAgICAgICBvYmouX3JlZnMucmVnaXN0ZXIoc291cmNlLCBSZWYudG9TaWJsaW5nKTtcblxuICAgICAgICBvYmouX3ByZWZlcmVuY2VzID0gb2JqLl9wcmVmZXJlbmNlcyA/IENvbW1vbi5wcmVmZXJlbmNlcyhvYmouX3ByZWZlcmVuY2VzLCBzb3VyY2UuX3ByZWZlcmVuY2VzKSA6IHNvdXJjZS5fcHJlZmVyZW5jZXM7XG4gICAgICAgIG9iai5fdmFsaWRzID0gVmFsdWVzLm1lcmdlKG9iai5fdmFsaWRzLCBzb3VyY2UuX3ZhbGlkcywgc291cmNlLl9pbnZhbGlkcyk7XG4gICAgICAgIG9iai5faW52YWxpZHMgPSBWYWx1ZXMubWVyZ2Uob2JqLl9pbnZhbGlkcywgc291cmNlLl9pbnZhbGlkcywgc291cmNlLl92YWxpZHMpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB1bmlxdWUgcnVsZXMgcHJlc2VudCBpbiBzb3VyY2VcblxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc291cmNlLl9zaW5nbGVSdWxlcy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGlmIChvYmouX3NpbmdsZVJ1bGVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9iai5fcnVsZXMgPSBvYmouX3J1bGVzLmZpbHRlcigodGFyZ2V0KSA9PiB0YXJnZXQua2VlcCB8fCB0YXJnZXQubmFtZSAhPT0gbmFtZSk7XG4gICAgICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdWxlc1xuXG4gICAgICAgIGZvciAoY29uc3QgdGVzdCBvZiBzb3VyY2UuX3J1bGVzKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZS5fZGVmaW5pdGlvbi5ydWxlc1t0ZXN0Lm1ldGhvZF0ubXVsdGkpIHtcbiAgICAgICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLnNldCh0ZXN0Lm5hbWUsIHRlc3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouX3J1bGVzLnB1c2godGVzdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGbGFnc1xuXG4gICAgICAgIGlmIChvYmouX2ZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICBzb3VyY2UuX2ZsYWdzLmVtcHR5KSB7XG5cbiAgICAgICAgICAgIG9iai5fZmxhZ3MuZW1wdHkgPSBvYmouX2ZsYWdzLmVtcHR5LmNvbmNhdChzb3VyY2UuX2ZsYWdzLmVtcHR5KTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLl9mbGFncyk7XG4gICAgICAgICAgICBkZWxldGUgZmxhZ3MuZW1wdHk7XG4gICAgICAgICAgICBNZXJnZShvYmouX2ZsYWdzLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc291cmNlLl9mbGFncy5lbXB0eSkge1xuICAgICAgICAgICAgb2JqLl9mbGFncy5lbXB0eSA9IHNvdXJjZS5fZmxhZ3MuZW1wdHk7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5fZmxhZ3MpO1xuICAgICAgICAgICAgZGVsZXRlIGZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgTWVyZ2Uob2JqLl9mbGFncywgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgTWVyZ2Uob2JqLl9mbGFncywgc291cmNlLl9mbGFncyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXJtc1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZS4kX3Rlcm1zKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXJtcyA9IHNvdXJjZS4kX3Rlcm1zW2tleV07XG4gICAgICAgICAgICBpZiAoIXRlcm1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmouJF90ZXJtc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zW2tleV0gPSB0ZXJtcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvYmouJF90ZXJtc1trZXldKSB7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXNba2V5XSA9IHRlcm1zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW2tleV0gPSBvYmouJF90ZXJtc1trZXldLmNvbmNhdCh0ZXJtcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjaW5nXG5cbiAgICAgICAgaWYgKHRoaXMuJF9yb290Ll90cmFjZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJF9yb290Ll90cmFjZXIuX2NvbWJpbmUob2JqLCBbdGhpcywgc291cmNlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWJ1aWxkXG5cbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBleHRlbmQob3B0aW9ucykge1xuXG4gICAgICAgIEFzc2VydCghb3B0aW9ucy5iYXNlLCAnQ2Fubm90IGV4dGVuZCB0eXBlIHdpdGggYW5vdGhlciBiYXNlJyk7XG5cbiAgICAgICAgcmV0dXJuIEV4dGVuZC50eXBlKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGV4dHJhY3QocGF0aCkge1xuXG4gICAgICAgIHBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkcy5yZWFjaChwYXRoKTtcbiAgICB9XG5cbiAgICBmb3JrKHBhdGhzLCBhZGp1c3Rlcikge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3QgZm9yayBpbnNpZGUgYSBydWxlc2V0Jyk7XG5cbiAgICAgICAgbGV0IG9iaiA9IHRoaXM7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXNcbiAgICAgICAgZm9yIChsZXQgcGF0aCBvZiBbXS5jb25jYXQocGF0aHMpKSB7XG4gICAgICAgICAgICBwYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBvYmogPSBvYmouX2lkcy5mb3JrKHBhdGgsIGFkanVzdGVyLCBvYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcnVsZShvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmaW5pdGlvbjtcbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgT2JqZWN0LmtleXMoZGVmLm1vZGlmaWVycykpO1xuXG4gICAgICAgIEFzc2VydCh0aGlzLiRfdGVtcC5ydWxlc2V0ICE9PSBmYWxzZSwgJ0Nhbm5vdCBhcHBseSBydWxlcyB0byBlbXB0eSBydWxlc2V0IG9yIHRoZSBsYXN0IHJ1bGUgYWRkZWQgZG9lcyBub3Qgc3VwcG9ydCBydWxlIHByb3BlcnRpZXMnKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLiRfdGVtcC5ydWxlc2V0ID09PSBudWxsID8gdGhpcy5fcnVsZXMubGVuZ3RoIC0gMSA6IHRoaXMuJF90ZW1wLnJ1bGVzZXQ7XG4gICAgICAgIEFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5fcnVsZXMubGVuZ3RoLCAnQ2Fubm90IGFwcGx5IHJ1bGVzIHRvIGVtcHR5IHJ1bGVzZXQnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgb2JqLl9ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBvYmouX3J1bGVzW2ldO1xuICAgICAgICAgICAgY29uc3QgcnVsZSA9IENsb25lKG9yaWdpbmFsKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBkZWYubW9kaWZpZXJzW25hbWVdKHJ1bGUsIG9wdGlvbnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIEFzc2VydChydWxlLm5hbWUgPT09IG9yaWdpbmFsLm5hbWUsICdDYW5ub3QgY2hhbmdlIHJ1bGUgbmFtZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouX3J1bGVzW2ldID0gcnVsZTtcblxuICAgICAgICAgICAgaWYgKG9iai5fc2luZ2xlUnVsZXMuZ2V0KHJ1bGUubmFtZSkgPT09IG9yaWdpbmFsKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5zZXQocnVsZS5uYW1lLCBydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIGdldCBydWxlc2V0KCkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3Qgc3RhcnQgYSBuZXcgcnVsZXNldCB3aXRob3V0IGNsb3NpbmcgdGhlIHByZXZpb3VzIG9uZScpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gb2JqLl9ydWxlcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZ2V0ICQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZXNldDtcbiAgICB9XG5cbiAgICB0YWlsb3IodGFyZ2V0cykge1xuXG4gICAgICAgIHRhcmdldHMgPSBbXS5jb25jYXQodGFyZ2V0cyk7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCB0YWlsb3IgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIGxldCBvYmogPSB0aGlzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXNcblxuICAgICAgICBpZiAodGhpcy4kX3Rlcm1zLmFsdGVyYXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0LCBhZGp1c3RlciB9IG9mIHRoaXMuJF90ZXJtcy5hbHRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRzLmluY2x1ZGVzKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gYWRqdXN0ZXIob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShvYmopLCAnQWx0ZXJhdGlvbiBhZGp1c3RlciBmb3InLCB0YXJnZXQsICdmYWlsZWQgdG8gcmV0dXJuIGEgc2NoZW1hIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IG9iai4kX21vZGlmeSh7IGVhY2g6IChpdGVtKSA9PiBpdGVtLnRhaWxvcih0YXJnZXRzKSwgcmVmOiBmYWxzZSB9KTtcbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgdHJhY2VyKCkge1xuXG4gICAgICAgIHJldHVybiBUcmFjZS5sb2NhdGlvbiA/IFRyYWNlLmxvY2F0aW9uKHRoaXMpIDogdGhpczsgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgfVxuXG4gICAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gVmFsaWRhdG9yLmVudHJ5KHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZUFzeW5jKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvci5lbnRyeUFzeW5jKHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBFeHRlbnNpb25zXG5cbiAgICAkX2FkZFJ1bGUob3B0aW9ucykge1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBydWxlXG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHsgbmFtZTogb3B0aW9ucyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnSW52YWxpZCBvcHRpb25zJyk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLm5hbWUgJiYgdHlwZW9mIG9wdGlvbnMubmFtZSA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHJ1bGUgbmFtZScpO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIEFzc2VydChrZXlbMF0gIT09ICdfJywgJ0Nhbm5vdCBzZXQgcHJpdmF0ZSBydWxlIHByb3BlcnRpZXMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJ1bGUgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTsgICAgICAgIC8vIFNoYWxsb3cgY2xvbmVkXG4gICAgICAgIHJ1bGUuX3Jlc29sdmUgPSBbXTtcbiAgICAgICAgcnVsZS5tZXRob2QgPSBydWxlLm1ldGhvZCB8fCBydWxlLm5hbWU7XG5cbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuX2RlZmluaXRpb24ucnVsZXNbcnVsZS5tZXRob2RdO1xuICAgICAgICBjb25zdCBhcmdzID0gcnVsZS5hcmdzO1xuXG4gICAgICAgIEFzc2VydChkZWZpbml0aW9uLCAnVW5rbm93biBydWxlJywgcnVsZS5tZXRob2QpO1xuXG4gICAgICAgIC8vIEFyZ3NcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgIEFzc2VydChPYmplY3Qua2V5cyhhcmdzKS5sZW5ndGggPT09IDEgfHwgT2JqZWN0LmtleXMoYXJncykubGVuZ3RoID09PSB0aGlzLl9kZWZpbml0aW9uLnJ1bGVzW3J1bGUubmFtZV0uYXJncy5sZW5ndGgsICdJbnZhbGlkIHJ1bGUgZGVmaW5pdGlvbiBmb3InLCB0aGlzLnR5cGUsIHJ1bGUubmFtZSk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXJnID0gYXJnc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXJnc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5hcmdzQnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZGVmaW5pdGlvbi5hcmdzQnlOYW1lLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5yZWYgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbW1vbi5pc1Jlc29sdmFibGUoYXJnKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLl9yZXNvbHZlLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gcmVzb2x2ZXIubm9ybWFsaXplKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1trZXldID0gYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIuYXNzZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBDb21tb24udmFsaWRhdGVBcmcoYXJnLCBrZXksIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIWVycm9yLCBlcnJvciwgJ29yIHJlZmVyZW5jZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJnc1trZXldID0gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5pcXVlIHJ1bGVzXG5cbiAgICAgICAgaWYgKCFkZWZpbml0aW9uLm11bHRpKSB7XG4gICAgICAgICAgICBvYmouX3J1bGVSZW1vdmUocnVsZS5uYW1lLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgcnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLiRfdGVtcC5ydWxlc2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLnByaW9yaXR5KSB7XG4gICAgICAgICAgICBvYmouX3J1bGVzLnVuc2hpZnQocnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouX3J1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgICRfY29tcGlsZShzY2hlbWEsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gQ29tcGlsZS5zY2hlbWEodGhpcy4kX3Jvb3QsIHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgJF9jcmVhdGVFcnJvcihjb2RlLCB2YWx1ZSwgbG9jYWwsIHN0YXRlLCBwcmVmcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRpb25zLmZsYWdzICE9PSBmYWxzZSA/IHRoaXMuX2ZsYWdzIDoge307XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcyA/IE1lc3NhZ2VzLm1lcmdlKHRoaXMuX2RlZmluaXRpb24ubWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZXMpIDogdGhpcy5fZGVmaW5pdGlvbi5tZXNzYWdlcztcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcnMuUmVwb3J0KGNvZGUsIHZhbHVlLCBsb2NhbCwgZmxhZ3MsIG1lc3NhZ2VzLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgICRfZ2V0RmxhZyhuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsYWdzW25hbWVdO1xuICAgIH1cblxuICAgICRfZ2V0UnVsZShuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpbmdsZVJ1bGVzLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAkX21hcExhYmVscyhwYXRoKSB7XG5cbiAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5faWRzLmxhYmVscyhwYXRoKTtcbiAgICB9XG5cbiAgICAkX21hdGNoKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG92ZXJyaWRlcykge1xuXG4gICAgICAgIHByZWZzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJlZnMpOyAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICBwcmVmcy5hYm9ydEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgcHJlZnMuX2V4dGVybmFscyA9IGZhbHNlO1xuXG4gICAgICAgIHN0YXRlLnNuYXBzaG90KCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICFWYWxpZGF0b3IudmFsaWRhdGUodmFsdWUsIHRoaXMsIHN0YXRlLCBwcmVmcywgb3ZlcnJpZGVzKS5lcnJvcnM7XG4gICAgICAgIHN0YXRlLnJlc3RvcmUoKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgICRfbW9kaWZ5KG9wdGlvbnMpIHtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2VhY2gnLCAnb25jZScsICdyZWYnLCAnc2NoZW1hJ10pO1xuICAgICAgICByZXR1cm4gTW9kaWZ5LnNjaGVtYSh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIH1cblxuICAgICRfbXV0YXRlUmVidWlsZCgpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IGFkZCB0aGlzIHJ1bGUgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIHRoaXMuX3JlZnMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5faWRzLnJlc2V0KCk7XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtLCB7IHNvdXJjZSwgbmFtZSwgcGF0aCwga2V5IH0pID0+IHtcblxuICAgICAgICAgICAgY29uc3QgZmFtaWx5ID0gdGhpcy5fZGVmaW5pdGlvbltzb3VyY2VdW25hbWVdICYmIHRoaXMuX2RlZmluaXRpb25bc291cmNlXVtuYW1lXS5yZWdpc3RlcjtcbiAgICAgICAgICAgIGlmIChmYW1pbHkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kX211dGF0ZVJlZ2lzdGVyKGl0ZW0sIHsgZmFtaWx5LCBrZXkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy4kX21vZGlmeSh7IGVhY2ggfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2RlZmluaXRpb24ucmVidWlsZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVmaW5pdGlvbi5yZWJ1aWxkKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAkX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSwgeyBmYW1pbHksIGtleSB9ID0ge30pIHtcblxuICAgICAgICB0aGlzLl9yZWZzLnJlZ2lzdGVyKHNjaGVtYSwgZmFtaWx5KTtcbiAgICAgICAgdGhpcy5faWRzLnJlZ2lzdGVyKHNjaGVtYSwgeyBrZXkgfSk7XG4gICAgfVxuXG4gICAgJF9wcm9wZXJ0eShuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24ucHJvcGVydGllc1tuYW1lXTtcbiAgICB9XG5cbiAgICAkX3JlYWNoKHBhdGgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5faWRzLnJlYWNoKHBhdGgpO1xuICAgIH1cblxuICAgICRfcm9vdFJlZmVyZW5jZXMoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZnMucm9vdHMoKTtcbiAgICB9XG5cbiAgICAkX3NldEZsYWcobmFtZSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lWzBdID09PSAnXycgfHwgIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHNldCBmbGFnIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBjb25zdCBmbGFnID0gdGhpcy5fZGVmaW5pdGlvbi5mbGFnc1tuYW1lXSB8fCB7fTtcbiAgICAgICAgaWYgKERlZXBFcXVhbCh2YWx1ZSwgZmxhZy5kZWZhdWx0KSkge1xuICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRGVlcEVxdWFsKHZhbHVlLCB0aGlzLl9mbGFnc1tuYW1lXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqLl9mbGFnc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lWzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAkX3BhcmVudChtZXRob2QsIC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2RdW0NvbW1vbi5zeW1ib2xzLnBhcmVudF0uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9XG5cbiAgICAkX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICByZXR1cm4gVmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlLCB0aGlzLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIC8vIEludGVybmFsc1xuXG4gICAgX2Fzc2lnbih0YXJnZXQpIHtcblxuICAgICAgICB0YXJnZXQudHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICB0YXJnZXQuJF9yb290ID0gdGhpcy4kX3Jvb3Q7XG5cbiAgICAgICAgdGFyZ2V0LiRfdGVtcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJF90ZW1wKTtcbiAgICAgICAgdGFyZ2V0LiRfdGVtcC53aGVucyA9IHt9O1xuXG4gICAgICAgIHRhcmdldC5faWRzID0gdGhpcy5faWRzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5fcHJlZmVyZW5jZXMgPSB0aGlzLl9wcmVmZXJlbmNlcztcbiAgICAgICAgdGFyZ2V0Ll92YWxpZHMgPSB0aGlzLl92YWxpZHMgJiYgdGhpcy5fdmFsaWRzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5faW52YWxpZHMgPSB0aGlzLl9pbnZhbGlkcyAmJiB0aGlzLl9pbnZhbGlkcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX3J1bGVzID0gdGhpcy5fcnVsZXMuc2xpY2UoKTtcbiAgICAgICAgdGFyZ2V0Ll9zaW5nbGVSdWxlcyA9IENsb25lKHRoaXMuX3NpbmdsZVJ1bGVzLCB7IHNoYWxsb3c6IHRydWUgfSk7XG4gICAgICAgIHRhcmdldC5fcmVmcyA9IHRoaXMuX3JlZnMuY2xvbmUoKTtcbiAgICAgICAgdGFyZ2V0Ll9mbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2ZsYWdzKTtcbiAgICAgICAgdGFyZ2V0Ll9jYWNoZSA9IG51bGw7XG5cbiAgICAgICAgdGFyZ2V0LiRfdGVybXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy4kX3Rlcm1zKSB7XG4gICAgICAgICAgICB0YXJnZXQuJF90ZXJtc1trZXldID0gdGhpcy4kX3Rlcm1zW2tleV0gPyB0aGlzLiRfdGVybXNba2V5XS5zbGljZSgpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgICAgICAgdGFyZ2V0LiRfc3VwZXIgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBvdmVycmlkZSBpbiB0aGlzLiRfc3VwZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC4kX3N1cGVyW292ZXJyaWRlXSA9IHRoaXMuX3N1cGVyW292ZXJyaWRlXS5iaW5kKHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIF9iYXJlKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9yZXNldCgpO1xuXG4gICAgICAgIGNvbnN0IHRlcm1zID0gb2JqLl9kZWZpbml0aW9uLnRlcm1zO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGVybXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlcm0gPSB0ZXJtc1tuYW1lXTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW25hbWVdID0gdGVybS5pbml0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBfZGVmYXVsdChmbGFnLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgJ2xpdGVyYWwnKTtcblxuICAgICAgICBBc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ01pc3NpbmcnLCBmbGFnLCAndmFsdWUnKTtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhb3B0aW9ucy5saXRlcmFsLCAnT25seSBmdW5jdGlvbiB2YWx1ZSBzdXBwb3J0cyBsaXRlcmFsIG9wdGlvbicpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIG9wdGlvbnMubGl0ZXJhbCkge1xuXG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBbQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF06IHRydWUsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbDogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfc2V0RmxhZyhmbGFnLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiB0aGlzIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2xsZWN0IG1hdGNoaW5nIHdoZW5zXG5cbiAgICAgICAgY29uc3Qgd2hlbnMgPSBbXTtcbiAgICAgICAgY29uc3QgaWRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4kX3Rlcm1zLndoZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB3aGVuID0gdGhpcy4kX3Rlcm1zLndoZW5zW2ldO1xuXG4gICAgICAgICAgICBpZiAod2hlbi5jb25jYXQpIHtcbiAgICAgICAgICAgICAgICB3aGVucy5wdXNoKHdoZW4uY29uY2F0KTtcbiAgICAgICAgICAgICAgICBpZHMucHVzaChgJHtpfS5jb25jYXRgKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB3aGVuLnJlZiA/IHdoZW4ucmVmLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcykgOiB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RzID0gd2hlbi5pcyA/IFt3aGVuXSA6IHdoZW4uc3dpdGNoO1xuICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gaWRzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXMsIHRoZW4sIG90aGVyd2lzZSB9ID0gdGVzdHNbal07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlSWQgPSBgJHtpfSR7d2hlbi5zd2l0Y2ggPyAnLicgKyBqIDogJyd9YDtcbiAgICAgICAgICAgICAgICBpZiAoaXMuJF9tYXRjaChpbnB1dCwgc3RhdGUubmVzdChpcywgYCR7YmFzZUlkfS5pc2ApLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgYCR7YmFzZUlkfS50aGVuYF0sIHN0YXRlLmFuY2VzdG9ycywgc3RhdGUuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYTogZ2VuZXJhdGVkLCBpZCB9ID0gdGhlbi5fZ2VuZXJhdGUodmFsdWUsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5zLnB1c2goZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKGAke2Jhc2VJZH0udGhlbiR7aWQgPyBgKCR7aWR9KWAgOiAnJ31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGAke2Jhc2VJZH0ub3RoZXJ3aXNlYF0sIHN0YXRlLmFuY2VzdG9ycywgc3RhdGUuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hOiBnZW5lcmF0ZWQsIGlkIH0gPSBvdGhlcndpc2UuX2dlbmVyYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIHdoZW5zLnB1c2goZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goYCR7YmFzZUlkfS5vdGhlcndpc2Uke2lkID8gYCgke2lkfSlgIDogJyd9YCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdoZW4uYnJlYWsgJiZcbiAgICAgICAgICAgICAgICBpZHMubGVuZ3RoID4gYmVmb3JlKSB7ICAgICAgICAgIC8vIFNvbWV0aGluZyBtYXRjaGVkXG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGNhY2hlXG5cbiAgICAgICAgY29uc3QgaWQgPSBpZHMuam9pbignLCAnKTtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmRlYnVnKHN0YXRlLCAncnVsZScsICd3aGVuJywgaWQpO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogdGhpcyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS50cmFjZXIuYWN0aXZlICYmXG4gICAgICAgICAgICB0aGlzLiRfdGVtcC53aGVuc1tpZF0pIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiB0aGlzLiRfdGVtcC53aGVuc1tpZF0sIGlkIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBkeW5hbWljIHNjaGVtYVxuXG4gICAgICAgIGxldCBvYmogPSB0aGlzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gICAgICAgIGlmICh0aGlzLl9kZWZpbml0aW9uLmdlbmVyYXRlKSB7XG4gICAgICAgICAgICBvYmogPSB0aGlzLl9kZWZpbml0aW9uLmdlbmVyYXRlKHRoaXMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgd2hlbnNcblxuICAgICAgICBmb3IgKGNvbnN0IHdoZW4gb2Ygd2hlbnMpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iai5jb25jYXQod2hlbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjaW5nXG5cbiAgICAgICAgaWYgKHRoaXMuJF9yb290Ll90cmFjZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJF9yb290Ll90cmFjZXIuX2NvbWJpbmUob2JqLCBbdGhpcywgLi4ud2hlbnNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhY2hlIHJlc3VsdFxuXG4gICAgICAgIHRoaXMuJF90ZW1wLndoZW5zW2lkXSA9IG9iajtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiBvYmosIGlkIH07XG4gICAgfVxuXG4gICAgX2lubmVyKHR5cGUsIHZhbHVlcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgYENhbm5vdCBzZXQgJHt0eXBlfSBpbnNpZGUgYSBydWxlc2V0YCk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoIW9iai4kX3Rlcm1zW3R5cGVdIHx8XG4gICAgICAgICAgICBvcHRpb25zLm92ZXJyaWRlKSB7XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zaW5nbGUpIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdLnB1c2godmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdLnB1c2goLi4udmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9pblJ1bGVzZXQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF90ZW1wLnJ1bGVzZXQgIT09IG51bGwgJiYgdGhpcy4kX3RlbXAucnVsZXNldCAhPT0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3J1bGVSZW1vdmUobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zaW5nbGVSdWxlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuXG4gICAgICAgIG9iai5fc2luZ2xlUnVsZXMuZGVsZXRlKG5hbWUpO1xuXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLl9ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdGVzdCA9IG9iai5fcnVsZXNbaV07XG4gICAgICAgICAgICBpZiAodGVzdC5uYW1lID09PSBuYW1lICYmXG4gICAgICAgICAgICAgICAgIXRlc3Qua2VlcCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iai5faW5SdWxlc2V0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaSA8IG9iai4kX3RlbXAucnVsZXNldCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC0tb2JqLiRfdGVtcC5ydWxlc2V0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKHRlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9ydWxlcyA9IGZpbHRlcmVkO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF92YWx1ZXModmFsdWVzLCBrZXkpIHtcblxuICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsIGtleS5zbGljZSgxLCAtMSkpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBvdmVycmlkZSA9IHZhbHVlc1swXSA9PT0gQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGU7XG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLnNsaWNlKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvYmpba2V5XSAmJlxuICAgICAgICAgICAgdmFsdWVzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBvYmpba2V5XSA9IG5ldyBWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZXMubGVuZ3RoID8gbmV3IFZhbHVlcygpIDogbnVsbDtcbiAgICAgICAgICAgIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIG9ialtrZXldLm92ZXJyaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCBhbGxvdy92YWxpZC9pbnZhbGlkIHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICBBc3NlcnQodmFsdWUgIT09IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlLCAnT3ZlcnJpZGUgbXVzdCBiZSB0aGUgZmlyc3QgdmFsdWUnKTtcblxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBrZXkgPT09ICdfaW52YWxpZHMnID8gJ192YWxpZHMnIDogJ19pbnZhbGlkcyc7XG4gICAgICAgICAgICBpZiAob2JqW290aGVyXSkge1xuICAgICAgICAgICAgICAgIG9ialtvdGhlcl0ucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9ialtvdGhlcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChrZXkgPT09ICdfdmFsaWRzJyB8fCAhb2JqLl9mbGFncy5vbmx5LCAnU2V0dGluZyBpbnZhbGlkIHZhbHVlJywgdmFsdWUsICdsZWF2ZXMgc2NoZW1hIHJlamVjdGluZyBhbGwgdmFsdWVzIGR1ZSB0byBwcmV2aW91cyB2YWxpZCBydWxlJyk7XG4gICAgICAgICAgICAgICAgICAgIG9ialtvdGhlcl0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqW2tleV0uYWRkKHZhbHVlLCBvYmouX3JlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5CYXNlLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy5hbnldID0ge1xuICAgIHZlcnNpb246IENvbW1vbi52ZXJzaW9uLFxuICAgIGNvbXBpbGU6IENvbXBpbGUuY29tcGlsZSxcbiAgICByb290OiAnJF9yb290J1xufTtcblxuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaXNJbW11dGFibGUgPSB0cnVlOyAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzIChtdXN0IGJlIG9uIHByb3RvdHlwZSlcblxuXG4vLyBBbGlhc2VzXG5cbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5kZW55ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZGlzYWxsb3cgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5lcXVhbCA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5leGlzdCA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5yZXF1aXJlZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5ub3QgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5vcHRpb25zID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZzO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZlcmVuY2VzID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZzO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5CYXNlKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtYXg6IDEwMDAsXG4gICAgc3VwcG9ydGVkOiBuZXcgU2V0KFsndW5kZWZpbmVkJywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZyddKVxufTtcblxuXG5leHBvcnRzLnByb3ZpZGVyID0ge1xuXG4gICAgcHJvdmlzaW9uKG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5DYWNoZShvcHRpb25zKTtcbiAgICB9XG59O1xuXG5cbi8vIExlYXN0IFJlY2VudGx5IFVzZWQgKExSVSkgQ2FjaGVcblxuaW50ZXJuYWxzLkNhY2hlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydtYXgnXSk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLm1heCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubWF4ICYmIG9wdGlvbnMubWF4ID4gMCAmJiBpc0Zpbml0ZShvcHRpb25zLm1heCksICdJbnZhbGlkIG1heCBjYWNoZSBzaXplJyk7XG5cbiAgICAgICAgdGhpcy5fbWF4ID0gb3B0aW9ucy5tYXggfHwgaW50ZXJuYWxzLm1heDtcblxuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXAgb2Ygbm9kZXMgYnkga2V5XG4gICAgICAgIHRoaXMuX2xpc3QgPSBuZXcgaW50ZXJuYWxzLkxpc3QoKTsgICAgICAgICAgICAgIC8vIExpc3Qgb2Ygbm9kZXMgKG1vc3QgcmVjZW50bHkgdXNlZCBpbiBoZWFkKVxuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgIWludGVybmFscy5zdXBwb3J0ZWQuaGFzKHR5cGVvZiBrZXkpKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fbGlzdC5maXJzdChub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSB0aGlzLl9saXN0LnVuc2hpZnQoeyBrZXksIHZhbHVlIH0pO1xuICAgICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbm9kZSk7XG4gICAgICAgIHRoaXMuX2NvbXBhY3QoKTtcbiAgICB9XG5cbiAgICBnZXQoa2V5KSB7XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3QuZmlyc3Qobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gQ2xvbmUobm9kZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY29tcGFjdCgpIHtcblxuICAgICAgICBpZiAodGhpcy5fbWFwLnNpemUgPiB0aGlzLl9tYXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9saXN0LnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShub2RlLmtleSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5MaXN0ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB9XG5cbiAgICB1bnNoaWZ0KG5vZGUpIHtcblxuICAgICAgICBub2RlLm5leHQgPSBudWxsO1xuICAgICAgICBub2RlLnByZXYgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkLm5leHQgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcblxuICAgICAgICBpZiAoIXRoaXMudGFpbCkge1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGZpcnN0KG5vZGUpIHtcblxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZW1vdmUobm9kZSk7XG4gICAgICAgIHRoaXMudW5zaGlmdChub2RlKTtcbiAgICB9XG5cbiAgICBwb3AoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZSh0aGlzLnRhaWwpO1xuICAgIH1cblxuICAgIF9yZW1vdmUobm9kZSkge1xuXG4gICAgICAgIGNvbnN0IHsgbmV4dCwgcHJldiB9ID0gbm9kZTtcblxuICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuXG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUucHJldiA9IG51bGw7XG4gICAgICAgIG5vZGUubmV4dCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBBc3NlcnRFcnJvciA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Vycm9yJyk7XG5cbmNvbnN0IFBrZyA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuXG5sZXQgTWVzc2FnZXM7XG5sZXQgU2NoZW1hcztcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgaXNvRGF0ZTogL14oPzpbLStdXFxkezJ9KT8oPzpcXGR7NH0oPyFcXGR7Mn1cXGIpKSg/OigtPykoPzooPzowWzEtOV18MVswLTJdKSg/OlxcMSg/OlsxMl1cXGR8MFsxLTldfDNbMDFdKSk/fFcoPzpbMC00XVxcZHw1WzAtMl0pKD86LT9bMS03XSk/fCg/OjAwWzEtOV18MFsxLTldXFxkfFsxMl1cXGR7Mn18Myg/OlswLTVdXFxkfDZbMS02XSkpKSg/IVtUXSR8W1RdW1xcZF0rWiQpKD86W1RcXHNdKD86KD86KD86WzAxXVxcZHwyWzAtM10pKD86KDo/KVswLTVdXFxkKT98MjRcXDo/MDApKD86Wy4sXVxcZCsoPyE6KSk/KSg/OlxcMlswLTVdXFxkKD86Wy4sXVxcZCspPyk/KD86W1pdfCg/OlsrLV0pKD86WzAxXVxcZHwyWzAtM10pKD86Oj9bMC01XVxcZCk/KT8pPyk/JC9cbn07XG5cblxuZXhwb3J0cy52ZXJzaW9uID0gUGtnLnZlcnNpb247XG5cblxuZXhwb3J0cy5kZWZhdWx0cyA9IHtcbiAgICBhYm9ydEVhcmx5OiB0cnVlLFxuICAgIGFsbG93VW5rbm93bjogZmFsc2UsXG4gICAgYXJ0aWZhY3RzOiBmYWxzZSxcbiAgICBjYWNoZTogdHJ1ZSxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIGNvbnZlcnQ6IHRydWUsXG4gICAgZGF0ZUZvcm1hdDogJ2lzbycsXG4gICAgZXJyb3JzOiB7XG4gICAgICAgIGVzY2FwZUh0bWw6IGZhbHNlLFxuICAgICAgICBsYWJlbDogJ3BhdGgnLFxuICAgICAgICBsYW5ndWFnZTogbnVsbCxcbiAgICAgICAgcmVuZGVyOiB0cnVlLFxuICAgICAgICBzdGFjazogZmFsc2UsXG4gICAgICAgIHdyYXA6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnXCInLFxuICAgICAgICAgICAgYXJyYXk6ICdbXSdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZXJuYWxzOiB0cnVlLFxuICAgIG1lc3NhZ2VzOiB7fSxcbiAgICBub25FbnVtZXJhYmxlczogZmFsc2UsXG4gICAgbm9EZWZhdWx0czogZmFsc2UsXG4gICAgcHJlc2VuY2U6ICdvcHRpb25hbCcsXG4gICAgc2tpcEZ1bmN0aW9uczogZmFsc2UsXG4gICAgc3RyaXBVbmtub3duOiBmYWxzZSxcbiAgICB3YXJuaW5nczogZmFsc2Vcbn07XG5cblxuZXhwb3J0cy5zeW1ib2xzID0ge1xuICAgIGFueTogU3ltYm9sLmZvcignQGhhcGkvam9pL3NjaGVtYScpLCAgICAgICAgICAgIC8vIFVzZWQgdG8gaW50ZXJuYWxseSBpZGVudGlmeSBhbnktYmFzZWQgdHlwZXMgKHNoYXJlZCB3aXRoIG90aGVyIGpvaSB2ZXJzaW9ucylcbiAgICBhcnJheVNpbmdsZTogU3ltYm9sKCdhcnJheVNpbmdsZScpLFxuICAgIGRlZXBEZWZhdWx0OiBTeW1ib2woJ2RlZXBEZWZhdWx0JyksXG4gICAgZXJyb3JzOiBTeW1ib2woJ2Vycm9ycycpLFxuICAgIGxpdGVyYWw6IFN5bWJvbCgnbGl0ZXJhbCcpLFxuICAgIG92ZXJyaWRlOiBTeW1ib2woJ292ZXJyaWRlJyksXG4gICAgcGFyZW50OiBTeW1ib2woJ3BhcmVudCcpLFxuICAgIHByZWZzOiBTeW1ib2woJ3ByZWZzJyksXG4gICAgcmVmOiBTeW1ib2woJ3JlZicpLFxuICAgIHRlbXBsYXRlOiBTeW1ib2woJ3RlbXBsYXRlJyksXG4gICAgdmFsdWVzOiBTeW1ib2woJ3ZhbHVlcycpXG59O1xuXG5cbmV4cG9ydHMuYXNzZXJ0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zLCBrZXlzLCBuYW1lID0gJ09wdGlvbnMnKSB7XG5cbiAgICBBc3NlcnQob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob3B0aW9ucyksICdPcHRpb25zIG11c3QgYmUgb2YgdHlwZSBvYmplY3QnKTtcbiAgICBjb25zdCB1bmtub3duS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcigoaykgPT4gIWtleXMuaW5jbHVkZXMoaykpO1xuICAgIEFzc2VydCh1bmtub3duS2V5cy5sZW5ndGggPT09IDAsIGAke25hbWV9IGNvbnRhaW4gdW5rbm93biBrZXlzOiAke3Vua25vd25LZXlzfWApO1xufTtcblxuXG5leHBvcnRzLmNoZWNrUHJlZmVyZW5jZXMgPSBmdW5jdGlvbiAocHJlZnMpIHtcblxuICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4vc2NoZW1hcycpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gU2NoZW1hcy5wcmVmZXJlbmNlcy52YWxpZGF0ZShwcmVmcyk7XG5cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRFcnJvcihbcmVzdWx0LmVycm9yLmRldGFpbHNbMF0ubWVzc2FnZV0pO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIsIG9wZXJhdG9yKSB7XG5cbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz0nOiByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgY2FzZSAnPic6IHJldHVybiBhID4gYjtcbiAgICAgICAgY2FzZSAnPCc6IHJldHVybiBhIDwgYjtcbiAgICAgICAgY2FzZSAnPj0nOiByZXR1cm4gYSA+PSBiO1xuICAgICAgICBjYXNlICc8PSc6IHJldHVybiBhIDw9IGI7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn07XG5cblxuZXhwb3J0cy5pc0lzb0RhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5pc29EYXRlLnRlc3QoZGF0ZSk7XG59O1xuXG5cbmV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSk7XG59O1xuXG5cbmV4cG9ydHMuaXNSZXNvbHZhYmxlID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmpbZXhwb3J0cy5zeW1ib2xzLnJlZl0gfHwgb2JqW2V4cG9ydHMuc3ltYm9scy50ZW1wbGF0ZV07XG59O1xuXG5cbmV4cG9ydHMuaXNTY2hlbWEgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcblxuICAgIGNvbnN0IGFueSA9IHNjaGVtYSAmJiBzY2hlbWFbZXhwb3J0cy5zeW1ib2xzLmFueV07XG4gICAgaWYgKCFhbnkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIEFzc2VydChvcHRpb25zLmxlZ2FjeSB8fCBhbnkudmVyc2lvbiA9PT0gZXhwb3J0cy52ZXJzaW9uLCAnQ2Fubm90IG1peCBkaWZmZXJlbnQgdmVyc2lvbnMgb2Ygam9pIHNjaGVtYXMnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuZXhwb3J0cy5pc1ZhbHVlcyA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIHJldHVybiBvYmpbZXhwb3J0cy5zeW1ib2xzLnZhbHVlc107XG59O1xuXG5cbmV4cG9ydHMubGltaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gMDtcbn07XG5cblxuZXhwb3J0cy5wcmVmZXJlbmNlcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXG4gICAgTWVzc2FnZXMgPSBNZXNzYWdlcyB8fCByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gICAgc291cmNlID0gc291cmNlIHx8IHt9O1xuXG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBzb3VyY2UpO1xuICAgIGlmIChzb3VyY2UuZXJyb3JzICYmXG4gICAgICAgIHRhcmdldC5lcnJvcnMpIHtcblxuICAgICAgICBtZXJnZWQuZXJyb3JzID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LmVycm9ycywgc291cmNlLmVycm9ycyk7XG4gICAgICAgIG1lcmdlZC5lcnJvcnMud3JhcCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldC5lcnJvcnMud3JhcCwgc291cmNlLmVycm9ycy53cmFwKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLm1lc3NhZ2VzKSB7XG4gICAgICAgIG1lcmdlZC5tZXNzYWdlcyA9IE1lc3NhZ2VzLmNvbXBpbGUoc291cmNlLm1lc3NhZ2VzLCB0YXJnZXQubWVzc2FnZXMpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBtZXJnZWRbZXhwb3J0cy5zeW1ib2xzLnByZWZzXTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufTtcblxuXG5leHBvcnRzLnRyeVdpdGhQYXRoID0gZnVuY3Rpb24gKGZuLCBrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVyci5wYXRoID0ga2V5ICsgJy4nICsgZXJyLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnIucGF0aCA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFwcGVuZCkge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtlcnIubWVzc2FnZX0gKCR7ZXJyLnBhdGh9KWA7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLnZhbGlkYXRlQXJnID0gZnVuY3Rpb24gKHZhbHVlLCBsYWJlbCwgeyBhc3NlcnQsIG1lc3NhZ2UgfSkge1xuXG4gICAgaWYgKGV4cG9ydHMuaXNTY2hlbWEoYXNzZXJ0KSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhc3NlcnQudmFsaWRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5lcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIGlmICghYXNzZXJ0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbGFiZWwgPyBgJHtsYWJlbH0gJHttZXNzYWdlfWAgOiBtZXNzYWdlO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy52ZXJpZnlGbGF0ID0gZnVuY3Rpb24gKGFyZ3MsIG1ldGhvZCkge1xuXG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICBBc3NlcnQoIUFycmF5LmlzQXJyYXkoYXJnKSwgJ01ldGhvZCBubyBsb25nZXIgYWNjZXB0cyBhcnJheSBhcmd1bWVudHM6JywgbWV0aG9kKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5zY2hlbWEgPSBmdW5jdGlvbiAoSm9pLCBjb25maWcsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhcHBlbmRQYXRoJywgJ292ZXJyaWRlJ10pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5zY2hlbWEoSm9pLCBjb25maWcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFwcGVuZFBhdGggJiZcbiAgICAgICAgICAgIGVyci5wYXRoICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtlcnIubWVzc2FnZX0gKCR7ZXJyLnBhdGh9KWA7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuc2NoZW1hID0gZnVuY3Rpb24gKEpvaSwgY29uZmlnLCBvcHRpb25zKSB7XG5cbiAgICBBc3NlcnQoY29uZmlnICE9PSB1bmRlZmluZWQsICdJbnZhbGlkIHVuZGVmaW5lZCBzY2hlbWEnKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgQXNzZXJ0KGNvbmZpZy5sZW5ndGgsICdJbnZhbGlkIGVtcHR5IGFycmF5IHNjaGVtYScpO1xuXG4gICAgICAgIGlmIChjb25maWcubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb25maWcgPSBjb25maWdbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZCA9IChiYXNlLCAuLi52YWx1ZXMpID0+IHtcblxuICAgICAgICBpZiAob3B0aW9ucy5vdmVycmlkZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlLnZhbGlkKEpvaS5vdmVycmlkZSwgLi4udmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlLnZhbGlkKC4uLnZhbHVlcyk7XG4gICAgfTtcblxuICAgIGlmIChpbnRlcm5hbHMuc2ltcGxlKGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gSm9pLmN1c3RvbShjb25maWcpO1xuICAgIH1cblxuICAgIEFzc2VydCh0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JywgJ0ludmFsaWQgc2NoZW1hIGNvbnRlbnQ6JywgdHlwZW9mIGNvbmZpZyk7XG5cbiAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZShjb25maWcpKSB7XG4gICAgICAgIHJldHVybiB2YWxpZChKb2ksIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKENvbW1vbi5pc1NjaGVtYShjb25maWcpKSB7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy5zaW1wbGUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSm9pLmFsdGVybmF0aXZlcygpLnRyeSguLi5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaSwgLi4uY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiBKb2kuc3RyaW5nKCkucmVnZXgoY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLmRhdGUoKSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBBc3NlcnQoT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbmZpZykgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSksICdTY2hlbWEgY2FuIG9ubHkgY29udGFpbiBwbGFpbiBvYmplY3RzJyk7XG5cbiAgICByZXR1cm4gSm9pLm9iamVjdCgpLmtleXMoY29uZmlnKTtcbn07XG5cblxuZXhwb3J0cy5yZWYgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiBSZWYuaXNSZWYoaWQpID8gaWQgOiBSZWYuY3JlYXRlKGlkLCBvcHRpb25zKTtcbn07XG5cblxuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gKHJvb3QsIHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2xlZ2FjeSddKTtcblxuICAgIC8vIENvbXBpbGVkIGJ5IGFueSBzdXBwb3J0ZWQgdmVyc2lvblxuXG4gICAgY29uc3QgYW55ID0gc2NoZW1hICYmIHNjaGVtYVtDb21tb24uc3ltYm9scy5hbnldO1xuICAgIGlmIChhbnkpIHtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMubGVnYWN5IHx8IGFueS52ZXJzaW9uID09PSBDb21tb24udmVyc2lvbiwgJ0Nhbm5vdCBtaXggZGlmZmVyZW50IHZlcnNpb25zIG9mIGpvaSBzY2hlbWFzOicsIGFueS52ZXJzaW9uLCBDb21tb24udmVyc2lvbik7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuXG4gICAgLy8gVW5jb21waWxlZCByb290XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgIW9wdGlvbnMubGVnYWN5KSB7XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc2NoZW1hKHJvb3QsIHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pOyAgICAgICAgICAvLyBXaWxsIGVycm9yIGlmIHNjaGVtYSBjb250YWlucyBvdGhlciB2ZXJzaW9uc1xuICAgIH1cblxuICAgIC8vIFNjYW4gc2NoZW1hIGZvciBjb21waWxlZCBwYXJ0c1xuXG4gICAgY29uc3QgY29tcGlsZXIgPSBpbnRlcm5hbHMud2FsayhzY2hlbWEpO1xuICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc2NoZW1hKHJvb3QsIHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb21waWxlci5jb21waWxlKGNvbXBpbGVyLnJvb3QsIHNjaGVtYSk7XG59O1xuXG5cbmludGVybmFscy53YWxrID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3QgY29tcGlsZXIgPSBpbnRlcm5hbHMud2FsayhpdGVtKTtcbiAgICAgICAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGFueSA9IHNjaGVtYVtDb21tb24uc3ltYm9scy5hbnldO1xuICAgIGlmIChhbnkpIHtcbiAgICAgICAgcmV0dXJuIHsgcm9vdDogc2NoZW1hW2FueS5yb290XSwgY29tcGlsZTogYW55LmNvbXBpbGUgfTtcbiAgICB9XG5cbiAgICBBc3NlcnQoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNjaGVtYSkgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSksICdTY2hlbWEgY2FuIG9ubHkgY29udGFpbiBwbGFpbiBvYmplY3RzJyk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgY29tcGlsZXIgPSBpbnRlcm5hbHMud2FsayhzY2hlbWFba2V5XSk7XG4gICAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbmludGVybmFscy5zaW1wbGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCBbJ2Jvb2xlYW4nLCAnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSk7XG59O1xuXG5cbmV4cG9ydHMud2hlbiA9IGZ1bmN0aW9uIChzY2hlbWEsIGNvbmRpdGlvbiwgb3B0aW9ucykge1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBBc3NlcnQoY29uZGl0aW9uICYmIHR5cGVvZiBjb25kaXRpb24gPT09ICdvYmplY3QnLCAnTWlzc2luZyBvcHRpb25zJyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IGNvbmRpdGlvbjtcbiAgICAgICAgY29uZGl0aW9uID0gUmVmLmNyZWF0ZSgnLicpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHN3aXRjaDogb3B0aW9ucyB9O1xuICAgIH1cblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnaXMnLCAnbm90JywgJ3RoZW4nLCAnb3RoZXJ3aXNlJywgJ3N3aXRjaCcsICdicmVhayddKTtcblxuICAgIC8vIFNjaGVtYSBjb25kaXRpb25cblxuICAgIGlmIChDb21tb24uaXNTY2hlbWEoY29uZGl0aW9uKSkge1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5pcyA9PT0gdW5kZWZpbmVkLCAnXCJpc1wiIGNhbiBub3QgYmUgdXNlZCB3aXRoIGEgc2NoZW1hIGNvbmRpdGlvbicpO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5ub3QgPT09IHVuZGVmaW5lZCwgJ1wibm90XCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggYSBzY2hlbWEgY29uZGl0aW9uJyk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLnN3aXRjaCA9PT0gdW5kZWZpbmVkLCAnXCJzd2l0Y2hcIiBjYW4gbm90IGJlIHVzZWQgd2l0aCBhIHNjaGVtYSBjb25kaXRpb24nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNvbmRpdGlvbihzY2hlbWEsIHsgaXM6IGNvbmRpdGlvbiwgdGhlbjogb3B0aW9ucy50aGVuLCBvdGhlcndpc2U6IG9wdGlvbnMub3RoZXJ3aXNlLCBicmVhazogb3B0aW9ucy5icmVhayB9KTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgY29uZGl0aW9uXG5cbiAgICBBc3NlcnQoUmVmLmlzUmVmKGNvbmRpdGlvbikgfHwgdHlwZW9mIGNvbmRpdGlvbiA9PT0gJ3N0cmluZycsICdJbnZhbGlkIGNvbmRpdGlvbjonLCBjb25kaXRpb24pO1xuICAgIEFzc2VydChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaXMgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjb21iaW5lIFwiaXNcIiB3aXRoIFwibm90XCInKTtcblxuICAgIGlmIChvcHRpb25zLnN3aXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBydWxlID0gb3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMubm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bGUgPSB7IGlzOiBvcHRpb25zLm5vdCwgdGhlbjogb3B0aW9ucy5vdGhlcndpc2UsIG90aGVyd2lzZTogb3B0aW9ucy50aGVuLCBicmVhazogb3B0aW9ucy5icmVhayB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlzID0gcnVsZS5pcyAhPT0gdW5kZWZpbmVkID8gc2NoZW1hLiRfY29tcGlsZShydWxlLmlzKSA6IHNjaGVtYS4kX3Jvb3QuaW52YWxpZChudWxsLCBmYWxzZSwgMCwgJycpLnJlcXVpcmVkKCk7XG4gICAgICAgIEFzc2VydChydWxlLnRoZW4gIT09IHVuZGVmaW5lZCB8fCBydWxlLm90aGVyd2lzZSAhPT0gdW5kZWZpbmVkLCAnb3B0aW9ucyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG9mIFwidGhlblwiLCBcIm90aGVyd2lzZVwiLCBvciBcInN3aXRjaFwiJyk7XG4gICAgICAgIEFzc2VydChydWxlLmJyZWFrID09PSB1bmRlZmluZWQgfHwgcnVsZS50aGVuID09PSB1bmRlZmluZWQgfHwgcnVsZS5vdGhlcndpc2UgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBzcGVjaWZ5IHRoZW4sIG90aGVyd2lzZSwgYW5kIGJyZWFrIGFsbCB0b2dldGhlcicpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmlzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFSZWYuaXNSZWYob3B0aW9ucy5pcykgJiZcbiAgICAgICAgICAgICFDb21tb24uaXNTY2hlbWEob3B0aW9ucy5pcykpIHtcblxuICAgICAgICAgICAgaXMgPSBpcy5yZXF1aXJlZCgpOyAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgcmVxdWlyZWQgaWYgdGhpcyB3YXNuJ3QgYWxyZWFkeSBhIHNjaGVtYSBvciBhIHJlZlxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jb25kaXRpb24oc2NoZW1hLCB7IHJlZjogZXhwb3J0cy5yZWYoY29uZGl0aW9uKSwgaXMsIHRoZW46IHJ1bGUudGhlbiwgb3RoZXJ3aXNlOiBydWxlLm90aGVyd2lzZSwgYnJlYWs6IHJ1bGUuYnJlYWsgfSk7XG4gICAgfVxuXG4gICAgLy8gU3dpdGNoIHN0YXRlbWVudFxuXG4gICAgQXNzZXJ0KEFycmF5LmlzQXJyYXkob3B0aW9ucy5zd2l0Y2gpLCAnXCJzd2l0Y2hcIiBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgQXNzZXJ0KG9wdGlvbnMuaXMgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjb21iaW5lIFwic3dpdGNoXCIgd2l0aCBcImlzXCInKTtcbiAgICBBc3NlcnQob3B0aW9ucy5ub3QgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjb21iaW5lIFwic3dpdGNoXCIgd2l0aCBcIm5vdFwiJyk7XG4gICAgQXNzZXJ0KG9wdGlvbnMudGhlbiA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJzd2l0Y2hcIiB3aXRoIFwidGhlblwiJyk7XG5cbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICByZWY6IGV4cG9ydHMucmVmKGNvbmRpdGlvbiksXG4gICAgICAgIHN3aXRjaDogW10sXG4gICAgICAgIGJyZWFrOiBvcHRpb25zLmJyZWFrXG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5zd2l0Y2gubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdGVzdCA9IG9wdGlvbnMuc3dpdGNoW2ldO1xuICAgICAgICBjb25zdCBsYXN0ID0gaSA9PT0gb3B0aW9ucy5zd2l0Y2gubGVuZ3RoIC0gMTtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyh0ZXN0LCBsYXN0ID8gWydpcycsICd0aGVuJywgJ290aGVyd2lzZSddIDogWydpcycsICd0aGVuJ10pO1xuXG4gICAgICAgIEFzc2VydCh0ZXN0LmlzICE9PSB1bmRlZmluZWQsICdTd2l0Y2ggc3RhdGVtZW50IG1pc3NpbmcgXCJpc1wiJyk7XG4gICAgICAgIEFzc2VydCh0ZXN0LnRoZW4gIT09IHVuZGVmaW5lZCwgJ1N3aXRjaCBzdGF0ZW1lbnQgbWlzc2luZyBcInRoZW5cIicpO1xuXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICBpczogc2NoZW1hLiRfY29tcGlsZSh0ZXN0LmlzKSxcbiAgICAgICAgICAgIHRoZW46IHNjaGVtYS4kX2NvbXBpbGUodGVzdC50aGVuKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghUmVmLmlzUmVmKHRlc3QuaXMpICYmXG4gICAgICAgICAgICAhQ29tbW9uLmlzU2NoZW1hKHRlc3QuaXMpKSB7XG5cbiAgICAgICAgICAgIGl0ZW0uaXMgPSBpdGVtLmlzLnJlcXVpcmVkKCk7ICAgICAgICAgICAvLyBPbmx5IGFwcGx5IHJlcXVpcmVkIGlmIHRoaXMgd2Fzbid0IGFscmVhZHkgYSBzY2hlbWEgb3IgYSByZWZcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBBc3NlcnQob3B0aW9ucy5vdGhlcndpc2UgPT09IHVuZGVmaW5lZCB8fCB0ZXN0Lm90aGVyd2lzZSA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHNwZWNpZnkgXCJvdGhlcndpc2VcIiBpbnNpZGUgYW5kIG91dHNpZGUgYSBcInN3aXRjaFwiJyk7XG4gICAgICAgICAgICBjb25zdCBvdGhlcndpc2UgPSBvcHRpb25zLm90aGVyd2lzZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vdGhlcndpc2UgOiB0ZXN0Lm90aGVyd2lzZTtcbiAgICAgICAgICAgIGlmIChvdGhlcndpc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIEFzc2VydChydWxlLmJyZWFrID09PSB1bmRlZmluZWQsICdDYW5ub3Qgc3BlY2lmeSBib3RoIG90aGVyd2lzZSBhbmQgYnJlYWsnKTtcbiAgICAgICAgICAgICAgICBpdGVtLm90aGVyd2lzZSA9IHNjaGVtYS4kX2NvbXBpbGUob3RoZXJ3aXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bGUuc3dpdGNoLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGU7XG59O1xuXG5cbmludGVybmFscy5jb25kaXRpb24gPSBmdW5jdGlvbiAoc2NoZW1hLCBjb25kaXRpb24pIHtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIFsndGhlbicsICdvdGhlcndpc2UnXSkge1xuICAgICAgICBpZiAoY29uZGl0aW9uW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmRpdGlvbltrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uZGl0aW9uW2tleV0gPSBzY2hlbWEuJF9jb21waWxlKGNvbmRpdGlvbltrZXldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb25kaXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBbm5vdGF0ZSA9IHJlcXVpcmUoJy4vYW5ub3RhdGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLlJlcG9ydCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIHZhbHVlLCBsb2NhbCwgZmxhZ3MsIG1lc3NhZ2VzLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5wYXRoID0gc3RhdGUucGF0aDtcbiAgICAgICAgdGhpcy5wcmVmcyA9IHByZWZzO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWwgfHwge307XG4gICAgICAgIHRoaXMubG9jYWwubGFiZWwgPSBleHBvcnRzLmxhYmVsKHRoaXMuZmxhZ3MsIHRoaXMuc3RhdGUsIHRoaXMucHJlZnMsIHRoaXMubWVzc2FnZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmxvY2FsLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG5cbiAgICAgICAgICAgIHRoaXMubG9jYWwudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmtleSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZmxhZ3MubGFiZWwgJiZcbiAgICAgICAgICAgIHRoaXMucGF0aC5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gdGhpcy5fdGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgJ3Jvb3QnKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmxhYmVsID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLmNvZGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZWZzLmVycm9ycy5yZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlKHRoaXMudGVtcGxhdGUpIHx8XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSh0aGlzLnByZWZzLm1lc3NhZ2VzKSB8fFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUodGhpcy5tZXNzYWdlcyk7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgY29kZSBcIiR7Y29kZX1cIiBpcyBub3QgZGVmaW5lZCwgeW91ciBjdXN0b20gdHlwZSBpcyBtaXNzaW5nIHRoZSBjb3JyZWN0IG1lc3NhZ2VzIGRlZmluaXRpb25gO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIGFuZCBjYWNoZSByZXN1bHRcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0ZW1wbGF0ZS5yZW5kZXIodGhpcy52YWx1ZSwgdGhpcy5zdGF0ZSwgdGhpcy5wcmVmcywgdGhpcy5sb2NhbCwgeyBlcnJvcnM6IHRoaXMucHJlZnMuZXJyb3JzLCBtZXNzYWdlczogW3RoaXMucHJlZnMubWVzc2FnZXMsIHRoaXMubWVzc2FnZXNdIH0pO1xuICAgICAgICBpZiAoIXRoaXMucHJlZnMuZXJyb3JzLmxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2UucmVwbGFjZSgvXlwiXCIgLywgJycpLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgX3RlbXBsYXRlKG1lc3NhZ2VzLCBjb2RlKSB7XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudGVtcGxhdGUodGhpcy52YWx1ZSwgbWVzc2FnZXMsIGNvZGUgfHwgdGhpcy5jb2RlLCB0aGlzLnN0YXRlLCB0aGlzLnByZWZzKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMucGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICBsZXQgbGFiZWwgPSAnJztcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdvYmplY3QnKSB7ICAgICAgICAgIC8vIEV4Y2x1ZGUgYXJyYXkgc2luZ2xlIHBhdGggc2VnbWVudFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCArPSAnLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVsICs9IHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbCArPSBgWyR7c2VnbWVudH1dYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn07XG5cblxuZXhwb3J0cy50ZW1wbGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZXMsIGNvZGUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZXMpKSB7XG4gICAgICAgIHJldHVybiBjb2RlICE9PSAncm9vdCcgPyBtZXNzYWdlcyA6IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGxhbmcgPSBwcmVmcy5lcnJvcnMubGFuZ3VhZ2U7XG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUobGFuZykpIHtcbiAgICAgICAgbGFuZyA9IGxhbmcucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpZiAobGFuZyAmJlxuICAgICAgICBtZXNzYWdlc1tsYW5nXSkge1xuXG4gICAgICAgIGlmIChtZXNzYWdlc1tsYW5nXVtjb2RlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXNbbGFuZ11bY29kZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVzc2FnZXNbbGFuZ11bJyonXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXNbbGFuZ11bJyonXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbWVzc2FnZXNbY29kZV0pIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzWycqJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VzW2NvZGVdO1xufTtcblxuXG5leHBvcnRzLmxhYmVsID0gZnVuY3Rpb24gKGZsYWdzLCBzdGF0ZSwgcHJlZnMsIG1lc3NhZ2VzKSB7XG5cbiAgICBpZiAoZmxhZ3MubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGZsYWdzLmxhYmVsO1xuICAgIH1cblxuICAgIGlmICghcHJlZnMuZXJyb3JzLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IHN0YXRlLnBhdGg7XG4gICAgaWYgKHByZWZzLmVycm9ycy5sYWJlbCA9PT0gJ2tleScgJiZcbiAgICAgICAgc3RhdGUucGF0aC5sZW5ndGggPiAxKSB7XG5cbiAgICAgICAgcGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoLTEpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBleHBvcnRzLnBhdGgocGF0aCk7XG4gICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMudGVtcGxhdGUobnVsbCwgcHJlZnMubWVzc2FnZXMsICdyb290Jywgc3RhdGUsIHByZWZzKSB8fFxuICAgICAgICBtZXNzYWdlcyAmJiBleHBvcnRzLnRlbXBsYXRlKG51bGwsIG1lc3NhZ2VzLCAncm9vdCcsIHN0YXRlLCBwcmVmcykgfHxcbiAgICAgICAgJ3ZhbHVlJztcbn07XG5cblxuZXhwb3J0cy5wcm9jZXNzID0gZnVuY3Rpb24gKGVycm9ycywgb3JpZ2luYWwsIHByZWZzKSB7XG5cbiAgICBpZiAoIWVycm9ycykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7IG92ZXJyaWRlLCBtZXNzYWdlLCBkZXRhaWxzIH0gPSBleHBvcnRzLmRldGFpbHMoZXJyb3JzKTtcbiAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgIH1cblxuICAgIGlmIChwcmVmcy5lcnJvcnMuc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcihtZXNzYWdlLCBkZXRhaWxzLCBvcmlnaW5hbCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMDtcbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgZGV0YWlscywgb3JpZ2luYWwpO1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIHJldHVybiB2YWxpZGF0aW9uRXJyb3I7XG59O1xuXG5cbmV4cG9ydHMuZGV0YWlscyA9IGZ1bmN0aW9uIChlcnJvcnMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgbGV0IG1lc3NhZ2VzID0gW107XG4gICAgY29uc3QgZGV0YWlscyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGVycm9ycykge1xuXG4gICAgICAgIC8vIE92ZXJyaWRlXG5cbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3ZlcnJpZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcnJpZGU6IGl0ZW0gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGRldGFpbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHsgZXJyb3I6IGl0ZW0gfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVwb3J0XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgbWVzc2FnZXMucHVzaChtZXNzYWdlKTtcblxuICAgICAgICBkZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHBhdGg6IGl0ZW0ucGF0aC5maWx0ZXIoKHYpID0+IHR5cGVvZiB2ICE9PSAnb2JqZWN0JyksXG4gICAgICAgICAgICB0eXBlOiBpdGVtLmNvZGUsXG4gICAgICAgICAgICBjb250ZXh0OiBpdGVtLmxvY2FsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1lc3NhZ2VzID0gWy4uLm5ldyBTZXQobWVzc2FnZXMpXTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlcy5qb2luKCcuICcpLCBkZXRhaWxzIH07XG59O1xuXG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzLCBvcmlnaW5hbCkge1xuXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbCA9IG9yaWdpbmFsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0Vycm9yKGVycikge1xuXG4gICAgICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiBleHBvcnRzLlZhbGlkYXRpb25FcnJvcjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5pc0pvaSA9IHRydWU7XG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcic7XG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5hbm5vdGF0ZSA9IEFubm90YXRlLmVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IE1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uIChmcm9tLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBiYXNlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZyb20pO1xuICAgIGNvbnN0IHByb3RvdHlwZSA9IENsb25lKGJhc2UpO1xuICAgIGNvbnN0IHNjaGVtYSA9IGZyb20uX2Fzc2lnbihPYmplY3QuY3JlYXRlKHByb3RvdHlwZSkpO1xuICAgIGNvbnN0IGRlZiA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWxsb3cgY2xvbmVkXG4gICAgZGVsZXRlIGRlZi5iYXNlO1xuXG4gICAgcHJvdG90eXBlLl9kZWZpbml0aW9uID0gZGVmO1xuXG4gICAgY29uc3QgcGFyZW50ID0gYmFzZS5fZGVmaW5pdGlvbiB8fCB7fTtcbiAgICBkZWYubWVzc2FnZXMgPSBNZXNzYWdlcy5tZXJnZShwYXJlbnQubWVzc2FnZXMsIGRlZi5tZXNzYWdlcyk7XG4gICAgZGVmLnByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQucHJvcGVydGllcywgZGVmLnByb3BlcnRpZXMpO1xuXG4gICAgLy8gVHlwZVxuXG4gICAgc2NoZW1hLnR5cGUgPSBkZWYudHlwZTtcblxuICAgIC8vIEZsYWdzXG5cbiAgICBkZWYuZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQuZmxhZ3MsIGRlZi5mbGFncyk7XG5cbiAgICAvLyBUZXJtc1xuXG4gICAgY29uc3QgdGVybXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQudGVybXMpO1xuICAgIGlmIChkZWYudGVybXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlZi50ZXJtcykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGx5IG93biB0ZXJtc1xuICAgICAgICAgICAgY29uc3QgdGVybSA9IGRlZi50ZXJtc1tuYW1lXTtcbiAgICAgICAgICAgIEFzc2VydChzY2hlbWEuJF90ZXJtc1tuYW1lXSA9PT0gdW5kZWZpbmVkLCAnSW52YWxpZCB0ZXJtIG92ZXJyaWRlIGZvcicsIGRlZi50eXBlLCBuYW1lKTtcbiAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zW25hbWVdID0gdGVybS5pbml0O1xuICAgICAgICAgICAgdGVybXNbbmFtZV0gPSB0ZXJtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLnRlcm1zID0gdGVybXM7XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBhcmd1bWVudHNcblxuICAgIGlmICghZGVmLmFyZ3MpIHtcbiAgICAgICAgZGVmLmFyZ3MgPSBwYXJlbnQuYXJncztcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlXG5cbiAgICBkZWYucHJlcGFyZSA9IGludGVybmFscy5wcmVwYXJlKGRlZi5wcmVwYXJlLCBwYXJlbnQucHJlcGFyZSk7XG5cbiAgICAvLyBDb2VyY2VcblxuICAgIGlmIChkZWYuY29lcmNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmLmNvZXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVmLmNvZXJjZSA9IHsgbWV0aG9kOiBkZWYuY29lcmNlIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmLmNvZXJjZS5mcm9tICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheShkZWYuY29lcmNlLmZyb20pKSB7XG5cbiAgICAgICAgICAgIGRlZi5jb2VyY2UgPSB7IG1ldGhvZDogZGVmLmNvZXJjZS5tZXRob2QsIGZyb206IFtdLmNvbmNhdChkZWYuY29lcmNlLmZyb20pIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYuY29lcmNlID0gaW50ZXJuYWxzLmNvZXJjZShkZWYuY29lcmNlLCBwYXJlbnQuY29lcmNlKTtcblxuICAgIC8vIFZhbGlkYXRlXG5cbiAgICBkZWYudmFsaWRhdGUgPSBpbnRlcm5hbHMudmFsaWRhdGUoZGVmLnZhbGlkYXRlLCBwYXJlbnQudmFsaWRhdGUpO1xuXG4gICAgLy8gUnVsZXNcblxuICAgIGNvbnN0IHJ1bGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LnJ1bGVzKTtcbiAgICBpZiAoZGVmLnJ1bGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWYucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBkZWYucnVsZXNbbmFtZV07XG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIHJ1bGUgPT09ICdvYmplY3QnLCAnSW52YWxpZCBydWxlIGRlZmluaXRpb24gZm9yJywgZGVmLnR5cGUsIG5hbWUpO1xuXG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gcnVsZS5tZXRob2Q7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXByb3RvdHlwZVtuYW1lXSwgJ1J1bGUgY29uZmxpY3QgaW4nLCBkZWYudHlwZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgcHJvdG90eXBlW25hbWVdID0gbWV0aG9kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQoIXJ1bGVzW25hbWVdLCAnUnVsZSBjb25mbGljdCBpbicsIGRlZi50eXBlLCBuYW1lKTtcbiAgICAgICAgICAgIHJ1bGVzW25hbWVdID0gcnVsZTtcblxuICAgICAgICAgICAgaWYgKHJ1bGUuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGlhc2VzID0gW10uY29uY2F0KHJ1bGUuYWxpYXMpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgICAgICAgICAgICAgICBwcm90b3R5cGVbYWxpYXNdID0gcnVsZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcnVsZS5hcmdzQnlOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHJ1bGUuYXJncyA9IHJ1bGUuYXJncy5tYXAoKGFyZykgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0geyBuYW1lOiBhcmcgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCghcnVsZS5hcmdzQnlOYW1lLmhhcyhhcmcubmFtZSksICdEdXBsaWNhdGVkIGFyZ3VtZW50IG5hbWUnLCBhcmcubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYShhcmcuYXNzZXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnLmFzc2VydCA9IGFyZy5hc3NlcnQuc3RyaWN0KCkubGFiZWwoYXJnLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcnVsZS5hcmdzQnlOYW1lLnNldChhcmcubmFtZSwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi5ydWxlcyA9IHJ1bGVzO1xuXG4gICAgLy8gTW9kaWZpZXJzXG5cbiAgICBjb25zdCBtb2RpZmllcnMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQubW9kaWZpZXJzKTtcbiAgICBpZiAoZGVmLm1vZGlmaWVycykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVmLm1vZGlmaWVycykge1xuICAgICAgICAgICAgQXNzZXJ0KCFwcm90b3R5cGVbbmFtZV0sICdSdWxlIGNvbmZsaWN0IGluJywgZGVmLnR5cGUsIG5hbWUpO1xuXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllciA9IGRlZi5tb2RpZmllcnNbbmFtZV07XG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIG1vZGlmaWVyID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBtb2RpZmllciBkZWZpbml0aW9uIGZvcicsIGRlZi50eXBlLCBuYW1lKTtcblxuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gZnVuY3Rpb24gKGFyZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVsZSh7IFtuYW1lXTogYXJnIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcHJvdG90eXBlW25hbWVdID0gbWV0aG9kO1xuICAgICAgICAgICAgbW9kaWZpZXJzW25hbWVdID0gbW9kaWZpZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuXG4gICAgLy8gT3ZlcnJpZGVzXG5cbiAgICBpZiAoZGVmLm92ZXJyaWRlcykge1xuICAgICAgICBwcm90b3R5cGUuX3N1cGVyID0gYmFzZTtcbiAgICAgICAgc2NoZW1hLiRfc3VwZXIgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICBmb3IgKGNvbnN0IG92ZXJyaWRlIGluIGRlZi5vdmVycmlkZXMpIHtcbiAgICAgICAgICAgIEFzc2VydChiYXNlW292ZXJyaWRlXSwgJ0Nhbm5vdCBvdmVycmlkZSBtaXNzaW5nJywgb3ZlcnJpZGUpO1xuICAgICAgICAgICAgZGVmLm92ZXJyaWRlc1tvdmVycmlkZV1bQ29tbW9uLnN5bWJvbHMucGFyZW50XSA9IGJhc2Vbb3ZlcnJpZGVdO1xuICAgICAgICAgICAgc2NoZW1hLiRfc3VwZXJbb3ZlcnJpZGVdID0gYmFzZVtvdmVycmlkZV0uYmluZChzY2hlbWEpOyAgICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKHByb3RvdHlwZSwgZGVmLm92ZXJyaWRlcyk7XG4gICAgfVxuXG4gICAgLy8gQ2FzdHNcblxuICAgIGRlZi5jYXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LmNhc3QsIGRlZi5jYXN0KTtcblxuICAgIC8vIE1hbmlmZXN0XG5cbiAgICBjb25zdCBtYW5pZmVzdCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5tYW5pZmVzdCwgZGVmLm1hbmlmZXN0KTtcbiAgICBtYW5pZmVzdC5idWlsZCA9IGludGVybmFscy5idWlsZChkZWYubWFuaWZlc3QgJiYgZGVmLm1hbmlmZXN0LmJ1aWxkLCBwYXJlbnQubWFuaWZlc3QgJiYgcGFyZW50Lm1hbmlmZXN0LmJ1aWxkKTtcbiAgICBkZWYubWFuaWZlc3QgPSBtYW5pZmVzdDtcblxuICAgIC8vIFJlYnVpbGRcblxuICAgIGRlZi5yZWJ1aWxkID0gaW50ZXJuYWxzLnJlYnVpbGQoZGVmLnJlYnVpbGQsIHBhcmVudC5yZWJ1aWxkKTtcblxuICAgIHJldHVybiBzY2hlbWE7XG59O1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmJ1aWxkID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGRlc2MpIHtcblxuICAgICAgICByZXR1cm4gcGFyZW50KGNoaWxkKG9iaiwgZGVzYyksIGRlc2MpO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5jb2VyY2UgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBjaGlsZC5mcm9tICYmIHBhcmVudC5mcm9tID8gWy4uLm5ldyBTZXQoWy4uLmNoaWxkLmZyb20sIC4uLnBhcmVudC5mcm9tXSldIDogbnVsbCxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgIGxldCBjb2VyY2VkO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIHBhcmVudC5mcm9tLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIGNvZXJjZWQgPSBwYXJlbnQubWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAoY29lcmNlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29lcmNlZC5lcnJvcnMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZXJjZWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2hpbGQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIGNoaWxkLmZyb20uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3duID0gY2hpbGQubWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAob3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvd247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5cbmludGVybmFscy5wcmVwYXJlID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgIGNvbnN0IHByZXBhcmVkID0gY2hpbGQodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAocHJlcGFyZWQpIHtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZC5lcnJvcnMgfHxcbiAgICAgICAgICAgICAgICBwcmVwYXJlZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlcGFyZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gcHJlcGFyZWQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50KHZhbHVlLCBoZWxwZXJzKSB8fCBwcmVwYXJlZDtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMucmVidWlsZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICAgICAgcGFyZW50KHNjaGVtYSk7XG4gICAgICAgIGNoaWxkKHNjaGVtYSk7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcmVudCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzICYmXG4gICAgICAgICAgICAgICAgKCFBcnJheS5pc0FycmF5KHJlc3VsdC5lcnJvcnMpIHx8IHJlc3VsdC5lcnJvcnMubGVuZ3RoKSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQodmFsdWUsIGhlbHBlcnMpIHx8IHJlc3VsdDtcbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBFeHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuY29uc3QgTWFuaWZlc3QgPSByZXF1aXJlKCcuL21hbmlmZXN0Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5jb25zdCBUcmFjZSA9IHJlcXVpcmUoJy4vdHJhY2UnKTtcblxubGV0IFNjaGVtYXM7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHR5cGVzOiB7XG4gICAgICAgIGFsdGVybmF0aXZlczogcmVxdWlyZSgnLi90eXBlcy9hbHRlcm5hdGl2ZXMnKSxcbiAgICAgICAgYW55OiByZXF1aXJlKCcuL3R5cGVzL2FueScpLFxuICAgICAgICBhcnJheTogcmVxdWlyZSgnLi90eXBlcy9hcnJheScpLFxuICAgICAgICBib29sZWFuOiByZXF1aXJlKCcuL3R5cGVzL2Jvb2xlYW4nKSxcbiAgICAgICAgZGF0ZTogcmVxdWlyZSgnLi90eXBlcy9kYXRlJyksXG4gICAgICAgIGZ1bmN0aW9uOiByZXF1aXJlKCcuL3R5cGVzL2Z1bmN0aW9uJyksXG4gICAgICAgIGxpbms6IHJlcXVpcmUoJy4vdHlwZXMvbGluaycpLFxuICAgICAgICBudW1iZXI6IHJlcXVpcmUoJy4vdHlwZXMvbnVtYmVyJyksXG4gICAgICAgIG9iamVjdDogcmVxdWlyZSgnLi90eXBlcy9vYmplY3QnKSxcbiAgICAgICAgc3RyaW5nOiByZXF1aXJlKCcuL3R5cGVzL3N0cmluZycpLFxuICAgICAgICBzeW1ib2w6IHJlcXVpcmUoJy4vdHlwZXMvc3ltYm9sJylcbiAgICB9LFxuICAgIGFsaWFzZXM6IHtcbiAgICAgICAgYWx0OiAnYWx0ZXJuYXRpdmVzJyxcbiAgICAgICAgYm9vbDogJ2Jvb2xlYW4nLFxuICAgICAgICBmdW5jOiAnZnVuY3Rpb24nXG4gICAgfVxufTtcblxuXG5pZiAoQnVmZmVyKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICBpbnRlcm5hbHMudHlwZXMuYmluYXJ5ID0gcmVxdWlyZSgnLi90eXBlcy9iaW5hcnknKTtcbn1cblxuXG5pbnRlcm5hbHMucm9vdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHJvb3QgPSB7XG4gICAgICAgIF90eXBlczogbmV3IFNldChPYmplY3Qua2V5cyhpbnRlcm5hbHMudHlwZXMpKVxuICAgIH07XG5cbiAgICAvLyBUeXBlc1xuXG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHJvb3QuX3R5cGVzKSB7XG4gICAgICAgIHJvb3RbdHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICBBc3NlcnQoIWFyZ3MubGVuZ3RoIHx8IFsnYWx0ZXJuYXRpdmVzJywgJ2xpbmsnLCAnb2JqZWN0J10uaW5jbHVkZXModHlwZSksICdUaGUnLCB0eXBlLCAndHlwZSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUodGhpcywgaW50ZXJuYWxzLnR5cGVzW3R5cGVdLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBTaG9ydGN1dHNcblxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIFsnYWxsb3cnLCAnY3VzdG9tJywgJ2Rpc2FsbG93JywgJ2VxdWFsJywgJ2V4aXN0JywgJ2ZvcmJpZGRlbicsICdpbnZhbGlkJywgJ25vdCcsICdvbmx5JywgJ29wdGlvbmFsJywgJ29wdGlvbnMnLCAncHJlZnMnLCAncHJlZmVyZW5jZXMnLCAncmVxdWlyZWQnLCAnc3RyaXAnLCAndmFsaWQnLCAnd2hlbiddKSB7XG4gICAgICAgIHJvb3RbbWV0aG9kXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFueSgpW21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTWV0aG9kc1xuXG4gICAgT2JqZWN0LmFzc2lnbihyb290LCBpbnRlcm5hbHMubWV0aG9kcyk7XG5cbiAgICAvLyBBbGlhc2VzXG5cbiAgICBmb3IgKGNvbnN0IGFsaWFzIGluIGludGVybmFscy5hbGlhc2VzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGludGVybmFscy5hbGlhc2VzW2FsaWFzXTtcbiAgICAgICAgcm9vdFthbGlhc10gPSByb290W3RhcmdldF07XG4gICAgfVxuXG4gICAgcm9vdC54ID0gcm9vdC5leHByZXNzaW9uO1xuXG4gICAgLy8gVHJhY2VcblxuICAgIGlmIChUcmFjZS5zZXR1cCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICBUcmFjZS5zZXR1cChyb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbn07XG5cblxuaW50ZXJuYWxzLm1ldGhvZHMgPSB7XG5cbiAgICBWYWxpZGF0aW9uRXJyb3I6IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IsXG4gICAgdmVyc2lvbjogQ29tbW9uLnZlcnNpb24sXG4gICAgY2FjaGU6IENhY2hlLnByb3ZpZGVyLFxuXG4gICAgYXNzZXJ0KHZhbHVlLCBzY2hlbWEsIC4uLmFyZ3MgLyogW21lc3NhZ2VdLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICBpbnRlcm5hbHMuYXNzZXJ0KHZhbHVlLCBzY2hlbWEsIHRydWUsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICBhdHRlbXB0KHZhbHVlLCBzY2hlbWEsIC4uLmFyZ3MgLyogW21lc3NhZ2VdLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmFzc2VydCh2YWx1ZSwgc2NoZW1hLCBmYWxzZSwgYXJncyk7XG4gICAgfSxcblxuICAgIGJ1aWxkKGRlc2MpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIE1hbmlmZXN0LmJ1aWxkID09PSAnZnVuY3Rpb24nLCAnTWFuaWZlc3QgZnVuY3Rpb25hbGl0eSBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gTWFuaWZlc3QuYnVpbGQodGhpcywgZGVzYyk7XG4gICAgfSxcblxuICAgIGNoZWNrUHJlZmVyZW5jZXMocHJlZnMpIHtcblxuICAgICAgICBDb21tb24uY2hlY2tQcmVmZXJlbmNlcyhwcmVmcyk7XG4gICAgfSxcblxuICAgIGNvbXBpbGUoc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIENvbXBpbGUuY29tcGlsZSh0aGlzLCBzY2hlbWEsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBkZWZhdWx0cyhtb2RpZmllcikge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbW9kaWZpZXIgPT09ICdmdW5jdGlvbicsICdtb2RpZmllciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGpvaS5fdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IG1vZGlmaWVyKGpvaVt0eXBlXSgpKTtcbiAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc2NoZW1hKSwgJ21vZGlmaWVyIG11c3QgcmV0dXJuIGEgdmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuXG4gICAgICAgICAgICBqb2lbdHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZSh0aGlzLCBzY2hlbWEsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqb2k7XG4gICAgfSxcblxuICAgIGV4cHJlc3Npb24oLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGUoLi4uYXJncyk7XG4gICAgfSxcblxuICAgIGV4dGVuZCguLi5leHRlbnNpb25zKSB7XG5cbiAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQoZXh0ZW5zaW9ucywgJ2V4dGVuZCcpO1xuXG4gICAgICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4vc2NoZW1hcycpO1xuXG4gICAgICAgIEFzc2VydChleHRlbnNpb25zLmxlbmd0aCwgJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYXQgbGVhc3Qgb25lIGV4dGVuc2lvbicpO1xuICAgICAgICB0aGlzLmFzc2VydChleHRlbnNpb25zLCBTY2hlbWFzLmV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGNvbnN0IGpvaSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMpO1xuICAgICAgICBqb2kuX3R5cGVzID0gbmV3IFNldChqb2kuX3R5cGVzKTtcblxuICAgICAgICBmb3IgKGxldCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24oam9pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9uLCBTY2hlbWFzLmV4dGVuc2lvbik7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkID0gaW50ZXJuYWxzLmV4cGFuZEV4dGVuc2lvbihleHRlbnNpb24sIGpvaSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoam9pW2l0ZW0udHlwZV0gPT09IHVuZGVmaW5lZCB8fCBqb2kuX3R5cGVzLmhhcyhpdGVtLnR5cGUpLCAnQ2Fubm90IG92ZXJyaWRlIG5hbWUnLCBpdGVtLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IGl0ZW0uYmFzZSB8fCB0aGlzLmFueSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IEV4dGVuZC50eXBlKGJhc2UsIGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgam9pLl90eXBlcy5hZGQoaXRlbS50eXBlKTtcbiAgICAgICAgICAgICAgICBqb2lbaXRlbS50eXBlXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZSh0aGlzLCBzY2hlbWEsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH0sXG5cbiAgICBpc0Vycm9yOiBFcnJvcnMuVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IsXG4gICAgaXNFeHByZXNzaW9uOiBUZW1wbGF0ZS5pc1RlbXBsYXRlLFxuICAgIGlzUmVmOiBSZWYuaXNSZWYsXG4gICAgaXNTY2hlbWE6IENvbW1vbi5pc1NjaGVtYSxcblxuICAgIGluKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gUmVmLmluKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICBvdmVycmlkZTogQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGUsXG5cbiAgICByZWYoLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBSZWYuY3JlYXRlKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICB0eXBlcygpIHtcblxuICAgICAgICBjb25zdCB0eXBlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdGhpcy5fdHlwZXMpIHtcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gdGhpc1t0eXBlXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgaW4gaW50ZXJuYWxzLmFsaWFzZXMpIHtcbiAgICAgICAgICAgIHR5cGVzW3RhcmdldF0gPSB0aGlzW3RhcmdldF0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG59O1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmFzc2VydCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBhbm5vdGF0ZSwgYXJncyAvKiBbbWVzc2FnZV0sIFtvcHRpb25zXSAqLykge1xuXG4gICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NbMF0gaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgPyBhcmdzWzBdIDogbnVsbDtcbiAgICBjb25zdCBvcHRpb25zID0gbWVzc2FnZSA/IGFyZ3NbMV0gOiBhcmdzWzBdO1xuICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS52YWxpZGF0ZSh2YWx1ZSwgQ29tbW9uLnByZWZlcmVuY2VzKHsgZXJyb3JzOiB7IHN0YWNrOiB0cnVlIH0gfSwgb3B0aW9ucyB8fCB7fSkpO1xuXG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgY29uc3QgZGlzcGxheSA9IGFubm90YXRlICYmIHR5cGVvZiBlcnJvci5hbm5vdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGVycm9yLmFubm90YXRlKCkgOiBlcnJvci5tZXNzYWdlO1xuXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3JzLlZhbGlkYXRpb25FcnJvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgZXJyb3IgPSBDbG9uZShlcnJvcik7XG4gICAgfVxuXG4gICAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2UgPyBgJHttZXNzYWdlfSAke2Rpc3BsYXl9YCA6IGRpc3BsYXk7XG4gICAgdGhyb3cgZXJyb3I7XG59O1xuXG5cbmludGVybmFscy5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChyb290LCBzY2hlbWEsIGFyZ3MpIHtcblxuICAgIEFzc2VydChyb290LCAnTXVzdCBiZSBpbnZva2VkIG9uIGEgSm9pIGluc3RhbmNlLicpO1xuXG4gICAgc2NoZW1hLiRfcm9vdCA9IHJvb3Q7XG5cbiAgICBpZiAoIXNjaGVtYS5fZGVmaW5pdGlvbi5hcmdzIHx8XG4gICAgICAgICFhcmdzLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS5fZGVmaW5pdGlvbi5hcmdzKHNjaGVtYSwgLi4uYXJncyk7XG59O1xuXG5cbmludGVybmFscy5leHBhbmRFeHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0ZW5zaW9uLCBqb2kpIHtcblxuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRlbmRlZCA9IFtdO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBqb2kuX3R5cGVzKSB7XG4gICAgICAgIGlmIChleHRlbnNpb24udHlwZS50ZXN0KHR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIGl0ZW0udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBpdGVtLmJhc2UgPSBqb2lbdHlwZV0oKTtcbiAgICAgICAgICAgIGV4dGVuZGVkLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0ZW5kZWQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLnJvb3QoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxubGV0IFNjaGVtYXM7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5kZXNjcmliZSA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcblxuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmaW5pdGlvbjtcblxuICAgIC8vIFR5cGVcblxuICAgIGNvbnN0IGRlc2MgPSB7XG4gICAgICAgIHR5cGU6IHNjaGVtYS50eXBlLFxuICAgICAgICBmbGFnczoge30sXG4gICAgICAgIHJ1bGVzOiBbXVxuICAgIH07XG5cbiAgICAvLyBGbGFnc1xuXG4gICAgZm9yIChjb25zdCBmbGFnIGluIHNjaGVtYS5fZmxhZ3MpIHtcbiAgICAgICAgaWYgKGZsYWdbMF0gIT09ICdfJykge1xuICAgICAgICAgICAgZGVzYy5mbGFnc1tmbGFnXSA9IGludGVybmFscy5kZXNjcmliZShzY2hlbWEuX2ZsYWdzW2ZsYWddKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghT2JqZWN0LmtleXMoZGVzYy5mbGFncykubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBkZXNjLmZsYWdzO1xuICAgIH1cblxuICAgIC8vIFByZWZlcmVuY2VzXG5cbiAgICBpZiAoc2NoZW1hLl9wcmVmZXJlbmNlcykge1xuICAgICAgICBkZXNjLnByZWZlcmVuY2VzID0gQ2xvbmUoc2NoZW1hLl9wcmVmZXJlbmNlcywgeyBzaGFsbG93OiBbJ21lc3NhZ2VzJ10gfSk7XG4gICAgICAgIGRlbGV0ZSBkZXNjLnByZWZlcmVuY2VzW0NvbW1vbi5zeW1ib2xzLnByZWZzXTtcbiAgICAgICAgaWYgKGRlc2MucHJlZmVyZW5jZXMubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGRlc2MucHJlZmVyZW5jZXMubWVzc2FnZXMgPSBNZXNzYWdlcy5kZWNvbXBpbGUoZGVzYy5wcmVmZXJlbmNlcy5tZXNzYWdlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvdyAvIEludmFsaWRcblxuICAgIGlmIChzY2hlbWEuX3ZhbGlkcykge1xuICAgICAgICBkZXNjLmFsbG93ID0gc2NoZW1hLl92YWxpZHMuZGVzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLl9pbnZhbGlkcykge1xuICAgICAgICBkZXNjLmludmFsaWQgPSBzY2hlbWEuX2ludmFsaWRzLmRlc2NyaWJlKCk7XG4gICAgfVxuXG4gICAgLy8gUnVsZXNcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBzY2hlbWEuX3J1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVEZWYgPSBkZWYucnVsZXNbcnVsZS5uYW1lXTtcbiAgICAgICAgaWYgKHJ1bGVEZWYubWFuaWZlc3QgPT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpdGVtID0geyBuYW1lOiBydWxlLm5hbWUgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbSBpbiBkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICBpZiAocnVsZVtjdXN0b21dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtW2N1c3RvbV0gPSBpbnRlcm5hbHMuZGVzY3JpYmUocnVsZVtjdXN0b21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgIGl0ZW0uYXJncyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gcnVsZS5hcmdzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ29wdGlvbnMnICYmXG4gICAgICAgICAgICAgICAgICAgICFPYmplY3Qua2V5cyhhcmcpLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0uYXJnc1trZXldID0gaW50ZXJuYWxzLmRlc2NyaWJlKGFyZywgeyBhc3NpZ246IGtleSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhpdGVtLmFyZ3MpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtLmFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjLnJ1bGVzLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgaWYgKCFkZXNjLnJ1bGVzLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgZGVzYy5ydWxlcztcbiAgICB9XG5cbiAgICAvLyBUZXJtcyAobXVzdCBiZSBsYXN0IHRvIHZlcmlmeSBubyBuYW1lIGNvbmZsaWN0cylcblxuICAgIGZvciAoY29uc3QgdGVybSBpbiBzY2hlbWEuJF90ZXJtcykge1xuICAgICAgICBpZiAodGVybVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydCghZGVzY1t0ZXJtXSwgJ0Nhbm5vdCBkZXNjcmliZSBzY2hlbWEgZHVlIHRvIGludGVybmFsIG5hbWUgY29uZmxpY3Qgd2l0aCcsIHRlcm0pO1xuXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gc2NoZW1hLiRfdGVybXNbdGVybV07XG4gICAgICAgIGlmICghaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGRlc2NbdGVybV0gPSBbLi4uaXRlbXMuZW50cmllcygpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQ29tbW9uLmlzVmFsdWVzKGl0ZW1zKSkge1xuICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IGl0ZW1zLmRlc2NyaWJlKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydChkZWYudGVybXNbdGVybV0sICdUZXJtJywgdGVybSwgJ21pc3NpbmcgY29uZmlndXJhdGlvbicpO1xuICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGRlZi50ZXJtc1t0ZXJtXS5tYW5pZmVzdDtcbiAgICAgICAgY29uc3QgbWFwcGVkID0gdHlwZW9mIG1hbmlmZXN0ID09PSAnb2JqZWN0JztcbiAgICAgICAgaWYgKCFpdGVtcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFtYXBwZWQpIHtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKGludGVybmFscy5kZXNjcmliZShpdGVtKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXBwZWRcblxuICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBtYW5pZmVzdC5tYXBwZWQ7XG4gICAgICAgICAgICBkZXNjW3Rlcm1dID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygbm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGRlc2NbdGVybV1baXRlbVt0b11dID0gaXRlbVtmcm9tXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5nbGVcblxuICAgICAgICBpZiAobWFuaWZlc3QgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICBBc3NlcnQobm9ybWFsaXplZC5sZW5ndGggPT09IDEsICdUZXJtJywgdGVybSwgJ2NvbnRhaW5zIG1vcmUgdGhhbiBvbmUgaXRlbScpO1xuICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IG5vcm1hbGl6ZWRbMF07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFycmF5XG5cbiAgICAgICAgZGVzY1t0ZXJtXSA9IG5vcm1hbGl6ZWQ7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxzLnZhbGlkYXRlKHNjaGVtYS4kX3Jvb3QsIGRlc2MpO1xuICAgIHJldHVybiBkZXNjO1xufTtcblxuXG5pbnRlcm5hbHMuZGVzY3JpYmUgPSBmdW5jdGlvbiAoaXRlbSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICByZXR1cm4gaXRlbS5tYXAoaW50ZXJuYWxzLmRlc2NyaWJlKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbSA9PT0gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3BlY2lhbDogJ2RlZXAnIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBpdGVtID09PSBudWxsKSB7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgcmV0dXJuIENsb25lKGl0ZW0pO1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKGl0ZW0pKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgcmV0dXJuIHsgYnVmZmVyOiBpdGVtLnRvU3RyaW5nKCdiaW5hcnknKSB9O1xuICAgIH1cblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVnZXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcmVnZXg6IGl0ZW0udG9TdHJpbmcoKSB9O1xuICAgIH1cblxuICAgIGlmIChpdGVtW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdKSB7XG4gICAgICAgIHJldHVybiB7IGZ1bmN0aW9uOiBpdGVtLmxpdGVyYWwgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0uZGVzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVmJykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGVzY3JpYmUoKS5yZWY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbS5kZXNjcmliZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXRlbVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkW2tleV0gPSBpbnRlcm5hbHMuZGVzY3JpYmUodmFsdWUsIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuXG5cbmV4cG9ydHMuYnVpbGQgPSBmdW5jdGlvbiAoam9pLCBkZXNjKSB7XG5cbiAgICBjb25zdCBidWlsZGVyID0gbmV3IGludGVybmFscy5CdWlsZGVyKGpvaSk7XG4gICAgcmV0dXJuIGJ1aWxkZXIucGFyc2UoZGVzYyk7XG59O1xuXG5cbmludGVybmFscy5CdWlsZGVyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioam9pKSB7XG5cbiAgICAgICAgdGhpcy5qb2kgPSBqb2k7XG4gICAgfVxuXG4gICAgcGFyc2UoZGVzYykge1xuXG4gICAgICAgIGludGVybmFscy52YWxpZGF0ZSh0aGlzLmpvaSwgZGVzYyk7XG5cbiAgICAgICAgLy8gVHlwZVxuXG4gICAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmpvaVtkZXNjLnR5cGVdKCkuX2JhcmUoKTtcbiAgICAgICAgY29uc3QgZGVmID0gc2NoZW1hLl9kZWZpbml0aW9uO1xuXG4gICAgICAgIC8vIEZsYWdzXG5cbiAgICAgICAgaWYgKGRlc2MuZmxhZ3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmxhZyBpbiBkZXNjLmZsYWdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGVyID0gZGVmLmZsYWdzW2ZsYWddICYmIGRlZi5mbGFnc1tmbGFnXS5zZXR0ZXIgfHwgZmxhZztcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHNjaGVtYVtzZXR0ZXJdID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBmbGFnJywgZmxhZywgJ2ZvciB0eXBlJywgZGVzYy50eXBlKTtcbiAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWFbc2V0dGVyXSh0aGlzLmJ1aWxkKGRlc2MuZmxhZ3NbZmxhZ10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZWZlcmVuY2VzXG5cbiAgICAgICAgaWYgKGRlc2MucHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5wcmVmZXJlbmNlcyh0aGlzLmJ1aWxkKGRlc2MucHJlZmVyZW5jZXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IC8gSW52YWxpZFxuXG4gICAgICAgIGlmIChkZXNjLmFsbG93KSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEuYWxsb3coLi4udGhpcy5idWlsZChkZXNjLmFsbG93KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy5pbnZhbGlkKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEuaW52YWxpZCguLi50aGlzLmJ1aWxkKGRlc2MuaW52YWxpZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVsZXNcblxuICAgICAgICBpZiAoZGVzYy5ydWxlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIGRlc2MucnVsZXMpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHNjaGVtYVtydWxlLm5hbWVdID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBydWxlJywgcnVsZS5uYW1lLCAnZm9yIHR5cGUnLCBkZXNjLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVpbHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWlsdFtrZXldID0gdGhpcy5idWlsZChydWxlLmFyZ3Nba2V5XSwgeyBhc3NpZ246IGtleSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhidWlsdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBkZWYucnVsZXNbcnVsZS5uYW1lXS5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KGtleXMubGVuZ3RoIDw9IGRlZmluaXRpb24ubGVuZ3RoLCAnSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvcicsIGRlc2MudHlwZSwgcnVsZS5uYW1lLCAnKGV4cGVjdGVkIHVwIHRvJywgZGVmaW5pdGlvbi5sZW5ndGgsICcsIGZvdW5kJywga2V5cy5sZW5ndGgsICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgbmFtZSB9IG9mIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYnVpbHRbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KGtleXMubGVuZ3RoID09PSAxLCAnSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvcicsIGRlc2MudHlwZSwgcnVsZS5uYW1lLCAnKGV4cGVjdGVkIHVwIHRvIDEsIGZvdW5kJywga2V5cy5sZW5ndGgsICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYnVpbHRba2V5c1swXV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHlcblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYVtydWxlLm5hbWVdKC4uLmFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gUnVsZXNldFxuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY3VzdG9tIGluIGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVbY3VzdG9tXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2N1c3RvbV0gPSB0aGlzLmJ1aWxkKHJ1bGVbY3VzdG9tXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5ydWxlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlcm1zXG5cbiAgICAgICAgY29uc3QgdGVybXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVzYykge1xuICAgICAgICAgICAgaWYgKFsnYWxsb3cnLCAnZmxhZ3MnLCAnaW52YWxpZCcsICd3aGVucycsICdwcmVmZXJlbmNlcycsICdydWxlcycsICd0eXBlJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQoZGVmLnRlcm1zW2tleV0sICdUZXJtJywga2V5LCAnbWlzc2luZyBjb25maWd1cmF0aW9uJyk7XG4gICAgICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGRlZi50ZXJtc1trZXldLm1hbmlmZXN0O1xuXG4gICAgICAgICAgICBpZiAobWFuaWZlc3QgPT09ICdzY2hlbWEnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IGRlc2Nba2V5XS5tYXAoKGl0ZW0pID0+IHRoaXMucGFyc2UoaXRlbSkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWFuaWZlc3QgPT09ICd2YWx1ZXMnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IGRlc2Nba2V5XS5tYXAoKGl0ZW0pID0+IHRoaXMuYnVpbGQoaXRlbSkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWFuaWZlc3QgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IHRoaXMuYnVpbGQoZGVzY1trZXldKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYW5pZmVzdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlc2Nba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlc2Nba2V5XVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdGVybXNba2V5XVtuYW1lXSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXJtc1trZXldID0gdGhpcy5idWlsZChkZXNjW2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2Mud2hlbnMpIHtcbiAgICAgICAgICAgIHRlcm1zLndoZW5zID0gZGVzYy53aGVucy5tYXAoKHdoZW4pID0+IHRoaXMuYnVpbGQod2hlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NoZW1hID0gZGVmLm1hbmlmZXN0LmJ1aWxkKHNjaGVtYSwgdGVybXMpO1xuICAgICAgICBzY2hlbWEuJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICBidWlsZChkZXNjLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBpZiAoZGVzYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZXNjKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2MubWFwKChpdGVtKSA9PiB0aGlzLmJ1aWxkKGl0ZW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgICAgIHJldHVybiBDbG9uZShkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZ2V4Jykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5yZWdleChkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZicpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWYuYnVpbGQoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlc2MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkZXNjKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChkZXNjLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIEFzc2VydChCdWZmZXIsICdCdWZmZXJzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlciAmJiBCdWZmZXIuZnJvbShkZXNjLmJ1ZmZlciwgJ2JpbmFyeScpOyAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdOiB0cnVlLCBsaXRlcmFsOiBkZXNjLmZ1bmN0aW9uIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmLmJ1aWxkKGRlc2MucmVmKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MucmVnZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnJlZ2V4KGRlc2MucmVnZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5zcGVjaWFsKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnZGVlcCddLmluY2x1ZGVzKGRlc2Muc3BlY2lhbCksICdVbmtub3duIHNwZWNpYWwgdmFsdWUnLCBkZXNjLnNwZWNpYWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MudmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xvbmUoZGVzYy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGUuYnVpbGQoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3JtYWxpemVkID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlc2MpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IHRoaXMuYnVpbGQoZGVzY1trZXldLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMucmVnZXggPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICBjb25zdCBlbmQgPSBzdHJpbmcubGFzdEluZGV4T2YoJy8nKTtcbiAgICBjb25zdCBleHAgPSBzdHJpbmcuc2xpY2UoMSwgZW5kKTtcbiAgICBjb25zdCBmbGFncyA9IHN0cmluZy5zbGljZShlbmQgKyAxKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChleHAsIGZsYWdzKTtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlID0gZnVuY3Rpb24gKGpvaSwgZGVzYykge1xuXG4gICAgU2NoZW1hcyA9IFNjaGVtYXMgfHwgcmVxdWlyZSgnLi9zY2hlbWFzJyk7XG5cbiAgICBqb2kuYXNzZXJ0KGRlc2MsIFNjaGVtYXMuZGVzY3JpcHRpb24pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuY29tcGlsZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgdGFyZ2V0KSB7XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgc3RyaW5nICgncGxhaW4gZXJyb3IgbWVzc2FnZScsICd0ZW1wbGF0ZSB7ZXJyb3J9IG1lc3NhZ2UnKVxuXG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgQXNzZXJ0KCF0YXJnZXQsICdDYW5ub3Qgc2V0IHNpbmdsZSBtZXNzYWdlIHN0cmluZycpO1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlKG1lc3NhZ2VzKTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgdGVtcGxhdGVcblxuICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2VzKSkge1xuICAgICAgICBBc3NlcnQoIXRhcmdldCwgJ0Nhbm5vdCBzZXQgc2luZ2xlIG1lc3NhZ2UgdGVtcGxhdGUnKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH1cblxuICAgIC8vIEJ5IGVycm9yIGNvZGUgeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfVxuXG4gICAgQXNzZXJ0KHR5cGVvZiBtZXNzYWdlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobWVzc2FnZXMpLCAnSW52YWxpZCBtZXNzYWdlIG9wdGlvbnMnKTtcblxuICAgIHRhcmdldCA9IHRhcmdldCA/IENsb25lKHRhcmdldCkgOiB7fTtcblxuICAgIGZvciAobGV0IGNvZGUgaW4gbWVzc2FnZXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW2NvZGVdO1xuXG4gICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZSkpIHtcblxuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbmV3IFRlbXBsYXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCeSBsYW5ndWFnZSB7IGVuZ2xpc2g6IHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH0gfVxuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobWVzc2FnZSksICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSk7XG5cbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb2RlO1xuICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdID0gdGFyZ2V0W2xhbmd1YWdlXSB8fCB7fTtcblxuICAgICAgICBmb3IgKGNvZGUgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gbWVzc2FnZVtjb2RlXTtcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobG9jYWxpemVkKSkge1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBsb2NhbGl6ZWQgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUsICdpbicsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBuZXcgVGVtcGxhdGUobG9jYWxpemVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbmV4cG9ydHMuZGVjb21waWxlID0gZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG5cbiAgICAvLyBCeSBlcnJvciBjb2RlIHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH1cblxuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZvciAobGV0IGNvZGUgaW4gbWVzc2FnZXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW2NvZGVdO1xuXG4gICAgICAgIGlmIChjb2RlID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHRhcmdldC5yb290ID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG1lc3NhZ2UuZGVzY3JpYmUoeyBjb21wYWN0OiB0cnVlIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCeSBsYW5ndWFnZSB7IGVuZ2xpc2g6IHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH0gfVxuXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gY29kZTtcbiAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXSA9IHt9O1xuXG4gICAgICAgIGZvciAoY29kZSBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSBtZXNzYWdlW2NvZGVdO1xuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXS5yb290ID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkLmRlc2NyaWJlKHsgY29tcGFjdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAoYmFzZSwgZXh0ZW5kZWQpIHtcblxuICAgIGlmICghYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb21waWxlKGV4dGVuZGVkKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4dGVuZGVkKSB7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSB2YWx1ZSBzdHJpbmdcblxuICAgIGlmICh0eXBlb2YgZXh0ZW5kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGUoZXh0ZW5kZWQpO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSB2YWx1ZSB0ZW1wbGF0ZVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUoZXh0ZW5kZWQpKSB7XG4gICAgICAgIHJldHVybiBleHRlbmRlZDtcbiAgICB9XG5cbiAgICAvLyBCeSBlcnJvciBjb2RlIHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH1cblxuICAgIGNvbnN0IHRhcmdldCA9IENsb25lKGJhc2UpO1xuXG4gICAgZm9yIChsZXQgY29kZSBpbiBleHRlbmRlZCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXh0ZW5kZWRbY29kZV07XG5cbiAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlKSkge1xuXG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBuZXcgVGVtcGxhdGUobWVzc2FnZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IGxhbmd1YWdlIHsgZW5nbGlzaDogeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfSB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShtZXNzYWdlKSwgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlKTtcblxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGNvZGU7XG4gICAgICAgIHRhcmdldFtsYW5ndWFnZV0gPSB0YXJnZXRbbGFuZ3VhZ2VdIHx8IHt9O1xuXG4gICAgICAgIGZvciAoY29kZSBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSBtZXNzYWdlW2NvZGVdO1xuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShsb2NhbGl6ZWQpKSB7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIGxvY2FsaXplZCA9PT0gJ3N0cmluZycsICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSwgJ2luJywgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IG5ldyBUZW1wbGF0ZShsb2NhbGl6ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5cbmV4cG9ydHMuSWRzID0gaW50ZXJuYWxzLklkcyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMuX2J5SWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2J5S2V5ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IGludGVybmFscy5JZHMoKTtcbiAgICAgICAgY2xvbmUuX2J5SWQgPSBuZXcgTWFwKHRoaXMuX2J5SWQpO1xuICAgICAgICBjbG9uZS5fYnlLZXkgPSBuZXcgTWFwKHRoaXMuX2J5S2V5KTtcbiAgICAgICAgY2xvbmUuX3NjaGVtYUNoYWluID0gdGhpcy5fc2NoZW1hQ2hhaW47XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgaWYgKHNvdXJjZS5fc2NoZW1hQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2lkLCB2YWx1ZV0gb2Ygc291cmNlLl9ieUlkLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUtleS5oYXMoaWQpLCAnU2NoZW1hIGlkIGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGtleTonLCBpZCk7XG4gICAgICAgICAgICB0aGlzLl9ieUlkLnNldChpZCwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc291cmNlLl9ieUtleS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlJZC5oYXMoa2V5KSwgJ1NjaGVtYSBrZXkgY29uZmxpY3RzIHdpdGggZXhpc3RpbmcgaWQ6Jywga2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2J5S2V5LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvcmsocGF0aCwgYWRqdXN0ZXIsIHJvb3QpIHtcblxuICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuX2NvbGxlY3QocGF0aCk7XG4gICAgICAgIGNoYWluLnB1c2goeyBzY2hlbWE6IHJvb3QgfSk7XG4gICAgICAgIGNvbnN0IHRhaWwgPSBjaGFpbi5zaGlmdCgpO1xuICAgICAgICBsZXQgYWRqdXN0ZWQgPSB7IGlkOiB0YWlsLmlkLCBzY2hlbWE6IGFkanVzdGVyKHRhaWwuc2NoZW1hKSB9O1xuXG4gICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoYWRqdXN0ZWQuc2NoZW1hKSwgJ2FkanVzdGVyIGZ1bmN0aW9uIGZhaWxlZCB0byByZXR1cm4gYSBqb2kgc2NoZW1hIHR5cGUnKTtcblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY2hhaW4pIHtcbiAgICAgICAgICAgIGFkanVzdGVkID0geyBpZDogbm9kZS5pZCwgc2NoZW1hOiBpbnRlcm5hbHMuZm9yayhub2RlLnNjaGVtYSwgYWRqdXN0ZWQuaWQsIGFkanVzdGVkLnNjaGVtYSkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhZGp1c3RlZC5zY2hlbWE7XG4gICAgfVxuXG4gICAgbGFiZWxzKHBhdGgsIGJlaGluZCA9IFtdKSB7XG5cbiAgICAgICAgY29uc3QgY3VycmVudCA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXQoY3VycmVudCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5iZWhpbmQsIC4uLnBhdGhdLmpvaW4oJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvcndhcmQgPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBiZWhpbmQgPSBbLi4uYmVoaW5kLCBub2RlLnNjaGVtYS5fZmxhZ3MubGFiZWwgfHwgY3VycmVudF07XG4gICAgICAgIGlmICghZm9yd2FyZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBiZWhpbmQuam9pbignLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hLl9pZHMubGFiZWxzKGZvcndhcmQsIGJlaGluZCk7XG4gICAgfVxuXG4gICAgcmVhY2gocGF0aCwgYmVoaW5kID0gW10pIHtcblxuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGF0aFswXTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldChjdXJyZW50KTtcbiAgICAgICAgQXNzZXJ0KG5vZGUsICdTY2hlbWEgZG9lcyBub3QgY29udGFpbiBwYXRoJywgWy4uLmJlaGluZCwgLi4ucGF0aF0uam9pbignLicpKTtcblxuICAgICAgICBjb25zdCBmb3J3YXJkID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgaWYgKCFmb3J3YXJkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hLl9pZHMucmVhY2goZm9yd2FyZCwgWy4uLmJlaGluZCwgY3VycmVudF0pO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyKHNjaGVtYSwgeyBrZXkgfSA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCFzY2hlbWEgfHxcbiAgICAgICAgICAgICFDb21tb24uaXNTY2hlbWEoc2NoZW1hKSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NoZW1hLiRfcHJvcGVydHkoJ3NjaGVtYUNoYWluJykgfHxcbiAgICAgICAgICAgIHNjaGVtYS5faWRzLl9zY2hlbWFDaGFpbikge1xuXG4gICAgICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZCA9IHNjaGVtYS5fZmxhZ3MuaWQ7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLl9ieUlkLmdldChpZCk7XG4gICAgICAgICAgICBBc3NlcnQoIWV4aXN0aW5nIHx8IGV4aXN0aW5nLnNjaGVtYSA9PT0gc2NoZW1hLCAnQ2Fubm90IGFkZCBkaWZmZXJlbnQgc2NoZW1hcyB3aXRoIHRoZSBzYW1lIGlkOicsIGlkKTtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlLZXkuaGFzKGlkKSwgJ1NjaGVtYSBpZCBjb25mbGljdHMgd2l0aCBleGlzdGluZyBrZXk6JywgaWQpO1xuXG4gICAgICAgICAgICB0aGlzLl9ieUlkLnNldChpZCwgeyBzY2hlbWEsIGlkIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUtleS5oYXMoa2V5KSwgJ1NjaGVtYSBhbHJlYWR5IGNvbnRhaW5zIGtleTonLCBrZXkpO1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUlkLmhhcyhrZXkpLCAnU2NoZW1hIGtleSBjb25mbGljdHMgd2l0aCBleGlzdGluZyBpZDonLCBrZXkpO1xuXG4gICAgICAgICAgICB0aGlzLl9ieUtleS5zZXQoa2V5LCB7IHNjaGVtYSwgaWQ6IGtleSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuXG4gICAgICAgIHRoaXMuX2J5SWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2J5S2V5ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9jb2xsZWN0KHBhdGgsIGJlaGluZCA9IFtdLCBub2RlcyA9IFtdKSB7XG5cbiAgICAgICAgY29uc3QgY3VycmVudCA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXQoY3VycmVudCk7XG4gICAgICAgIEFzc2VydChub2RlLCAnU2NoZW1hIGRvZXMgbm90IGNvbnRhaW4gcGF0aCcsIFsuLi5iZWhpbmQsIC4uLnBhdGhdLmpvaW4oJy4nKSk7XG5cbiAgICAgICAgbm9kZXMgPSBbbm9kZSwgLi4ubm9kZXNdO1xuXG4gICAgICAgIGNvbnN0IGZvcndhcmQgPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBpZiAoIWZvcndhcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWEuX2lkcy5fY29sbGVjdChmb3J3YXJkLCBbLi4uYmVoaW5kLCBjdXJyZW50XSwgbm9kZXMpO1xuICAgIH1cblxuICAgIF9nZXQoaWQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fYnlJZC5nZXQoaWQpIHx8IHRoaXMuX2J5S2V5LmdldChpZCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZm9yayA9IGZ1bmN0aW9uIChzY2hlbWEsIGlkLCByZXBsYWNlbWVudCkge1xuXG4gICAgY29uc3QgZWFjaCA9IChpdGVtLCB7IGtleSB9KSA9PiB7XG5cbiAgICAgICAgaWYgKGlkID09PSAoaXRlbS5fZmxhZ3MuaWQgfHwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9iaiA9IGV4cG9ydHMuc2NoZW1hKHNjaGVtYSwgeyBlYWNoLCByZWY6IGZhbHNlIH0pO1xuICAgIHJldHVybiBvYmogPyBvYmouJF9tdXRhdGVSZWJ1aWxkKCkgOiBzY2hlbWE7XG59O1xuXG5cbmV4cG9ydHMuc2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0aW9ucykge1xuXG4gICAgbGV0IG9iajtcblxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzY2hlbWEuX2ZsYWdzKSB7XG4gICAgICAgIGlmIChuYW1lWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oc2NoZW1hLl9mbGFnc1tuYW1lXSwgeyBzb3VyY2U6ICdmbGFncycsIG5hbWUgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqID0gb2JqIHx8IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgICAgICAgb2JqLl9mbGFnc1tuYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLl9ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBydWxlID0gc2NoZW1hLl9ydWxlc1tpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4ocnVsZS5hcmdzLCB7IHNvdXJjZTogJ3J1bGVzJywgbmFtZTogcnVsZS5uYW1lIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiB8fCBzY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgcnVsZSk7XG4gICAgICAgICAgICBjbG9uZS5hcmdzID0gcmVzdWx0O1xuICAgICAgICAgICAgb2JqLl9ydWxlc1tpXSA9IGNsb25lO1xuXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1VuaXF1ZSA9IG9iai5fc2luZ2xlUnVsZXMuZ2V0KHJ1bGUubmFtZSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdVbmlxdWUgPT09IHJ1bGUpIHtcbiAgICAgICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLnNldChydWxlLm5hbWUsIGNsb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzY2hlbWEuJF90ZXJtcykge1xuICAgICAgICBpZiAobmFtZVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKHNjaGVtYS4kX3Rlcm1zW25hbWVdLCB7IHNvdXJjZTogJ3Rlcm1zJywgbmFtZSB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgc2NoZW1hLmNsb25lKCk7XG4gICAgICAgICAgICBvYmouJF90ZXJtc1tuYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmludGVybmFscy5zY2FuID0gZnVuY3Rpb24gKGl0ZW0sIHNvdXJjZSwgb3B0aW9ucywgX3BhdGgsIF9rZXkpIHtcblxuICAgIGNvbnN0IHBhdGggPSBfcGF0aCB8fCBbXTtcblxuICAgIGlmIChpdGVtID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2xvbmU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHNvdXJjZS5zb3VyY2UgPT09ICd0ZXJtcycgJiYgc291cmNlLm5hbWUgPT09ICdrZXlzJyAmJiBpdGVtW2ldLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKGl0ZW1baV0sIHNvdXJjZSwgb3B0aW9ucywgW2ksIC4uLnBhdGhdLCBrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSBjbG9uZSB8fCBpdGVtLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY2xvbmVbaV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2NoZW1hICE9PSBmYWxzZSAmJiBDb21tb24uaXNTY2hlbWEoaXRlbSkgfHxcbiAgICAgICAgb3B0aW9ucy5yZWYgIT09IGZhbHNlICYmIFJlZi5pc1JlZihpdGVtKSkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbnMuZWFjaChpdGVtLCB7IC4uLnNvdXJjZSwgcGF0aCwga2V5OiBfa2V5IH0pO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IGluIGl0ZW0pIHtcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKGl0ZW1ba2V5XSwgc291cmNlLCBvcHRpb25zLCBba2V5LCAuLi5wYXRoXSwgX2tleSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xvbmUgPSBjbG9uZSB8fCBPYmplY3QuYXNzaWduKHt9LCBpdGVtKTtcbiAgICAgICAgICAgIGNsb25lW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxubGV0IFRlbXBsYXRlO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBzeW1ib2w6IFN5bWJvbCgncmVmJyksICAgICAgLy8gVXNlZCB0byBpbnRlcm5hbGx5IGlkZW50aWZ5IHJlZmVyZW5jZXMgKHNoYXJlZCB3aXRoIG90aGVyIGpvaSB2ZXJzaW9ucylcbiAgICBkZWZhdWx0czoge1xuICAgICAgICBhZGp1c3Q6IG51bGwsXG4gICAgICAgIGluOiBmYWxzZSxcbiAgICAgICAgaXRlcmFibGVzOiBudWxsLFxuICAgICAgICBtYXA6IG51bGwsXG4gICAgICAgIHNlcGFyYXRvcjogJy4nLFxuICAgICAgICB0eXBlOiAndmFsdWUnXG4gICAgfVxufTtcblxuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQXNzZXJ0KHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnLCAnSW52YWxpZCByZWZlcmVuY2Uga2V5OicsIGtleSk7XG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhZGp1c3QnLCAnYW5jZXN0b3InLCAnaW4nLCAnaXRlcmFibGVzJywgJ21hcCcsICdwcmVmaXgnLCAncmVuZGVyJywgJ3NlcGFyYXRvciddKTtcbiAgICBBc3NlcnQoIW9wdGlvbnMucHJlZml4IHx8IHR5cGVvZiBvcHRpb25zLnByZWZpeCA9PT0gJ29iamVjdCcsICdvcHRpb25zLnByZWZpeCBtdXN0IGJlIG9mIHR5cGUgb2JqZWN0Jyk7XG5cbiAgICBjb25zdCByZWYgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSByZWYucHJlZml4O1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gcmVmLnNlcGFyYXRvcjtcbiAgICBjb25zdCBjb250ZXh0ID0gaW50ZXJuYWxzLmNvbnRleHQoa2V5LCBzZXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICByZWYudHlwZSA9IGNvbnRleHQudHlwZTtcbiAgICBrZXkgPSBjb250ZXh0LmtleTtcblxuICAgIGlmIChyZWYudHlwZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICBpZiAoY29udGV4dC5yb290KSB7XG4gICAgICAgICAgICBBc3NlcnQoIXNlcGFyYXRvciB8fCBrZXlbMF0gIT09IHNlcGFyYXRvciwgJ0Nhbm5vdCBzcGVjaWZ5IHJlbGF0aXZlIHBhdGggd2l0aCByb290IHByZWZpeCcpO1xuICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gJ3Jvb3QnO1xuICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcGFyYXRvciAmJlxuICAgICAgICAgICAgc2VwYXJhdG9yID09PSBrZXkpIHtcblxuICAgICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgICAgIHJlZi5hbmNlc3RvciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVmLmFuY2VzdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXNlcGFyYXRvciB8fCAha2V5IHx8IGtleVswXSAhPT0gc2VwYXJhdG9yLCAnQ2Fubm90IGNvbWJpbmUgcHJlZml4IHdpdGggYW5jZXN0b3Igb3B0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbYW5jZXN0b3IsIHNsaWNlXSA9IGludGVybmFscy5hbmNlc3RvcihrZXksIHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5zbGljZShzbGljZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gYW5jZXN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWYucGF0aCA9IHNlcGFyYXRvciA/IChrZXkgPT09IG51bGwgPyBbXSA6IGtleS5zcGxpdChzZXBhcmF0b3IpKSA6IFtrZXldO1xuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKHJlZik7XG59O1xuXG5cbmV4cG9ydHMuaW4gPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zID0ge30pIHtcblxuICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZShrZXksIHsgLi4ub3B0aW9ucywgaW46IHRydWUgfSk7XG59O1xuXG5cbmV4cG9ydHMuaXNSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG5cbiAgICByZXR1cm4gcmVmID8gISFyZWZbQ29tbW9uLnN5bWJvbHMucmVmXSA6IGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuUmVmID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHJlZmVyZW5jZSBjb25zdHJ1Y3Rpb24nKTtcbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgW1xuICAgICAgICAgICAgJ2FkanVzdCcsICdhbmNlc3RvcicsICdpbicsICdpdGVyYWJsZXMnLCAnbWFwJywgJ3BhdGgnLCAncmVuZGVyJywgJ3NlcGFyYXRvcicsICd0eXBlJywgIC8vIENvcGllZFxuICAgICAgICAgICAgJ2RlcHRoJywgJ2tleScsICdyb290JywgJ2Rpc3BsYXknICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRkZW5cbiAgICAgICAgXSk7XG5cbiAgICAgICAgQXNzZXJ0KFtmYWxzZSwgdW5kZWZpbmVkXS5pbmNsdWRlcyhvcHRpb25zLnNlcGFyYXRvcikgfHwgdHlwZW9mIG9wdGlvbnMuc2VwYXJhdG9yID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLnNlcGFyYXRvci5sZW5ndGggPT09IDEsICdJbnZhbGlkIHNlcGFyYXRvcicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMuYWRqdXN0IHx8IHR5cGVvZiBvcHRpb25zLmFkanVzdCA9PT0gJ2Z1bmN0aW9uJywgJ29wdGlvbnMuYWRqdXN0IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMubWFwIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy5tYXApLCAnb3B0aW9ucy5tYXAgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMubWFwIHx8ICFvcHRpb25zLmFkanVzdCwgJ0Nhbm5vdCBzZXQgYm90aCBtYXAgYW5kIGFkanVzdCBvcHRpb25zJyk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIEFzc2VydCh0aGlzLnR5cGUgPT09ICd2YWx1ZScgfHwgdGhpcy5hbmNlc3RvciA9PT0gdW5kZWZpbmVkLCAnTm9uLXZhbHVlIHJlZmVyZW5jZXMgY2Fubm90IHJlZmVyZW5jZSBhbmNlc3RvcnMnKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hcCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCh0aGlzLm1hcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5wYXRoLmxlbmd0aDtcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLnBhdGgubGVuZ3RoID8gdGhpcy5wYXRoLmpvaW4odGhpcy5zZXBhcmF0b3IpIDogbnVsbDtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5wYXRoWzBdO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5pbiB8fCBvcHRpb25zLmluLCAnSW52YWxpZCBpbigpIHJlZmVyZW5jZSB1c2FnZScpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShwcmVmcy5jb250ZXh0LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShsb2NhbCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmFuY2VzdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUoc3RhdGUuYW5jZXN0b3JzW3N0YXRlLmFuY2VzdG9ycy5sZW5ndGggLSAxXSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KHRoaXMuYW5jZXN0b3IgPD0gc3RhdGUuYW5jZXN0b3JzLmxlbmd0aCwgJ0ludmFsaWQgcmVmZXJlbmNlIGV4Y2VlZHMgdGhlIHNjaGVtYSByb290OicsIHRoaXMuZGlzcGxheSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHN0YXRlLmFuY2VzdG9yc1t0aGlzLmFuY2VzdG9yIC0gMV0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfcmVzb2x2ZSh0YXJnZXQsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHJlc29sdmVkO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnNoYWRvdyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5zaGFkb3cgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIHJlc29sdmVkID0gc3RhdGUubWFpbnN0YXkuc2hhZG93LmdldCh0aGlzLmFic29sdXRlKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSBSZWFjaCh0YXJnZXQsIHRoaXMucGF0aCwgeyBpdGVyYWJsZXM6IHRoaXMuaXRlcmFibGVzLCBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hZGp1c3QpIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gdGhpcy5hZGp1c3QocmVzb2x2ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwZWQgPSB0aGlzLm1hcC5nZXQocmVzb2x2ZWQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBtYXBwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUubWFpbnN0YXkpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5yZXNvbHZlKHN0YXRlLCB0aGlzLCByZXNvbHZlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheTtcbiAgICB9XG5cbiAgICBhYnNvbHV0ZShzdGF0ZSkge1xuXG4gICAgICAgIHJldHVybiBbLi4uc3RhdGUucGF0aC5zbGljZSgwLCAtdGhpcy5hbmNlc3RvciksIC4uLnRoaXMucGF0aF07XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKHRoaXMpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IHJlZiA9IHsgcGF0aDogdGhpcy5wYXRoIH07XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgcmVmLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICAgICAgcmVmLnNlcGFyYXRvciA9IHRoaXMuc2VwYXJhdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgICAgdGhpcy5hbmNlc3RvciAhPT0gMSkge1xuXG4gICAgICAgICAgICByZWYuYW5jZXN0b3IgPSB0aGlzLmFuY2VzdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICByZWYubWFwID0gWy4uLnRoaXMubWFwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnYWRqdXN0JywgJ2l0ZXJhYmxlcycsICdyZW5kZXInXSkge1xuICAgICAgICAgICAgaWYgKHRoaXNba2V5XSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICByZWZba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVmLmluID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHJlZiB9O1xuICAgIH1cblxuICAgIHVwZGF0ZURpc3BsYXkoKSB7XG5cbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXkgIT09IG51bGwgPyB0aGlzLmtleSA6ICcnO1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7dGhpcy50eXBlfToke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlcGFyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmFuY2VzdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7dGhpcy5zZXBhcmF0b3J9JHtrZXl9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuY2VzdG9yID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6cm9vdDoke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtrZXkgfHwgJy4uJ31gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGVhZCA9IG5ldyBBcnJheSh0aGlzLmFuY2VzdG9yICsgMSkuZmlsbCh0aGlzLnNlcGFyYXRvcikuam9pbignJyk7XG4gICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtsZWFkfSR7a2V5IHx8ICcnfWA7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuUmVmLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy5yZWZdID0gdHJ1ZTtcblxuXG5leHBvcnRzLmJ1aWxkID0gZnVuY3Rpb24gKGRlc2MpIHtcblxuICAgIGRlc2MgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbHMuZGVmYXVsdHMsIGRlc2MpO1xuICAgIGlmIChkZXNjLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgZGVzYy5hbmNlc3RvciA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgZGVzYy5hbmNlc3RvciA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKGRlc2MpO1xufTtcblxuXG5pbnRlcm5hbHMuY29udGV4dCA9IGZ1bmN0aW9uIChrZXksIHNlcGFyYXRvciwgcHJlZml4ID0ge30pIHtcblxuICAgIGtleSA9IGtleS50cmltKCk7XG5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IGdsb2JhbHAgPSBwcmVmaXguZ2xvYmFsID09PSB1bmRlZmluZWQgPyAnJCcgOiBwcmVmaXguZ2xvYmFsO1xuICAgICAgICBpZiAoZ2xvYmFscCAhPT0gc2VwYXJhdG9yICYmXG4gICAgICAgICAgICBrZXkuc3RhcnRzV2l0aChnbG9iYWxwKSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGtleS5zbGljZShnbG9iYWxwLmxlbmd0aCksIHR5cGU6ICdnbG9iYWwnIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2NhbCA9IHByZWZpeC5sb2NhbCA9PT0gdW5kZWZpbmVkID8gJyMnIDogcHJlZml4LmxvY2FsO1xuICAgICAgICBpZiAobG9jYWwgIT09IHNlcGFyYXRvciAmJlxuICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgobG9jYWwpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKGxvY2FsLmxlbmd0aCksIHR5cGU6ICdsb2NhbCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvb3QgPSBwcmVmaXgucm9vdCA9PT0gdW5kZWZpbmVkID8gJy8nIDogcHJlZml4LnJvb3Q7XG4gICAgICAgIGlmIChyb290ICE9PSBzZXBhcmF0b3IgJiZcbiAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKHJvb3QpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKHJvb3QubGVuZ3RoKSwgdHlwZTogJ3ZhbHVlJywgcm9vdDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsga2V5LCB0eXBlOiAndmFsdWUnIH07XG59O1xuXG5cbmludGVybmFscy5hbmNlc3RvciA9IGZ1bmN0aW9uIChrZXksIHNlcGFyYXRvcikge1xuXG4gICAgaWYgKCFzZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFsxLCAwXTsgICAgICAgICAgICAgIC8vICdhX2InIC0+IDEgKHBhcmVudClcbiAgICB9XG5cbiAgICBpZiAoa2V5WzBdICE9PSBzZXBhcmF0b3IpIHsgICAgIC8vICdhLmInIC0+IDEgKHBhcmVudClcbiAgICAgICAgcmV0dXJuIFsxLCAwXTtcbiAgICB9XG5cbiAgICBpZiAoa2V5WzFdICE9PSBzZXBhcmF0b3IpIHsgICAgIC8vICcuYS5iJyAtPiAwIChzZWxmKVxuICAgICAgICByZXR1cm4gWzAsIDFdO1xuICAgIH1cblxuICAgIGxldCBpID0gMjtcbiAgICB3aGlsZSAoa2V5W2ldID09PSBzZXBhcmF0b3IpIHtcbiAgICAgICAgKytpO1xuICAgIH1cblxuICAgIHJldHVybiBbaSAtIDEsIGldOyAgICAgICAgICAgICAgLy8gJy4uLmEuYi4nIC0+IDIgKGdyYW5kcGFyZW50KVxufTtcblxuXG5leHBvcnRzLnRvU2libGluZyA9IDA7XG5cbmV4cG9ydHMudG9QYXJlbnQgPSAxO1xuXG5cbmV4cG9ydHMuTWFuYWdlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMucmVmcyA9IFtdOyAgICAgICAgICAgICAgICAgICAgIC8vIDA6IFtzZWxmIHJlZnNdLCAxOiBbcGFyZW50IHJlZnNdLCAyOiBbZ3JhbmRwYXJlbnQgcmVmc10sIC4uLlxuICAgIH1cblxuICAgIHJlZ2lzdGVyKHNvdXJjZSwgdGFyZ2V0KSB7XG5cbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZXhwb3J0cy50b1BhcmVudCA6IHRhcmdldDtcblxuICAgICAgICAvLyBBcnJheVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIocmVmLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTY2hlbWFcblxuICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzb3VyY2UuX3JlZnMucmVmcykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmFuY2VzdG9yIC0gdGFyZ2V0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzLnB1c2goeyBhbmNlc3RvcjogaXRlbS5hbmNlc3RvciAtIHRhcmdldCwgcm9vdDogaXRlbS5yb290IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlXG5cbiAgICAgICAgaWYgKGV4cG9ydHMuaXNSZWYoc291cmNlKSAmJlxuICAgICAgICAgICAgc291cmNlLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgICAgIHNvdXJjZS5hbmNlc3RvciAtIHRhcmdldCA+PSAwKSB7XG5cbiAgICAgICAgICAgIHRoaXMucmVmcy5wdXNoKHsgYW5jZXN0b3I6IHNvdXJjZS5hbmNlc3RvciAtIHRhcmdldCwgcm9vdDogc291cmNlLnJvb3QgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wbGF0ZVxuXG4gICAgICAgIFRlbXBsYXRlID0gVGVtcGxhdGUgfHwgcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG4gICAgICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoc291cmNlLnJlZnMoKSwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3QgY29weSA9IG5ldyBleHBvcnRzLk1hbmFnZXIoKTtcbiAgICAgICAgY29weS5yZWZzID0gQ2xvbmUodGhpcy5yZWZzKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG5cbiAgICAgICAgdGhpcy5yZWZzID0gW107XG4gICAgfVxuXG4gICAgcm9vdHMoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy5maWx0ZXIoKHJlZikgPT4gIXJlZi5hbmNlc3RvcikubWFwKChyZWYpID0+IHJlZi5yb290KTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBKb2kgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuLy8gUHJlZmVyZW5jZXNcblxuaW50ZXJuYWxzLndyYXAgPSBKb2kuc3RyaW5nKClcbiAgICAubWluKDEpXG4gICAgLm1heCgyKVxuICAgIC5hbGxvdyhmYWxzZSk7XG5cblxuZXhwb3J0cy5wcmVmZXJlbmNlcyA9IEpvaS5vYmplY3Qoe1xuICAgIGFsbG93VW5rbm93bjogSm9pLmJvb2xlYW4oKSxcbiAgICBhYm9ydEVhcmx5OiBKb2kuYm9vbGVhbigpLFxuICAgIGFydGlmYWN0czogSm9pLmJvb2xlYW4oKSxcbiAgICBjYWNoZTogSm9pLmJvb2xlYW4oKSxcbiAgICBjb250ZXh0OiBKb2kub2JqZWN0KCksXG4gICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICBkYXRlRm9ybWF0OiBKb2kudmFsaWQoJ2RhdGUnLCAnaXNvJywgJ3N0cmluZycsICd0aW1lJywgJ3V0YycpLFxuICAgIGRlYnVnOiBKb2kuYm9vbGVhbigpLFxuICAgIGVycm9yczoge1xuICAgICAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBsYWJlbDogSm9pLnZhbGlkKCdwYXRoJywgJ2tleScsIGZhbHNlKSxcbiAgICAgICAgbGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIEpvaS5vYmplY3QoKS5yZWYoKVxuICAgICAgICBdLFxuICAgICAgICByZW5kZXI6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHN0YWNrOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICB3cmFwOiB7XG4gICAgICAgICAgICBsYWJlbDogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICBhcnJheTogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICBzdHJpbmc6IGludGVybmFscy53cmFwXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVybmFsczogSm9pLmJvb2xlYW4oKSxcbiAgICBtZXNzYWdlczogSm9pLm9iamVjdCgpLFxuICAgIG5vRGVmYXVsdHM6IEpvaS5ib29sZWFuKCksXG4gICAgbm9uRW51bWVyYWJsZXM6IEpvaS5ib29sZWFuKCksXG4gICAgcHJlc2VuY2U6IEpvaS52YWxpZCgncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJyksXG4gICAgc2tpcEZ1bmN0aW9uczogSm9pLmJvb2xlYW4oKSxcbiAgICBzdHJpcFVua25vd246IEpvaS5vYmplY3Qoe1xuICAgICAgICBhcnJheXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG9iamVjdHM6IEpvaS5ib29sZWFuKClcbiAgICB9KVxuICAgICAgICAub3IoJ2FycmF5cycsICdvYmplY3RzJylcbiAgICAgICAgLmFsbG93KHRydWUsIGZhbHNlKSxcbiAgICB3YXJuaW5nczogSm9pLmJvb2xlYW4oKVxufSlcbiAgICAuc3RyaWN0KCk7XG5cblxuLy8gRXh0ZW5zaW9uc1xuXG5pbnRlcm5hbHMubmFtZVJ4ID0gL15bYS16QS1aMC05XVxcdyokLztcblxuXG5pbnRlcm5hbHMucnVsZSA9IEpvaS5vYmplY3Qoe1xuICAgIGFsaWFzOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4KSkuc2luZ2xlKCksXG4gICAgYXJnczogSm9pLmFycmF5KCkuaXRlbXMoXG4gICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgSm9pLm9iamVjdCh7XG4gICAgICAgICAgICBuYW1lOiBKb2kuc3RyaW5nKCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4KS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgcmVmOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgYXNzZXJ0OiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgICAgICAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBKb2kub2JqZWN0KCkuc2NoZW1hKClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLmNvbmRpdGlvbmFsKCdyZWYnLCB7IGlzOiB0cnVlLCB0aGVuOiBKb2kucmVxdWlyZWQoKSB9KSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZTogSm9pLmZ1bmN0aW9uKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBKb2kuc3RyaW5nKCkud2hlbignYXNzZXJ0JywgeyBpczogSm9pLmZ1bmN0aW9uKCksIHRoZW46IEpvaS5yZXF1aXJlZCgpIH0pXG4gICAgICAgIH0pXG4gICAgKSxcbiAgICBjb252ZXJ0OiBKb2kuYm9vbGVhbigpLFxuICAgIG1hbmlmZXN0OiBKb2kuYm9vbGVhbigpLFxuICAgIG1ldGhvZDogSm9pLmZ1bmN0aW9uKCkuYWxsb3coZmFsc2UpLFxuICAgIG11bHRpOiBKb2kuYm9vbGVhbigpLFxuICAgIHZhbGlkYXRlOiBKb2kuZnVuY3Rpb24oKVxufSk7XG5cblxuZXhwb3J0cy5leHRlbnNpb24gPSBKb2kub2JqZWN0KHtcbiAgICB0eXBlOiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBKb2kub2JqZWN0KCkucmVnZXgoKVxuICAgIF0pXG4gICAgICAgIC5yZXF1aXJlZCgpLFxuICAgIGFyZ3M6IEpvaS5mdW5jdGlvbigpLFxuICAgIGNhc3Q6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5vYmplY3Qoe1xuICAgICAgICBmcm9tOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgxKS5yZXF1aXJlZCgpLFxuICAgICAgICB0bzogSm9pLmZ1bmN0aW9uKCkubWluQXJpdHkoMSkubWF4QXJpdHkoMikucmVxdWlyZWQoKVxuICAgIH0pKSxcbiAgICBiYXNlOiBKb2kub2JqZWN0KCkuc2NoZW1hKClcbiAgICAgICAgLndoZW4oJ3R5cGUnLCB7IGlzOiBKb2kub2JqZWN0KCkucmVnZXgoKSwgdGhlbjogSm9pLmZvcmJpZGRlbigpIH0pLFxuICAgIGNvZXJjZTogW1xuICAgICAgICBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKSxcbiAgICAgICAgSm9pLm9iamVjdCh7IG1ldGhvZDogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMykucmVxdWlyZWQoKSwgZnJvbTogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5zaW5nbGUoKSB9KVxuICAgIF0sXG4gICAgZmxhZ3M6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5vYmplY3Qoe1xuICAgICAgICBzZXR0ZXI6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZGVmYXVsdDogSm9pLmFueSgpXG4gICAgfSkpLFxuICAgIG1hbmlmZXN0OiB7XG4gICAgICAgIGJ1aWxkOiBKb2kuZnVuY3Rpb24oKS5hcml0eSgyKVxuICAgIH0sXG4gICAgbWVzc2FnZXM6IFtKb2kub2JqZWN0KCksIEpvaS5zdHJpbmcoKV0sXG4gICAgbW9kaWZpZXJzOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kuZnVuY3Rpb24oKS5taW5Bcml0eSgxKS5tYXhBcml0eSgyKSksXG4gICAgb3ZlcnJpZGVzOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kuZnVuY3Rpb24oKSksXG4gICAgcHJlcGFyZTogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMyksXG4gICAgcmVidWlsZDogSm9pLmZ1bmN0aW9uKCkuYXJpdHkoMSksXG4gICAgcnVsZXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIGludGVybmFscy5ydWxlKSxcbiAgICB0ZXJtczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIGluaXQ6IEpvaS5hcnJheSgpLmFsbG93KG51bGwpLnJlcXVpcmVkKCksXG4gICAgICAgIG1hbmlmZXN0OiBKb2kub2JqZWN0KCkucGF0dGVybigvLisvLCBbXG4gICAgICAgICAgICBKb2kudmFsaWQoJ3NjaGVtYScsICdzaW5nbGUnKSxcbiAgICAgICAgICAgIEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIG1hcHBlZDogSm9pLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgICAgICAgICB0bzogSm9pLnN0cmluZygpLnJlcXVpcmVkKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAucmVxdWlyZWQoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXSlcbiAgICB9KSksXG4gICAgdmFsaWRhdGU6IEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDMpXG59KVxuICAgIC5zdHJpY3QoKTtcblxuXG5leHBvcnRzLmV4dGVuc2lvbnMgPSBKb2kuYXJyYXkoKS5pdGVtcyhKb2kub2JqZWN0KCksIEpvaS5mdW5jdGlvbigpLmFyaXR5KDEpKS5zdHJpY3QoKTtcblxuXG4vLyBNYW5pZmVzdFxuXG5pbnRlcm5hbHMuZGVzYyA9IHtcblxuICAgIGJ1ZmZlcjogSm9pLm9iamVjdCh7XG4gICAgICAgIGJ1ZmZlcjogSm9pLnN0cmluZygpXG4gICAgfSksXG5cbiAgICBmdW5jOiBKb2kub2JqZWN0KHtcbiAgICAgICAgZnVuY3Rpb246IEpvaS5mdW5jdGlvbigpLnJlcXVpcmVkKCksXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGxpdGVyYWw6IHRydWVcbiAgICAgICAgfVxuICAgIH0pLFxuXG4gICAgb3ZlcnJpZGU6IEpvaS5vYmplY3Qoe1xuICAgICAgICBvdmVycmlkZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVmOiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVmOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IEpvaS52YWxpZCgndmFsdWUnLCAnZ2xvYmFsJywgJ2xvY2FsJyksXG4gICAgICAgICAgICBwYXRoOiBKb2kuYXJyYXkoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgc2VwYXJhdG9yOiBKb2kuc3RyaW5nKCkubGVuZ3RoKDEpLmFsbG93KGZhbHNlKSxcbiAgICAgICAgICAgIGFuY2VzdG9yOiBKb2kubnVtYmVyKCkubWluKDApLmludGVnZXIoKS5hbGxvdygncm9vdCcpLFxuICAgICAgICAgICAgbWFwOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuYXJyYXkoKS5sZW5ndGgoMikpLm1pbigxKSxcbiAgICAgICAgICAgIGFkanVzdDogSm9pLmZ1bmN0aW9uKCksXG4gICAgICAgICAgICBpdGVyYWJsZXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBpbjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIHJlbmRlcjogSm9pLmJvb2xlYW4oKVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcXVpcmVkKClcbiAgICB9KSxcblxuICAgIHJlZ2V4OiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVnZXg6IEpvaS5zdHJpbmcoKS5taW4oMylcbiAgICB9KSxcblxuICAgIHNwZWNpYWw6IEpvaS5vYmplY3Qoe1xuICAgICAgICBzcGVjaWFsOiBKb2kudmFsaWQoJ2RlZXAnKS5yZXF1aXJlZCgpXG4gICAgfSksXG5cbiAgICB0ZW1wbGF0ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHRlbXBsYXRlOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICAgICAgb3B0aW9uczogSm9pLm9iamVjdCgpXG4gICAgfSksXG5cbiAgICB2YWx1ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHZhbHVlOiBKb2kuYWx0ZXJuYXRpdmVzKFtKb2kub2JqZWN0KCksIEpvaS5hcnJheSgpXSkucmVxdWlyZWQoKVxuICAgIH0pXG59O1xuXG5cbmludGVybmFscy5kZXNjLmVudGl0eSA9IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgIEpvaS5hcnJheSgpLml0ZW1zKEpvaS5saW5rKCcuLi4nKSksXG4gICAgSm9pLmJvb2xlYW4oKSxcbiAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICBKb2kubnVtYmVyKCksXG4gICAgSm9pLnN0cmluZygpLFxuICAgIGludGVybmFscy5kZXNjLmJ1ZmZlcixcbiAgICBpbnRlcm5hbHMuZGVzYy5mdW5jLFxuICAgIGludGVybmFscy5kZXNjLnJlZixcbiAgICBpbnRlcm5hbHMuZGVzYy5yZWdleCxcbiAgICBpbnRlcm5hbHMuZGVzYy5zcGVjaWFsLFxuICAgIGludGVybmFscy5kZXNjLnRlbXBsYXRlLFxuICAgIGludGVybmFscy5kZXNjLnZhbHVlLFxuICAgIEpvaS5saW5rKCcvJylcbl0pO1xuXG5cbmludGVybmFscy5kZXNjLnZhbHVlcyA9IEpvaS5hcnJheSgpXG4gICAgLml0ZW1zKFxuICAgICAgICBudWxsLFxuICAgICAgICBKb2kuYm9vbGVhbigpLFxuICAgICAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgSm9pLm51bWJlcigpLmFsbG93KEluZmluaXR5LCAtSW5maW5pdHkpLFxuICAgICAgICBKb2kuc3RyaW5nKCkuYWxsb3coJycpLFxuICAgICAgICBKb2kuc3ltYm9sKCksXG4gICAgICAgIGludGVybmFscy5kZXNjLmJ1ZmZlcixcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MuZnVuYyxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2Mub3ZlcnJpZGUsXG4gICAgICAgIGludGVybmFscy5kZXNjLnJlZixcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVnZXgsXG4gICAgICAgIGludGVybmFscy5kZXNjLnRlbXBsYXRlLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy52YWx1ZVxuICAgICk7XG5cblxuaW50ZXJuYWxzLmRlc2MubWVzc2FnZXMgPSBKb2kub2JqZWN0KClcbiAgICAucGF0dGVybigvLisvLCBbXG4gICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgICAgIEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKy8sIFtKb2kuc3RyaW5nKCksIGludGVybmFscy5kZXNjLnRlbXBsYXRlXSlcbiAgICBdKTtcblxuXG5leHBvcnRzLmRlc2NyaXB0aW9uID0gSm9pLm9iamVjdCh7XG4gICAgdHlwZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgZmxhZ3M6IEpvaS5vYmplY3Qoe1xuICAgICAgICBjYXN0OiBKb2kuc3RyaW5nKCksXG4gICAgICAgIGRlZmF1bHQ6IEpvaS5hbnkoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZW1wdHk6IEpvaS5saW5rKCcvJyksXG4gICAgICAgIGZhaWxvdmVyOiBpbnRlcm5hbHMuZGVzYy5lbnRpdHksXG4gICAgICAgIGlkOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIGxhYmVsOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIG9ubHk6IHRydWUsXG4gICAgICAgIHByZXNlbmNlOiBbJ29wdGlvbmFsJywgJ3JlcXVpcmVkJywgJ2ZvcmJpZGRlbiddLFxuICAgICAgICByZXN1bHQ6IFsncmF3JywgJ3N0cmlwJ10sXG4gICAgICAgIHN0cmlwOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICB1bml0OiBKb2kuc3RyaW5nKClcbiAgICB9KVxuICAgICAgICAudW5rbm93bigpLFxuICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIGFsbG93VW5rbm93bjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgYWJvcnRFYXJseTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgYXJ0aWZhY3RzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBjYWNoZTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgZGF0ZUZvcm1hdDogWydkYXRlJywgJ2lzbycsICdzdHJpbmcnLCAndGltZScsICd1dGMnXSxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgbGFiZWw6IFsncGF0aCcsICdrZXknXSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBbXG4gICAgICAgICAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGludGVybmFscy5kZXNjLnJlZlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHdyYXA6IHtcbiAgICAgICAgICAgICAgICBsYWJlbDogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICAgICAgYXJyYXk6IGludGVybmFscy53cmFwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVybmFsczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgbWVzc2FnZXM6IGludGVybmFscy5kZXNjLm1lc3NhZ2VzLFxuICAgICAgICBub0RlZmF1bHRzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBub25FbnVtZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgcHJlc2VuY2U6IFsncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJ10sXG4gICAgICAgIHNraXBGdW5jdGlvbnM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHN0cmlwVW5rbm93bjogSm9pLm9iamVjdCh7XG4gICAgICAgICAgICBhcnJheXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBvYmplY3RzOiBKb2kuYm9vbGVhbigpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAub3IoJ2FycmF5cycsICdvYmplY3RzJylcbiAgICAgICAgICAgIC5hbGxvdyh0cnVlLCBmYWxzZSksXG4gICAgICAgIHdhcm5pbmdzOiBKb2kuYm9vbGVhbigpXG4gICAgfSxcbiAgICBhbGxvdzogaW50ZXJuYWxzLmRlc2MudmFsdWVzLFxuICAgIGludmFsaWQ6IGludGVybmFscy5kZXNjLnZhbHVlcyxcbiAgICBydWxlczogSm9pLmFycmF5KCkubWluKDEpLml0ZW1zKHtcbiAgICAgICAgbmFtZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgICAgIGFyZ3M6IEpvaS5vYmplY3QoKS5taW4oMSksXG4gICAgICAgIGtlZXA6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG1lc3NhZ2U6IFtcbiAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIGludGVybmFscy5kZXNjLm1lc3NhZ2VzXG4gICAgICAgIF0sXG4gICAgICAgIHdhcm46IEpvaS5ib29sZWFuKClcbiAgICB9KSxcblxuICAgIC8vIFRlcm1zXG5cbiAgICBrZXlzOiBKb2kub2JqZWN0KCkucGF0dGVybigvLiovLCBKb2kubGluaygnLycpKSxcbiAgICBsaW5rOiBpbnRlcm5hbHMuZGVzYy5yZWZcbn0pXG4gICAgLnBhdHRlcm4oL15bYS16XVxcdyokLywgSm9pLmFueSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9yZWFjaCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB2YWx1ZTogU3ltYm9sKCd2YWx1ZScpXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlN0YXRlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IocGF0aCwgYW5jZXN0b3JzLCBzdGF0ZSkge1xuXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuYW5jZXN0b3JzID0gYW5jZXN0b3JzOyAgICAgICAgICAgICAgICAgLy8gW3BhcmVudCwgLi4uLCByb290XVxuXG4gICAgICAgIHRoaXMubWFpbnN0YXkgPSBzdGF0ZS5tYWluc3RheTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gc3RhdGUuc2NoZW1hczsgICAgICAgICAgICAgICAvLyBbY3VycmVudCwgLi4uLCByb290XVxuICAgICAgICB0aGlzLmRlYnVnID0gbnVsbDtcbiAgICB9XG5cbiAgICBsb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMgPSBudWxsLCBzY2hlbWEgPSBudWxsKSB7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgaW50ZXJuYWxzLlN0YXRlKHBhdGgsIGFuY2VzdG9ycywgdGhpcyk7XG5cbiAgICAgICAgaWYgKHNjaGVtYSAmJlxuICAgICAgICAgICAgc3RhdGUuc2NoZW1hcykge1xuXG4gICAgICAgICAgICBzdGF0ZS5zY2hlbWFzID0gW2ludGVybmFscy5zY2hlbWFzKHNjaGVtYSksIC4uLnN0YXRlLnNjaGVtYXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIG5lc3Qoc2NoZW1hLCBkZWJ1Zykge1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gbmV3IGludGVybmFscy5TdGF0ZSh0aGlzLnBhdGgsIHRoaXMuYW5jZXN0b3JzLCB0aGlzKTtcbiAgICAgICAgc3RhdGUuc2NoZW1hcyA9IHN0YXRlLnNjaGVtYXMgJiYgW2ludGVybmFscy5zY2hlbWFzKHNjaGVtYSksIC4uLnN0YXRlLnNjaGVtYXNdO1xuICAgICAgICBzdGF0ZS5kZWJ1ZyA9IGRlYnVnO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgc2hhZG93KHZhbHVlLCByZWFzb24pIHtcblxuICAgICAgICB0aGlzLm1haW5zdGF5LnNoYWRvdyA9IHRoaXMubWFpbnN0YXkuc2hhZG93IHx8IG5ldyBpbnRlcm5hbHMuU2hhZG93KCk7XG4gICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93LnNldCh0aGlzLnBhdGgsIHZhbHVlLCByZWFzb24pO1xuICAgIH1cblxuICAgIHNuYXBzaG90KCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1haW5zdGF5LnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3QgPSBDbG9uZSh0aGlzLm1haW5zdGF5LnNoYWRvdy5ub2RlKHRoaXMucGF0aCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzdG9yZSgpIHtcblxuICAgICAgICBpZiAodGhpcy5tYWluc3RheS5zaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93Lm92ZXJyaWRlKHRoaXMucGF0aCwgdGhpcy5fc25hcHNob3QpO1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zY2hlbWFzID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgaWYgKENvbW1vbi5pc1NjaGVtYShzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiB7IHNjaGVtYSB9O1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWE7XG59O1xuXG5cbmludGVybmFscy5TaGFkb3cgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHNldChwYXRoLCB2YWx1ZSwgcmVhc29uKSB7XG5cbiAgICAgICAgaWYgKCFwYXRoLmxlbmd0aCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHN0b3JlIHJvb3QgdmFsdWVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWFzb24gPT09ICdzdHJpcCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICdudW1iZXInKSB7ICAgICAgICAvLyBDYW5ub3Qgc3RvcmUgc3RyaXBwZWQgYXJyYXkgdmFsdWVzIChkdWUgdG8gc2hpZnQpXG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuX3ZhbHVlcyB8fCBuZXcgTWFwKCk7XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl92YWx1ZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHBhdGhbaV07XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuZ2V0KHNlZ21lbnQpO1xuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBub2RlLnNldChzZWdtZW50LCBuZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlW2ludGVybmFscy52YWx1ZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQocGF0aCkge1xuXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGUocGF0aCk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVtpbnRlcm5hbHMudmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbm9kZShwYXRoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjaCh0aGlzLl92YWx1ZXMsIHBhdGgsIHsgaXRlcmFibGVzOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIG92ZXJyaWRlKHBhdGgsIG5vZGUpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyZW50cyA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgICAgICBjb25zdCBvd24gPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IFJlYWNoKHRoaXMuX3ZhbHVlcywgcGFyZW50cywgeyBpdGVyYWJsZXM6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudC5zZXQob3duLCBub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5kZWxldGUob3duKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgRXNjYXBlSHRtbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2VzY2FwZUh0bWwnKTtcbmNvbnN0IEZvcm11bGEgPSByZXF1aXJlKCdAc2lkZXdheS9mb3JtdWxhJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgc3ltYm9sOiBTeW1ib2woJ3RlbXBsYXRlJyksXG5cbiAgICBvcGVuczogbmV3IEFycmF5KDEwMDApLmpvaW4oJ1xcdTAwMDAnKSxcbiAgICBjbG9zZXM6IG5ldyBBcnJheSgxMDAwKS5qb2luKCdcXHUwMDAxJyksXG5cbiAgICBkYXRlRm9ybWF0OiB7XG4gICAgICAgIGRhdGU6IERhdGUucHJvdG90eXBlLnRvRGF0ZVN0cmluZyxcbiAgICAgICAgaXNvOiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyxcbiAgICAgICAgc3RyaW5nOiBEYXRlLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgdGltZTogRGF0ZS5wcm90b3R5cGUudG9UaW1lU3RyaW5nLFxuICAgICAgICB1dGM6IERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nXG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBpbnRlcm5hbHMuVGVtcGxhdGUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycsICdUZW1wbGF0ZSBzb3VyY2UgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICBBc3NlcnQoIXNvdXJjZS5pbmNsdWRlcygnXFx1MDAwMCcpICYmICFzb3VyY2UuaW5jbHVkZXMoJ1xcdTAwMDEnKSwgJ1RlbXBsYXRlIHNvdXJjZSBjYW5ub3QgY29udGFpbiByZXNlcnZlZCBjb250cm9sIGNoYXJhY3RlcnMnKTtcblxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCA9IHNvdXJjZTtcblxuICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gQ2xvbmUob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fcGFyc2UoKTtcbiAgICB9XG5cbiAgICBfcGFyc2UoKSB7XG5cbiAgICAgICAgLy8gJ3RleHQge3Jhd30ge3tyZWZ9fSBcXFxce3tpZ25vcmV9fSB7e2lnbm9yZVxcXFx9fSB7e2lnbm9yZSB7e2lnbm9yZX0nXG5cbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZS5pbmNsdWRlcygneycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmNvZGUgZXNjYXBlZCBcXFxce3t7e3tcblxuICAgICAgICBjb25zdCBlbmNvZGVkID0gaW50ZXJuYWxzLmVuY29kZSh0aGlzLnNvdXJjZSk7XG5cbiAgICAgICAgLy8gU3BsaXQgb24gZmlyc3QgeyBpbiBlYWNoIHNldFxuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gaW50ZXJuYWxzLnNwbGl0KGVuY29kZWQpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgcGFydHNcblxuICAgICAgICBsZXQgcmVmcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcbiAgICAgICAgY29uc3QgaGVhZCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gcGFydFswXSAhPT0gJ3snO1xuICAgICAgICAgICAgY29uc3QgZW5kZXIgPSByYXcgPyAnfScgOiAnfX0nO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcGFydC5pbmRleE9mKGVuZGVyKTtcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xIHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBub24tbWF0Y2hpbmcgY2xvc2luZ1xuICAgICAgICAgICAgICAgIHBhcnRbMV0gPT09ICd7JykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIG1vcmUgdGhhbiB0d28ge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goYHske2ludGVybmFscy5kZWNvZGUocGFydCl9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB2YXJpYWJsZSA9IHBhcnQuc2xpY2UocmF3ID8gMCA6IDEsIGVuZCk7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkID0gdmFyaWFibGVbMF0gPT09ICc6JztcbiAgICAgICAgICAgIGlmICh3cmFwcGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IHRoaXMuX3JlZihpbnRlcm5hbHMuZGVjb2RlKHZhcmlhYmxlKSwgeyByYXcsIHdyYXBwZWQgfSk7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChkeW5hbWljKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHluYW1pYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzdCA9IHBhcnQuc2xpY2UoZW5kICsgZW5kZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goaW50ZXJuYWxzLmRlY29kZShyZXN0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWQgPSBwcm9jZXNzZWQuam9pbignJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IHByb2Nlc3NlZDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGF0ZShkYXRlLCBwcmVmcykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZUZvcm1hdFtwcmVmcy5kYXRlRm9ybWF0XS5jYWxsKGRhdGUpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29tcGFjdCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXNjID0geyB0ZW1wbGF0ZTogdGhpcy5zb3VyY2UgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzKSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB0aGlzLl9zZXR0aW5ncztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cblxuICAgIHN0YXRpYyBidWlsZChkZXNjKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuVGVtcGxhdGUoZGVzYy50ZW1wbGF0ZSwgZGVzYy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICBpc0R5bmFtaWMoKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy5fdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzVGVtcGxhdGUodGVtcGxhdGUpIHtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUgPyAhIXRlbXBsYXRlW0NvbW1vbi5zeW1ib2xzLnRlbXBsYXRlXSA6IGZhbHNlO1xuICAgIH1cblxuICAgIHJlZnMoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2goLi4ucGFydC5yZWZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWZzO1xuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpIHtcblxuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUgJiZcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydCh0aGlzLl90ZW1wbGF0ZVswXSwgLyogY29udGV4dCAtPiBbKi8gdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIHt9IC8qXSAqLyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpO1xuICAgIH1cblxuICAgIF9wYXJ0KHBhcnQsIC4uLmFyZ3MpIHtcblxuICAgICAgICBpZiAocGFydC5yZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnJlZi5yZXNvbHZlKC4uLmFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnQuZm9ybXVsYS5ldmFsdWF0ZShhcmdzKTtcbiAgICB9XG5cbiAgICByZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0R5bmFtaWMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZWQgPSB0aGlzLl9wYXJ0KHBhcnQsIC8qIGNvbnRleHQgLT4gWyovIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zIC8qXSAqLyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gaW50ZXJuYWxzLnN0cmluZ2lmeShyZW5kZXJlZCwgdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJ0LnJhdyB8fCAob3B0aW9ucy5lcnJvcnMgJiYgb3B0aW9ucy5lcnJvcnMuZXNjYXBlSHRtbCkgPT09IGZhbHNlID8gc3RyaW5nIDogRXNjYXBlSHRtbChzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGludGVybmFscy53cmFwKHJlc3VsdCwgcGFydC53cmFwcGVkICYmIHByZWZzLmVycm9ycy53cmFwLmxhYmVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuICAgIH1cblxuICAgIF9yZWYoY29udGVudCwgeyByYXcsIHdyYXBwZWQgfSkge1xuXG4gICAgICAgIGNvbnN0IHJlZnMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gKHZhcmlhYmxlKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IFJlZi5jcmVhdGUodmFyaWFibGUsIHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgICAgIHJlZnMucHVzaChyZWYpO1xuICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiByZWYucmVzb2x2ZSguLi5jb250ZXh0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGZvcm11bGEgPSBuZXcgRm9ybXVsYS5QYXJzZXIoY29udGVudCwgeyByZWZlcmVuY2UsIGZ1bmN0aW9uczogaW50ZXJuYWxzLmZ1bmN0aW9ucywgY29uc3RhbnRzOiBpbnRlcm5hbHMuY29uc3RhbnRzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYEludmFsaWQgdGVtcGxhdGUgdmFyaWFibGUgXCIke2NvbnRlbnR9XCIgZmFpbHMgZHVlIHRvOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybXVsYS5zaW5nbGUpIHtcbiAgICAgICAgICAgIGlmIChmb3JtdWxhLnNpbmdsZS50eXBlID09PSAncmVmZXJlbmNlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHJlZnNbMF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVmLCByYXcsIHJlZnMsIHdyYXBwZWQ6IHdyYXBwZWQgfHwgcmVmLnR5cGUgPT09ICdsb2NhbCcgJiYgcmVmLmtleSA9PT0gJ2xhYmVsJyB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnN0cmluZ2lmeShmb3JtdWxhLnNpbmdsZS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBmb3JtdWxhLCByYXcsIHJlZnMgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuVGVtcGxhdGUucHJvdG90eXBlW0NvbW1vbi5zeW1ib2xzLnRlbXBsYXRlXSA9IHRydWU7XG5pbnRlcm5hbHMuVGVtcGxhdGUucHJvdG90eXBlLmlzSW1tdXRhYmxlID0gdHJ1ZTsgICAgICAgICAgICAgICAgLy8gUHJldmVudHMgSG9layBmcm9tIGRlZXAgY2xvbmluZyBzY2hlbWEgb2JqZWN0c1xuXG5cbmludGVybmFscy5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcKFxceyspL2csICgkMCwgJDEpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5vcGVucy5zbGljZSgwLCAkMS5sZW5ndGgpO1xuICAgICAgICB9KVxuICAgICAgICAucmVwbGFjZSgvXFxcXChcXH0rKS9nLCAoJDAsICQxKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuY2xvc2VzLnNsaWNlKDAsICQxLmxlbmd0aCk7XG4gICAgICAgIH0pO1xufTtcblxuXG5pbnRlcm5hbHMuZGVjb2RlID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgICAucmVwbGFjZSgvXFx1MDAwMC9nLCAneycpXG4gICAgICAgIC5yZXBsYWNlKC9cXHUwMDAxL2csICd9Jyk7XG59O1xuXG5cbmludGVybmFscy5zcGxpdCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBzdHJpbmdbaV07XG5cbiAgICAgICAgaWYgKGNoYXIgPT09ICd7Jykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChpICsgMSA8IHN0cmluZy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdbaSArIDFdID09PSAneycpIHtcblxuICAgICAgICAgICAgICAgIG5leHQgKz0gJ3snO1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudCArPSBjaGFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChjdXJyZW50KTtcbiAgICByZXR1cm4gcGFydHM7XG59O1xuXG5cbmludGVybmFscy53cmFwID0gZnVuY3Rpb24gKHZhbHVlLCBlbmRzKSB7XG5cbiAgICBpZiAoIWVuZHMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChlbmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYCR7ZW5kc30ke3ZhbHVlfSR7ZW5kc31gO1xuICAgIH1cblxuICAgIHJldHVybiBgJHtlbmRzWzBdfSR7dmFsdWV9JHtlbmRzWzFdfWA7XG59O1xuXG5cbmludGVybmFscy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodmFsdWUsIG9yaWdpbmFsLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zID0ge30pIHtcblxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgY29uc3Qgd3JhcCA9IHByZWZzICYmIHByZWZzLmVycm9ycyAmJiBwcmVmcy5lcnJvcnMud3JhcCB8fCB7fTtcblxuICAgIGxldCBza2lwV3JhcCA9IGZhbHNlO1xuICAgIGlmIChSZWYuaXNSZWYodmFsdWUpICYmXG4gICAgICAgIHZhbHVlLnJlbmRlcikge1xuXG4gICAgICAgIHNraXBXcmFwID0gdmFsdWUuaW47XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVzb2x2ZShvcmlnaW5hbCwgc3RhdGUsIHByZWZzLCBsb2NhbCwgeyBpbjogdmFsdWUuaW4sIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMud3JhcCh2YWx1ZSwgb3B0aW9ucy5hcnJheUl0ZW1zICYmIHdyYXAuc3RyaW5nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlID09PSAnc3ltYm9sJykge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5UZW1wbGF0ZS5kYXRlKHZhbHVlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgc3ltXSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goYCR7a2V5LnRvU3RyaW5nKCl9IC0+ICR7c3ltLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHBhaXJzO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGludGVybmFscy5zdHJpbmdpZnkoaXRlbSwgb3JpZ2luYWwsIHN0YXRlLCBwcmVmcywgbG9jYWwsIHsgYXJyYXlJdGVtczogdHJ1ZSwgLi4ub3B0aW9ucyB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy53cmFwKHZhbHVlcy5qb2luKCcsICcpLCAhc2tpcFdyYXAgJiYgd3JhcC5hcnJheSk7XG59O1xuXG5cbmludGVybmFscy5jb25zdGFudHMgPSB7XG5cbiAgICB0cnVlOiB0cnVlLFxuICAgIGZhbHNlOiBmYWxzZSxcbiAgICBudWxsOiBudWxsLFxuXG4gICAgc2Vjb25kOiAxMDAwLFxuICAgIG1pbnV0ZTogNjAgKiAxMDAwLFxuICAgIGhvdXI6IDYwICogNjAgKiAxMDAwLFxuICAgIGRheTogMjQgKiA2MCAqIDYwICogMTAwMFxufTtcblxuXG5pbnRlcm5hbHMuZnVuY3Rpb25zID0ge1xuXG4gICAgaWYoY29uZGl0aW9uLCB0aGVuLCBvdGhlcndpc2UpIHtcblxuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gdGhlbiA6IG90aGVyd2lzZTtcbiAgICB9LFxuXG4gICAgbGVuZ3RoKGl0ZW0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWl0ZW0gfHwgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlbSkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBtc2coY29kZSkge1xuXG4gICAgICAgIGNvbnN0IFt2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9uc10gPSB0aGlzO1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IG9wdGlvbnMubWVzc2FnZXM7XG4gICAgICAgIGlmICghbWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gRXJyb3JzLnRlbXBsYXRlKHZhbHVlLCBtZXNzYWdlc1swXSwgY29kZSwgc3RhdGUsIHByZWZzKSB8fCBFcnJvcnMudGVtcGxhdGUodmFsdWUsIG1lc3NhZ2VzWzFdLCBjb2RlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVuZGVyKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgbnVtYmVyKHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuY29uc3QgUGlucG9pbnQgPSByZXF1aXJlKCdAc2lkZXdheS9waW5wb2ludCcpO1xuXG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBjb2Rlczoge1xuICAgICAgICBlcnJvcjogMSxcbiAgICAgICAgcGFzczogMixcbiAgICAgICAgZnVsbDogM1xuICAgIH0sXG4gICAgbGFiZWxzOiB7XG4gICAgICAgIDA6ICduZXZlciB1c2VkJyxcbiAgICAgICAgMTogJ2Fsd2F5cyBlcnJvcicsXG4gICAgICAgIDI6ICdhbHdheXMgcGFzcydcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuc2V0dXAgPSBmdW5jdGlvbiAocm9vdCkge1xuXG4gICAgY29uc3QgdHJhY2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gcm9vdC5fdHJhY2VyIHx8IG5ldyBpbnRlcm5hbHMuVHJhY2VyKCk7XG4gICAgICAgIHJldHVybiByb290Ll90cmFjZXI7XG4gICAgfTtcblxuICAgIHJvb3QudHJhY2UgPSB0cmFjZTtcbiAgICByb290W1N5bWJvbC5mb3IoJ0BoYXBpL2xhYi9jb3ZlcmFnZS9pbml0aWFsaXplJyldID0gdHJhY2U7XG5cbiAgICByb290LnVudHJhY2UgPSAoKSA9PiB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gbnVsbDtcbiAgICB9O1xufTtcblxuXG5leHBvcnRzLmxvY2F0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgcmV0dXJuIHNjaGVtYS4kX3NldEZsYWcoJ190cmFjZXJMb2NhdGlvbicsIFBpbnBvaW50LmxvY2F0aW9uKDIpKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2UudHJhY2VyKCksIGNhbGxlclxufTtcblxuXG5pbnRlcm5hbHMuVHJhY2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0pvaSc7XG4gICAgICAgIHRoaXMuX3NjaGVtYXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgX3JlZ2lzdGVyKHNjaGVtYSkge1xuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fc2NoZW1hcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmcuc3RvcmU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9yZSA9IG5ldyBpbnRlcm5hbHMuU3RvcmUoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgeyBmaWxlbmFtZSwgbGluZSB9ID0gc2NoZW1hLl9mbGFncy5fdHJhY2VyTG9jYXRpb24gfHwgUGlucG9pbnQubG9jYXRpb24oNSk7ICAgLy8gaW50ZXJuYWxzLnRyYWNlcigpLCBpbnRlcm5hbHMuZW50cnkoKSwgZXhwb3J0cy5lbnRyeSgpLCB2YWxpZGF0ZSgpLCBjYWxsZXJcbiAgICAgICAgdGhpcy5fc2NoZW1hcy5zZXQoc2NoZW1hLCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9KTtcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHN0b3JlLl9jb21iaW5lKG1lcmdlZCwgc291cmNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXBvcnQoZmlsZSkge1xuXG4gICAgICAgIGNvbnN0IGNvdmVyYWdlID0gW107XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHJlZ2lzdGVyZWQgc2NoZW1hXG5cbiAgICAgICAgZm9yIChjb25zdCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChmaWxlICYmXG4gICAgICAgICAgICAgICAgZmlsZSAhPT0gZmlsZW5hbWUpIHtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIHN1YiBzY2hlbWFzIG9mIHRoZSByZWdpc3RlcmVkIHJvb3RcblxuICAgICAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc2tpcHBlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtzY2hlbWEsIGxvZ10gb2Ygc3RvcmUuX3NvdXJjZXMuZW50cmllcygpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBzdWIgc2NoZW1hIHBhcmVudCBza2lwcGVkXG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLnN1Yihsb2cucGF0aHMsIHNraXBwZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHN1YiBzY2hlbWEgcmVhY2hlZFxuXG4gICAgICAgICAgICAgICAgaWYgKCFsb2cuZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ25ldmVyIHJlYWNoZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHM6IFsuLi5sb2cucGF0aHNdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCguLi5sb2cucGF0aHMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB2YWx1ZXNcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ3ZhbGlkJywgJ2ludmFsaWQnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBzY2hlbWFbYF8ke3R5cGV9c2BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KHNldC5fdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcyA9IG5ldyBTZXQoc2V0Ll9yZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbHVlLCByZWYgfSBvZiBsb2dbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuc2l6ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5zaXplKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBbLi4udmFsdWVzLCAuLi5bLi4ucmVmc10ubWFwKChyZWYpID0+IHJlZi5kaXNwbGF5KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYCR7dHlwZX1zYFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBydWxlcyBzdGF0dXNcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gc2NoZW1hLl9ydWxlcy5tYXAoKHJ1bGUpID0+IHJ1bGUubmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIFsnZGVmYXVsdCcsICdmYWlsb3ZlciddKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gaW50ZXJuYWxzLmxhYmVsc1tsb2cucnVsZVtuYW1lXSB8fCAwXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0geyBydWxlOiBuYW1lLCBzdGF0dXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cucGF0aHMuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRocyA9IFsuLi5sb2cucGF0aHNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLFxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFNjaGVtYSBtaXNzaW5nIHRlc3RzIGZvciAke21pc3NpbmcubWFwKGludGVybmFscy5tZXNzYWdlKS5qb2luKCcsICcpfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3ZlcmFnZS5sZW5ndGggPyBjb3ZlcmFnZSA6IG51bGw7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuU3RvcmUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcblxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgTWFwKCk7ICAgICAgICAgIC8vIHNjaGVtYSAtPiB7IHBhdGhzLCBlbnRyeSwgcnVsZSwgdmFsaWQsIGludmFsaWQgfVxuICAgICAgICB0aGlzLl9jb21ib3MgPSBuZXcgTWFwKCk7ICAgICAgICAgICAvLyBtZXJnZWQgLT4gW3NvdXJjZXNdXG4gICAgICAgIHRoaXMuX3NjYW4oc2NoZW1hKTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhzdGF0ZSwgc291cmNlLCBuYW1lLCByZXN1bHQpIHtcblxuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1ZyAmJiBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKHsgdHlwZTogc291cmNlLCBuYW1lLCByZXN1bHQsIHBhdGg6IHN0YXRlLnBhdGggfSk7XG4gICAgfVxuXG4gICAgZW50cnkoc2NoZW1hLCBzdGF0ZSkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiAnZW50cnknIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlY29yZChzY2hlbWEsIChsb2cpID0+IHtcblxuICAgICAgICAgICAgbG9nLmVudHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmlsdGVyKHNjaGVtYSwgc3RhdGUsIHNvdXJjZSwgdmFsdWUpIHtcblxuICAgICAgICBpbnRlcm5hbHMuZGVidWcoc3RhdGUsIHsgdHlwZTogc291cmNlLCAuLi52YWx1ZSB9KTtcblxuICAgICAgICB0aGlzLl9yZWNvcmQoc2NoZW1hLCAobG9nKSA9PiB7XG5cbiAgICAgICAgICAgIGxvZ1tzb3VyY2VdLmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvZyhzY2hlbWEsIHN0YXRlLCBzb3VyY2UsIG5hbWUsIHJlc3VsdCkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiBzb3VyY2UsIG5hbWUsIHJlc3VsdDogcmVzdWx0ID09PSAnZnVsbCcgPyAncGFzcycgOiByZXN1bHQgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVjb3JkKHNjaGVtYSwgKGxvZykgPT4ge1xuXG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSA9IGxvZ1tzb3VyY2VdW25hbWVdIHx8IDA7XG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSB8PSBpbnRlcm5hbHMuY29kZXNbcmVzdWx0XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZShzdGF0ZSwgcmVmLCB0bykge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvZyA9IHsgdHlwZTogJ3Jlc29sdmUnLCByZWY6IHJlZi5kaXNwbGF5LCB0bywgcGF0aDogc3RhdGUucGF0aCB9O1xuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKGxvZyk7XG4gICAgfVxuXG4gICAgdmFsdWUoc3RhdGUsIGJ5LCBmcm9tLCB0bywgbmFtZSkge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcgfHxcbiAgICAgICAgICAgIERlZXBFcXVhbChmcm9tLCB0bykpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9nID0geyB0eXBlOiAndmFsdWUnLCBieSwgZnJvbSwgdG8sIHBhdGg6IHN0YXRlLnBhdGggfTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGxvZy5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2gobG9nKTtcbiAgICB9XG5cbiAgICBfcmVjb3JkKHNjaGVtYSwgZWFjaCkge1xuXG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX3NvdXJjZXMuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgIGVhY2gobG9nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSB0aGlzLl9jb21ib3MuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZChzb3VyY2UsIGVhY2gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NjYW4oc2NoZW1hLCBfcGF0aCkge1xuXG4gICAgICAgIGNvbnN0IHBhdGggPSBfcGF0aCB8fCBbXTtcblxuICAgICAgICBsZXQgbG9nID0gdGhpcy5fc291cmNlcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKCFsb2cpIHtcbiAgICAgICAgICAgIGxvZyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoczogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGVudHJ5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBydWxlOiB7fSxcbiAgICAgICAgICAgICAgICB2YWxpZDogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGludmFsaWQ6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fc291cmNlcy5zZXQoc2NoZW1hLCBsb2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2cucGF0aHMuYWRkKHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChzdWIsIHNvdXJjZSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IGludGVybmFscy5pZChzdWIsIHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9zY2FuKHN1YiwgcGF0aC5jb25jYXQoc3ViSWQpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzY2hlbWEuJF9tb2RpZnkoeyBlYWNoLCByZWY6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIHRoaXMuX2NvbWJvcy5zZXQobWVyZ2VkLCBzb3VyY2VzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5tZXNzYWdlID0gZnVuY3Rpb24gKGl0ZW0pIHtcblxuICAgIGNvbnN0IHBhdGggPSBpdGVtLnBhdGhzID8gRXJyb3JzLnBhdGgoaXRlbS5wYXRoc1swXSkgKyAoaXRlbS5ydWxlID8gJzonIDogJycpIDogJyc7XG4gICAgcmV0dXJuIGAke3BhdGh9JHtpdGVtLnJ1bGUgfHwgJyd9ICgke2l0ZW0uc3RhdHVzfSlgO1xufTtcblxuXG5pbnRlcm5hbHMuaWQgPSBmdW5jdGlvbiAoc2NoZW1hLCB7IHNvdXJjZSwgbmFtZSwgcGF0aCwga2V5IH0pIHtcblxuICAgIGlmIChzY2hlbWEuX2ZsYWdzLmlkKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuX2ZsYWdzLmlkO1xuICAgIH1cblxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBuYW1lID0gYEAke25hbWV9YDtcblxuICAgIGlmIChzb3VyY2UgPT09ICd0ZXJtcycpIHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCBwYXRoW01hdGgubWluKHBhdGgubGVuZ3RoIC0gMSwgMSldXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbn07XG5cblxuaW50ZXJuYWxzLnN1YiA9IGZ1bmN0aW9uIChwYXRocywgc2tpcHBlZCkge1xuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2tpcCBvZiBza2lwcGVkKSB7XG4gICAgICAgICAgICBpZiAoRGVlcEVxdWFsKHBhdGguc2xpY2UoMCwgc2tpcC5sZW5ndGgpLCBza2lwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuZGVidWcgPSBmdW5jdGlvbiAoc3RhdGUsIGV2ZW50KSB7XG5cbiAgICBpZiAoc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgZXZlbnQucGF0aCA9IHN0YXRlLmRlYnVnID8gWy4uLnN0YXRlLnBhdGgsIHN0YXRlLmRlYnVnXSA6IHN0YXRlLnBhdGg7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2goZXZlbnQpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgTWVyZ2UgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9tZXJnZScpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FsdGVybmF0aXZlcycsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIG1hdGNoOiB7IGRlZmF1bHQ6ICdhbnknIH0gICAgICAgICAgICAgICAgIC8vICdhbnknLCAnb25lJywgJ2FsbCdcbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBtYXRjaGVzOiB7IGluaXQ6IFtdLCByZWdpc3RlcjogUmVmLnRvU2libGluZyB9XG4gICAgfSxcblxuICAgIGFyZ3Moc2NoZW1hLCAuLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgaWYgKHNjaGVtYXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFzWzBdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2hlbWEudHJ5KC4uLnNjaGVtYXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS50cnkoLi4uc2NoZW1hcyk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMgfSA9IGhlbHBlcnM7XG5cbiAgICAgICAgLy8gTWF0Y2ggYWxsIG9yIG9uZVxuXG4gICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkID0gW107XG4gICAgICAgICAgICBjb25zdCBmYWlsZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5tYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLm5lc3QoaXRlbS5zY2hlbWEsIGBtYXRjaC4ke2l9YCk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5zbmFwc2hvdCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlbS5zY2hlbWEuJF92YWxpZGF0ZSh2YWx1ZSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2gocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZC5wdXNoKHJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGZhaWxlZC5tYXAoKGYpID0+IEVycm9ycy5kZXRhaWxzKGYsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMuYW55JywgY29udGV4dCkgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWF0Y2ggb25lXG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm1hdGNoID09PSAnb25lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVkLmxlbmd0aCA9PT0gMSA/IHsgdmFsdWU6IG1hdGNoZWRbMF0gfSA6IHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLm9uZScpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1hdGNoIGFsbFxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZC5sZW5ndGggIT09IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZmFpbGVkLm1hcCgoZikgPT4gRXJyb3JzLmRldGFpbHMoZiwgeyBvdmVycmlkZTogZmFsc2UgfSkpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbGwnLCBjb250ZXh0KSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpc0FueU9iaiA9IChhbHRlcm5hdGl2ZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsdGVybmF0aXZlLiRfdGVybXMubWF0Y2hlcy5zb21lKCh2KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYuc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodi5zY2hlbWEudHlwZSA9PT0gJ2FsdGVybmF0aXZlcycgJiYgaXNBbnlPYmoodi5zY2hlbWEpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBpc0FueU9iaihzY2hlbWEpID8geyB2YWx1ZTogbWF0Y2hlZC5yZWR1Y2UoKGFjYywgdikgPT4gTWVyZ2UoYWNjLCB2LCB7IG1lcmdlQXJyYXlzOiBmYWxzZSB9KSkgfSA6IHsgdmFsdWU6IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWF0Y2ggYW55XG5cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLiRfdGVybXMubWF0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXNbaV07XG5cbiAgICAgICAgICAgIC8vIFRyeVxuXG4gICAgICAgICAgICBpZiAoaXRlbS5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubmVzdChpdGVtLnNjaGVtYSwgYG1hdGNoLiR7aX1gKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVtLnNjaGVtYS4kX3ZhbGlkYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBzY2hlbWE6IGl0ZW0uc2NoZW1hLCByZXBvcnRzOiByZXN1bHQuZXJyb3JzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb25kaXRpb25hbFxuXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGl0ZW0ucmVmID8gaXRlbS5yZWYucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKSA6IHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdGVzdHMgPSBpdGVtLmlzID8gW2l0ZW1dIDogaXRlbS5zd2l0Y2g7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGVzdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gdGVzdHNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpcywgdGhlbiwgb3RoZXJ3aXNlIH0gPSB0ZXN0O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBgbWF0Y2guJHtpfSR7aXRlbS5zd2l0Y2ggPyAnLicgKyBqIDogJyd9YDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzLiRfbWF0Y2goaW5wdXQsIHN0YXRlLm5lc3QoaXMsIGAke2lkfS5pc2ApLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyd2lzZS4kX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZS5uZXN0KG90aGVyd2lzZSwgYCR7aWR9Lm90aGVyd2lzZWApLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhlbi4kX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZS5uZXN0KHRoZW4sIGAke2lkfS50aGVuYCksIHByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmVycm9ycyhlcnJvcnMsIGhlbHBlcnMpO1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGNvbmRpdGlvbmFsOiB7XG4gICAgICAgICAgICBtZXRob2QoY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2ZsYWdzLl9lbmRlZFN3aXRjaCwgJ1VucmVhY2hhYmxlIGNvbmRpdGlvbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MubWF0Y2gsICdDYW5ub3QgY29tYmluZSBtYXRjaCBtb2RlJywgdGhpcy5fZmxhZ3MubWF0Y2gsICd3aXRoIGNvbmRpdGlvbmFsIHJ1bGUnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQob3B0aW9ucy5icmVhayA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHVzZSBicmVhayBvcHRpb24gd2l0aCBhbHRlcm5hdGl2ZXMgY29uZGl0aW9uYWwnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gQ29tcGlsZS53aGVuKG9iaiwgY29uZGl0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kaXRpb25zID0gbWF0Y2guaXMgPyBbbWF0Y2hdIDogbWF0Y2guc3dpdGNoO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25kaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRoZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3RoZXJ3aXNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai4kX3NldEZsYWcoJ19lbmRlZFN3aXRjaCcsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5tYXRjaGVzLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF0Y2g6IHtcbiAgICAgICAgICAgIG1ldGhvZChtb2RlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydhbnknLCAnb25lJywgJ2FsbCddLmluY2x1ZGVzKG1vZGUpLCAnSW52YWxpZCBhbHRlcm5hdGl2ZXMgbWF0Y2ggbW9kZScsIG1vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgIT09ICdhbnknKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgdGhpcy4kX3Rlcm1zLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydChtYXRjaC5zY2hlbWEsICdDYW5ub3QgY29tYmluZSBtYXRjaCBtb2RlJywgbW9kZSwgJ3dpdGggY29uZGl0aW9uYWwgcnVsZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnbWF0Y2gnLCBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cnk6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoc2NoZW1hcy5sZW5ndGgsICdNaXNzaW5nIGFsdGVybmF0aXZlIHNjaGVtYXMnKTtcbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChzY2hlbWFzLCAndHJ5Jyk7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2ZsYWdzLl9lbmRlZFN3aXRjaCwgJ1VucmVhY2hhYmxlIGNvbmRpdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubWF0Y2hlcy5wdXNoKHsgc2NoZW1hOiBvYmouJF9jb21waWxlKHNjaGVtYSkgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBsYWJlbChuYW1lKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9wYXJlbnQoJ2xhYmVsJywgbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBlYWNoID0gKGl0ZW0sIHNvdXJjZSkgPT4gKHNvdXJjZS5wYXRoWzBdICE9PSAnaXMnID8gaXRlbS5sYWJlbChuYW1lKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXR1cm4gb2JqLiRfbW9kaWZ5KHsgZWFjaCwgcmVmOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWJ1aWxkKHNjaGVtYSkge1xuXG4gICAgICAgIC8vIEZsYWcgd2hlbiBhbiBhbHRlcm5hdGl2ZSB0eXBlIGlzIGFuIGFycmF5XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoaXRlbSkgJiZcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPT09ICdhcnJheScpIHtcblxuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3NldEZsYWcoJ19hcnJheUl0ZW1zJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NoZW1hLiRfbW9kaWZ5KHsgZWFjaCB9KTtcbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgZGVzYy5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCByZWYsIGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSB9ID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai50cnkoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChyZWYsIHsgaXMsIHRoZW4sIG5vdCwgb3RoZXJ3aXNlLCBzd2l0Y2g6IG1hdGNoLnN3aXRjaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChpcywgeyB0aGVuLCBvdGhlcndpc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5hbGwnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbGwgb2YgdGhlIHJlcXVpcmVkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5hbnknOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICAnYWx0ZXJuYXRpdmVzLm1hdGNoJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5vbmUnOiAne3sjbGFiZWx9fSBtYXRjaGVzIG1vcmUgdGhhbiBvbmUgYWxsb3dlZCB0eXBlJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy50eXBlcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgb25lIG9mIHt7I3R5cGVzfX0nXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuZXJyb3JzID0gZnVuY3Rpb24gKGZhaWx1cmVzLCB7IGVycm9yLCBzdGF0ZSB9KSB7XG5cbiAgICAvLyBOb3RoaW5nIG1hdGNoZWQgZHVlIHRvIHR5cGUgY3JpdGVyaWEgcnVsZXNcblxuICAgIGlmICghZmFpbHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbnknKSB9O1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBlcnJvclxuXG4gICAgaWYgKGZhaWx1cmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGZhaWx1cmVzWzBdLnJlcG9ydHMgfTtcbiAgICB9XG5cbiAgICAvLyBBbmFseXplIHJlYXNvbnNcblxuICAgIGNvbnN0IHZhbGlkcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBjb21wbGV4ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHsgcmVwb3J0cywgc2NoZW1hIH0gb2YgZmFpbHVyZXMpIHtcblxuICAgICAgICAvLyBNdWx0aXBsZSBlcnJvcnMgKCFhYm9ydEVhcmx5KVxuXG4gICAgICAgIGlmIChyZXBvcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXN0b20gZXJyb3JcblxuICAgICAgICBjb25zdCByZXBvcnQgPSByZXBvcnRzWzBdO1xuICAgICAgICBpZiAocmVwb3J0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcm5hbCBvYmplY3Qgb3IgYXJyYXkgZXJyb3JcblxuICAgICAgICBpZiAocmVwb3J0LnN0YXRlLnBhdGgubGVuZ3RoICE9PSBzdGF0ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tcGxleC5wdXNoKHsgdHlwZTogc2NoZW1hLnR5cGUsIHJlcG9ydCB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRzXG5cbiAgICAgICAgaWYgKHJlcG9ydC5jb2RlID09PSAnYW55Lm9ubHknKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkIG9mIHJlcG9ydC5sb2NhbC52YWxpZHMpIHtcbiAgICAgICAgICAgICAgICB2YWxpZHMuYWRkKHZhbGlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNlIHR5cGVcblxuICAgICAgICBjb25zdCBbdHlwZSwgY29kZV0gPSByZXBvcnQuY29kZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY29kZSAhPT0gJ2Jhc2UnKSB7XG4gICAgICAgICAgICBjb21wbGV4LnB1c2goeyB0eXBlOiBzY2hlbWEudHlwZSwgcmVwb3J0IH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YWxpZHMuYWRkKHR5cGUpO1xuICAgIH1cblxuICAgIC8vIEFsbCBlcnJvcnMgYXJlIGJhc2UgdHlwZXMgb3IgdmFsaWRzXG5cbiAgICBpZiAoIWNvbXBsZXgubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy50eXBlcycsIHsgdHlwZXM6IFsuLi52YWxpZHNdIH0pIH07XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIGNvbXBsZXggZXJyb3JcblxuICAgIGlmIChjb21wbGV4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGNvbXBsZXhbMF0ucmVwb3J0IH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy51bm1hdGNoZWQoZmFpbHVyZXMsIGVycm9yKTtcbn07XG5cblxuaW50ZXJuYWxzLnVubWF0Y2hlZCA9IGZ1bmN0aW9uIChmYWlsdXJlcywgZXJyb3IpIHtcblxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBmYWlsdXJlcykge1xuICAgICAgICBlcnJvcnMucHVzaCguLi5mYWlsdXJlLnJlcG9ydHMpO1xuICAgIH1cblxuICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5tYXRjaCcsIEVycm9ycy5kZXRhaWxzKGVycm9ycywgeyBvdmVycmlkZTogZmFsc2UgfSkpIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuLi9tZXNzYWdlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FueScsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIG9ubHk6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGFsdGVyYXRpb25zOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgZXhhbXBsZXM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBleHRlcm5hbHM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBtZXRhczogeyBpbml0OiBbXSB9LFxuICAgICAgICBub3RlczogeyBpbml0OiBbXSB9LFxuICAgICAgICBzaGFyZWQ6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICB0YWdzOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIHdoZW5zOiB7IGluaXQ6IG51bGwgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGN1c3RvbToge1xuICAgICAgICAgICAgbWV0aG9kKG1ldGhvZCwgZGVzY3JpcHRpb24pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nLCAnTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydChkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGRlc2NyaXB0aW9uICYmIHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycsICdEZXNjcmlwdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2N1c3RvbScsIGFyZ3M6IHsgbWV0aG9kLCBkZXNjcmlwdGlvbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG1ldGhvZCB9KSB7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignYW55LmN1c3RvbScsIHsgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydtZXRob2QnLCAnZGVzY3JpcHRpb24nXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgICAgIG1ldGhvZChtZXNzYWdlcykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlZnMoeyBtZXNzYWdlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzaGFyZWQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc2NoZW1hKSAmJiBzY2hlbWEuX2ZsYWdzLmlkLCAnU2NoZW1hIG11c3QgYmUgYSBzY2hlbWEgd2l0aCBhbiBpZCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnNoYXJlZCA9IG9iai4kX3Rlcm1zLnNoYXJlZCB8fCBbXTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5zaGFyZWQucHVzaChzY2hlbWEpO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3YXJuaW5nOiB7XG4gICAgICAgICAgICBtZXRob2QoY29kZSwgbG9jYWwpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChjb2RlICYmIHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJywgJ0ludmFsaWQgd2FybmluZyBjb2RlJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnd2FybmluZycsIGFyZ3M6IHsgY29kZSwgbG9jYWwgfSwgd2FybjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBjb2RlLCBsb2NhbCB9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcihjb2RlLCBsb2NhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydjb2RlJywgJ2xvY2FsJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vZGlmaWVyczoge1xuXG4gICAgICAgIGtlZXAocnVsZSwgZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgcnVsZS5rZWVwID0gZW5hYmxlZDtcbiAgICAgICAgfSxcblxuICAgICAgICBtZXNzYWdlKHJ1bGUsIG1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgcnVsZS5tZXNzYWdlID0gTWVzc2FnZXMuY29tcGlsZShtZXNzYWdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3YXJuKHJ1bGUsIGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgIHJ1bGUud2FybiA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVzYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGRlc2Nba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChbJ2V4YW1wbGVzJywgJ2V4dGVybmFscycsICdtZXRhcycsICdub3RlcycsICd0YWdzJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqW2tleS5zbGljZSgwLCAtMSldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdhbHRlcmF0aW9ucycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx0ZXIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhcmdldCwgYWRqdXN0ZXIgfSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVyW3RhcmdldF0gPSBhZGp1c3RlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5hbHRlcihhbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd3aGVucycpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVmLCBpcywgbm90LCB0aGVuLCBvdGhlcndpc2UsIGNvbmNhdCB9ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uY2F0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLmNvbmNhdChjb25jYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLndoZW4ocmVmLCB7IGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSwgc3dpdGNoOiB2YWx1ZS5zd2l0Y2gsIGJyZWFrOiB2YWx1ZS5icmVhayB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai53aGVuKGlzLCB7IHRoZW4sIG90aGVyd2lzZSwgYnJlYWs6IHZhbHVlLmJyZWFrIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5zaGFyZWQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhbnkuY3VzdG9tJzogJ3t7I2xhYmVsfX0gZmFpbGVkIGN1c3RvbSB2YWxpZGF0aW9uIGJlY2F1c2Uge3sjZXJyb3IubWVzc2FnZX19JyxcbiAgICAgICAgJ2FueS5kZWZhdWx0JzogJ3t7I2xhYmVsfX0gdGhyZXcgYW4gZXJyb3Igd2hlbiBydW5uaW5nIGRlZmF1bHQgbWV0aG9kJyxcbiAgICAgICAgJ2FueS5mYWlsb3Zlcic6ICd7eyNsYWJlbH19IHRocmV3IGFuIGVycm9yIHdoZW4gcnVubmluZyBmYWlsb3ZlciBtZXRob2QnLFxuICAgICAgICAnYW55LmludmFsaWQnOiAne3sjbGFiZWx9fSBjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlJyxcbiAgICAgICAgJ2FueS5vbmx5JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSB7aWYoI3ZhbGlkcy5sZW5ndGggPT0gMSwgXCJcIiwgXCJvbmUgb2YgXCIpfXt7I3ZhbGlkc319JyxcbiAgICAgICAgJ2FueS5yZWYnOiAne3sjbGFiZWx9fSB7eyNhcmd9fSByZWZlcmVuY2VzIHt7OiNyZWZ9fSB3aGljaCB7eyNyZWFzb259fScsXG4gICAgICAgICdhbnkucmVxdWlyZWQnOiAne3sjbGFiZWx9fSBpcyByZXF1aXJlZCcsXG4gICAgICAgICdhbnkudW5rbm93bic6ICd7eyNsYWJlbH19IGlzIG5vdCBhbGxvd2VkJ1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9yZWFjaCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYXJyYXknLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICBzaW5nbGU6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgc3BhcnNlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBpdGVtczogeyBpbml0OiBbXSwgbWFuaWZlc3Q6ICdzY2hlbWEnIH0sXG4gICAgICAgIG9yZGVyZWQ6IHsgaW5pdDogW10sIG1hbmlmZXN0OiAnc2NoZW1hJyB9LFxuXG4gICAgICAgIF9leGNsdXNpb25zOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIF9pbmNsdXNpb25zOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIF9yZXF1aXJlZHM6IHsgaW5pdDogW10gfVxuICAgIH0sXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogJ29iamVjdCcsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNvcnQgPSBzY2hlbWEuJF9nZXRSdWxlKCdzb3J0Jyk7XG4gICAgICAgICAgICBpZiAoIXNvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuc29ydChzY2hlbWEsIHZhbHVlLCBzb3J0LmFyZ3Mub3B0aW9ucywgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yIH0pIHtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy5zaW5nbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaW5nbGUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgICAgIHNpbmdsZVtDb21tb24uc3ltYm9scy5hcnJheVNpbmdsZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBzaW5nbGUgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcignYXJyYXkuYmFzZScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNjaGVtYS4kX2dldFJ1bGUoJ2l0ZW1zJykgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLnNsaWNlKCkgfTsgICAgICAgIC8vIENsb25lIHRoZSBhcnJheSBzbyB0aGF0IHdlIGRvbid0IG1vZGlmeSB0aGUgb3JpZ2luYWxcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBoYXM6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuJF9jb21waWxlKHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2hhcycsIGFyZ3M6IHsgc2NoZW1hIH0gfSk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IHN0YXRlLCBwcmVmcywgZXJyb3IgfSwgeyBzY2hlbWE6IGhhcyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGldLCBhbmNlc3RvcnMsIGhhcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXMuJF9tYXRjaCh2YWx1ZVtpXSwgbG9jYWxTdGF0ZSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuTGFiZWwgPSBoYXMuX2ZsYWdzLmxhYmVsO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuTGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS5oYXNLbm93bicsIHsgcGF0dGVybkxhYmVsIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkuaGFzVW5rbm93bicsIG51bGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChzY2hlbWFzLCAnaXRlbXMnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9hZGRSdWxlKCdpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWFzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBDb21tb24udHJ5V2l0aFBhdGgoKCkgPT4gdGhpcy4kX2NvbXBpbGUoc2NoZW1hc1tpXSksIGksIHsgYXBwZW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5pdGVtcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgc3RhdGUsIHByZWZzLCBlcnJvcnNBcnJheSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1aXJlZHMgPSBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZHMgPSBzY2hlbWEuJF90ZXJtcy5vcmRlcmVkLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5jbHVzaW9ucyA9IFsuLi5zY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucywgLi4ucmVxdWlyZWRzXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHdhc0FycmF5ID0gIXZhbHVlW0NvbW1vbi5zeW1ib2xzLmFycmF5U2luZ2xlXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbQ29tbW9uLnN5bWJvbHMuYXJyYXlTaW5nbGVdO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gZXJyb3JzQXJyYXkoKTtcblxuICAgICAgICAgICAgICAgIGxldCBpbCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gd2FzQXJyYXkgPyBpIDogbmV3IE51bWJlcihpKTsgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IFsuLi5zdGF0ZS5wYXRoLCBrZXldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNwYXJzZVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBFeGNsdXNpb25zXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXhjbHVzaW9uIG9mIHNjaGVtYS4kX3Rlcm1zLl9leGNsdXNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4Y2x1c2lvbi4kX21hdGNoKGl0ZW0sIHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgZXhjbHVzaW9uKSwgcHJlZnMsIHsgcHJlc2VuY2U6ICdpZ25vcmUnIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5leGNsdWRlcycsIHsgcG9zOiBpLCB2YWx1ZTogaXRlbSB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9yZGVyZWRcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMub3JkZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkID0gb3JkZXJlZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBvcmRlcmVkLiRfdmFsaWRhdGUoaXRlbSwgc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCBvcmRlcmVkKSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXJlZC5fZmxhZ3MucmVzdWx0ID09PSAnc3RyaXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJiByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LnNwYXJzZScsIHsga2V5LCBwYXRoLCBwb3M6IGksIHZhbHVlOiB1bmRlZmluZWQgfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc2NoZW1hLiRfdGVybXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5Lm9yZGVyZWRMZW5ndGgnLCB7IHBvczogaSwgbGltaXQ6IHNjaGVtYS4kX3Rlcm1zLm9yZGVyZWQubGVuZ3RoIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgIC8vIE5vIHJlYXNvbiB0byBjb250aW51ZSBzaW5jZSB0aGVyZSBhcmUgbm8gb3RoZXIgcnVsZXMgdG8gdmFsaWRhdGUgb3RoZXIgdGhhbiBhcnJheS5vcmRlcmVkTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXF1aXJlZHNcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1aXJlZENoZWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgamwgPSByZXF1aXJlZHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGpsOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIHJlcXVpcmVkc1tqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHJlcXVpcmVkc1tqXS4kX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkQ2hlY2tzW2pdID0gcmVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZShyZXF1aXJlZHMsIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWpsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jbHVzaW9uc1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmlwVW5rbm93biA9IHByZWZzLnN0cmlwVW5rbm93biAmJiAhIXByZWZzLnN0cmlwVW5rbm93bi5hcnJheXMgfHwgZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgamwgPSBpbmNsdXNpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmNsdXNpb24gb2YgaW5jbHVzaW9ucykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCByZS1ydW5uaW5nIHJlcXVpcmVkcyB0aGF0IGFscmVhZHkgZGlkbid0IG1hdGNoIGluIHRoZSBwcmV2aW91cyBsb29wXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0NoZWNrID0gcmVxdWlyZWRzLmluZGV4T2YoaW5jbHVzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NoZWNrICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcXVpcmVkQ2hlY2tzW3ByZXZpb3VzQ2hlY2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgaW5jbHVzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBpbmNsdXNpb24uJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdXNpb24uX2ZsYWdzLnJlc3VsdCA9PT0gJ3N0cmlwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UodmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGFjdHVhbCBlcnJvciBpZiBvbmx5IG9uZSBpbmNsdXNpb24gZGVmaW5lZFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoamwgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoc2NoZW1hLiRfdGVybXMuX2luY2x1c2lvbnMubGVuZ3RoIHx8IHNjaGVtYS4kX3Rlcm1zLl9yZXF1aXJlZHMubGVuZ3RoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzVmFsaWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LmluY2x1ZGVzJywgeyBwb3M6IGksIHZhbHVlOiBpdGVtIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmlsbE1pc3NlZEVycm9ycyhzY2hlbWEsIGVycm9ycywgcmVxdWlyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5maWxsT3JkZXJlZEVycm9ycyhzY2hlbWEsIGVycm9ycywgb3JkZXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZpbGxEZWZhdWx0KG9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwcmlvcml0eTogdHJ1ZSxcbiAgICAgICAgICAgIG1hbmlmZXN0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz0nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLmxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2FycmF5LicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4JywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzw9JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3JkZXJlZDoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHNjaGVtYXMsICdvcmRlcmVkJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfYWRkUnVsZSgnaXRlbXMnKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IHRoaXMuJF9jb21waWxlKHNjaGVtYXNbaV0pLCBpLCB7IGFwcGVuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlKHR5cGUsIG9iaik7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIodHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLm9yZGVyZWQucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNpbmdsZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZW5hYmxlZDtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXZhbHVlIHx8ICF0aGlzLl9mbGFncy5fYXJyYXlJdGVtcywgJ0Nhbm5vdCBzcGVjaWZ5IHNpbmdsZSBydWxlIHdoZW4gYXJyYXkgaGFzIGFycmF5IGl0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3NpbmdsZScsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzb3J0OiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2J5JywgJ29yZGVyJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiBvcHRpb25zLm9yZGVyIHx8ICdhc2NlbmRpbmcnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmJ5ID0gQ29tcGlsZS5yZWYob3B0aW9ucy5ieSwgeyBhbmNlc3RvcjogMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KCFzZXR0aW5ncy5ieS5hbmNlc3RvciwgJ0Nhbm5vdCBzb3J0IGJ5IGFuY2VzdG9yJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3NvcnQnLCBhcmdzOiB7IG9wdGlvbnM6IHNldHRpbmdzIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IsIHN0YXRlLCBwcmVmcywgc2NoZW1hIH0sIHsgb3B0aW9ucyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBzb3J0ZWQsIGVycm9ycyB9ID0gaW50ZXJuYWxzLnNvcnQoc2NoZW1hLCB2YWx1ZSwgb3B0aW9ucywgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbaV0gIT09IHNvcnRlZFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS5zb3J0JywgeyBvcmRlcjogb3B0aW9ucy5vcmRlciwgYnk6IG9wdGlvbnMuYnkgPyBvcHRpb25zLmJ5LmtleSA6ICd2YWx1ZScgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHNwYXJzZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZW5hYmxlZDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy5zcGFyc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHZhbHVlID8gdGhpcy5jbG9uZSgpIDogdGhpcy4kX2FkZFJ1bGUoJ2l0ZW1zJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX3NldEZsYWcoJ3NwYXJzZScsIHZhbHVlLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bmlxdWU6IHtcbiAgICAgICAgICAgIG1ldGhvZChjb21wYXJhdG9yLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghY29tcGFyYXRvciB8fCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycsICdjb21wYXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnaWdub3JlVW5kZWZpbmVkJywgJ3NlcGFyYXRvciddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSB7IG5hbWU6ICd1bmlxdWUnLCBhcmdzOiB7IG9wdGlvbnMsIGNvbXBhcmF0b3IgfSB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gQ29tbW9uLmRlZmF1bHQob3B0aW9ucy5zZXBhcmF0b3IsICcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLnBhdGggPSBzZXBhcmF0b3IgPyBjb21wYXJhdG9yLnNwbGl0KHNlcGFyYXRvcikgOiBbY29tcGFyYXRvcl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHJ1bGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IHN0YXRlLCBlcnJvciwgc2NoZW1hIH0sIHsgY29tcGFyYXRvcjogcmF3LCBvcHRpb25zIH0sIHsgY29tcGFyYXRvciwgcGF0aCB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBudW1iZXI6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbTogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmUgPSBjb21wYXJhdG9yIHx8IERlZXBFcXVhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHBhdGggPyBSZWFjaCh2YWx1ZVtpXSwgcGF0aCkgOiB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkcyA9IGNvbXBhcmF0b3IgPyBmb3VuZC5jdXN0b20gOiBmb3VuZFt0eXBlb2YgaXRlbV07XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChyZWNvcmRzLCAnRmFpbGVkIHRvIGZpbmQgdW5pcXVlIG1hcCBjb250YWluZXIgZm9yIHR5cGUnLCB0eXBlb2YgaXRlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZHMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSByZWNvcmRzLmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCEoY3VycmVudCA9IGVudHJpZXMubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoY3VycmVudC52YWx1ZVswXSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVQb3M6IGN1cnJlbnQudmFsdWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlVmFsdWU6IHZhbHVlW2N1cnJlbnQudmFsdWVbMV1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGF0aCA9IHJhdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkudW5pcXVlJywgY29udGV4dCwgbG9jYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNldChpdGVtLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoIWlnbm9yZVVuZGVmaW5lZCB8fCBpdGVtICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkc1tpdGVtXSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVBvczogcmVjb3Jkc1tpdGVtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVZhbHVlOiB2YWx1ZVtyZWNvcmRzW2l0ZW1dXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGggPSByYXc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5LnVuaXF1ZScsIGNvbnRleHQsIGxvY2FsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzW2l0ZW1dID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2NvbXBhcmF0b3InLCAnb3B0aW9ucyddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIHNldDoge1xuICAgICAgICAgICAgZnJvbTogQXJyYXkuaXNBcnJheSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICBzY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucyA9IFtdO1xuICAgICAgICBzY2hlbWEuJF90ZXJtcy5fZXhjbHVzaW9ucyA9IFtdO1xuICAgICAgICBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHNjaGVtYS4kX3Rlcm1zLml0ZW1zKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGVTaW5nbGUodHlwZSwgc2NoZW1hKTtcblxuICAgICAgICAgICAgaWYgKHR5cGUuX2ZsYWdzLnByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZS5fZmxhZ3MucHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygc2NoZW1hLiRfdGVybXMub3JkZXJlZCkge1xuICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlKHR5cGUsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmouaXRlbXMoLi4uZGVzYy5pdGVtcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoub3JkZXJlZCguLi5kZXNjLm9yZGVyZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhcnJheS5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhbiBhcnJheScsXG4gICAgICAgICdhcnJheS5leGNsdWRlcyc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGFuIGV4Y2x1ZGVkIHZhbHVlJyxcbiAgICAgICAgJ2FycmF5Lmhhc0tub3duJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWF0Y2ggZm9yIHR5cGUgezojcGF0dGVybkxhYmVsfScsXG4gICAgICAgICdhcnJheS5oYXNVbmtub3duJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWF0Y2gnLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXMnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEJvdGgnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBjb250YWluIHt7I2tub3duTWlzc2VzfX0gYW5kIHt7I3Vua25vd25NaXNzZXN9fSBvdGhlciByZXF1aXJlZCB2YWx1ZShzKScsXG4gICAgICAgICdhcnJheS5pbmNsdWRlc1JlcXVpcmVkS25vd25zJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiB7eyNrbm93bk1pc3Nlc319JyxcbiAgICAgICAgJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRVbmtub3ducyc6ICd7eyNsYWJlbH19IGRvZXMgbm90IGNvbnRhaW4ge3sjdW5rbm93bk1pc3Nlc319IHJlcXVpcmVkIHZhbHVlKHMpJyxcbiAgICAgICAgJ2FycmF5Lmxlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiB7eyNsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgJ2FycmF5Lm1heCc6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5vcmRlcmVkTGVuZ3RoJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGF0IG1vc3Qge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5zb3J0JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBzb3J0ZWQgaW4geyNvcmRlcn0gb3JkZXIgYnkge3sjYnl9fScsXG4gICAgICAgICdhcnJheS5zb3J0Lm1pc21hdGNoaW5nJzogJ3t7I2xhYmVsfX0gY2Fubm90IGJlIHNvcnRlZCBkdWUgdG8gbWlzbWF0Y2hpbmcgdHlwZXMnLFxuICAgICAgICAnYXJyYXkuc29ydC51bnN1cHBvcnRlZCc6ICd7eyNsYWJlbH19IGNhbm5vdCBiZSBzb3J0ZWQgZHVlIHRvIHVuc3VwcG9ydGVkIHR5cGUgeyN0eXBlfScsXG4gICAgICAgICdhcnJheS5zcGFyc2UnOiAne3sjbGFiZWx9fSBtdXN0IG5vdCBiZSBhIHNwYXJzZSBhcnJheSBpdGVtJyxcbiAgICAgICAgJ2FycmF5LnVuaXF1ZSc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGEgZHVwbGljYXRlIHZhbHVlJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmZpbGxNaXNzZWRFcnJvcnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBlcnJvcnMsIHJlcXVpcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qga25vd25NaXNzZXMgPSBbXTtcbiAgICBsZXQgdW5rbm93bk1pc3NlcyA9IDA7XG4gICAgZm9yIChjb25zdCByZXF1aXJlZCBvZiByZXF1aXJlZHMpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSByZXF1aXJlZC5fZmxhZ3MubGFiZWw7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAga25vd25NaXNzZXMucHVzaChsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICArK3Vua25vd25NaXNzZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa25vd25NaXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh1bmtub3duTWlzc2VzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEJvdGgnLCB2YWx1ZSwgeyBrbm93bk1pc3NlcywgdW5rbm93bk1pc3NlcyB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkS25vd25zJywgdmFsdWUsIHsga25vd25NaXNzZXMgfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkVW5rbm93bnMnLCB2YWx1ZSwgeyB1bmtub3duTWlzc2VzIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZpbGxPcmRlcmVkRXJyb3JzID0gZnVuY3Rpb24gKHNjaGVtYSwgZXJyb3JzLCBvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3QgcmVxdWlyZWRPcmRlcmVkcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBvcmRlcmVkIG9mIG9yZGVyZWRzKSB7XG4gICAgICAgIGlmIChvcmRlcmVkLl9mbGFncy5wcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmVxdWlyZWRPcmRlcmVkcy5wdXNoKG9yZGVyZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcXVpcmVkT3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgIGludGVybmFscy5maWxsTWlzc2VkRXJyb3JzKHNjaGVtYSwgZXJyb3JzLCByZXF1aXJlZE9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5maWxsRGVmYXVsdCA9IGZ1bmN0aW9uIChvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gW107XG4gICAgbGV0IHRyYWlsaW5nVW5kZWZpbmVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSBvcmRlcmVkcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBvcmRlcmVkID0gb3JkZXJlZHNbaV07XG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBvcmRlcmVkLiRfdmFsaWRhdGUodW5kZWZpbmVkLCBzdGF0ZS5sb2NhbGl6ZShzdGF0ZS5wYXRoLCBhbmNlc3RvcnMsIG9yZGVyZWQpLCBwcmVmcykudmFsdWU7XG5cbiAgICAgICAgaWYgKHRyYWlsaW5nVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFpbGluZ1VuZGVmaW5lZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3ZlcnJpZGVzLnVuc2hpZnQob3ZlcnJpZGUpO1xuICAgIH1cblxuICAgIGlmIChvdmVycmlkZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlLnB1c2goLi4ub3ZlcnJpZGVzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5mYXN0U3BsaWNlID0gZnVuY3Rpb24gKGFyciwgaSkge1xuXG4gICAgbGV0IHBvcyA9IGk7XG4gICAgd2hpbGUgKHBvcyA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgYXJyW3BvcysrXSA9IGFycltwb3NdO1xuICAgIH1cblxuICAgIC0tYXJyLmxlbmd0aDtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlID0gZnVuY3Rpb24gKHR5cGUsIG9iaikge1xuXG4gICAgaWYgKHR5cGUudHlwZSA9PT0gJ2FycmF5JyB8fFxuICAgICAgICB0eXBlLl9mbGFncy5fYXJyYXlJdGVtcykge1xuXG4gICAgICAgIEFzc2VydCghb2JqLl9mbGFncy5zaW5nbGUsICdDYW5ub3Qgc3BlY2lmeSBhcnJheSBpdGVtIHdpdGggc2luZ2xlIHJ1bGUgZW5hYmxlZCcpO1xuICAgICAgICBvYmouJF9zZXRGbGFnKCdfYXJyYXlJdGVtcycsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNvcnQgPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgc2V0dGluZ3MsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qgb3JkZXIgPSBzZXR0aW5ncy5vcmRlciA9PT0gJ2FzY2VuZGluZycgPyAxIDogLTE7XG4gICAgY29uc3QgYUZpcnN0ID0gLTEgKiBvcmRlcjtcbiAgICBjb25zdCBiRmlyc3QgPSBvcmRlcjtcblxuICAgIGNvbnN0IHNvcnQgPSAoYSwgYikgPT4ge1xuXG4gICAgICAgIGxldCBjb21wYXJlID0gaW50ZXJuYWxzLmNvbXBhcmUoYSwgYiwgYUZpcnN0LCBiRmlyc3QpO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuYnkpIHtcbiAgICAgICAgICAgIGEgPSBzZXR0aW5ncy5ieS5yZXNvbHZlKGEsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBiID0gc2V0dGluZ3MuYnkucmVzb2x2ZShiLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcGFyZSA9IGludGVybmFscy5jb21wYXJlKGEsIGIsIGFGaXJzdCwgYkZpcnN0KTtcbiAgICAgICAgaWYgKGNvbXBhcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBhO1xuICAgICAgICBpZiAodHlwZSAhPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgICAgIHRocm93IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5zb3J0Lm1pc21hdGNoaW5nJywgdmFsdWUsIG51bGwsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSAhPT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIHRocm93IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5zb3J0LnVuc3VwcG9ydGVkJywgdmFsdWUsIHsgdHlwZSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEgLSBiKSAqIG9yZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgPCBiID8gYUZpcnN0IDogYkZpcnN0O1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUuc2xpY2UoKS5zb3J0KHNvcnQpIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnIgfTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIsIGFGaXJzdCwgYkZpcnN0KSB7XG5cbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxOyAgICAgICAgICAgLy8gQWx3YXlzIGxhc3QgcmVnYXJkbGVzcyBvZiBzb3J0IG9yZGVyXG4gICAgfVxuXG4gICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTE7ICAgICAgICAgICAvLyBBbHdheXMgbGFzdCByZWdhcmRsZXNzIG9mIHNvcnQgb3JkZXJcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYkZpcnN0O1xuICAgIH1cblxuICAgIGlmIChiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhRmlyc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYmluYXJ5JyxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiAnc3RyaW5nJyxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSB9KSB7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IEJ1ZmZlci5mcm9tKHZhbHVlLCBzY2hlbWEuX2ZsYWdzLmVuY29kaW5nKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZUVycikgeyB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2JpbmFyeS5iYXNlJykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBlbmNvZGluZzoge1xuICAgICAgICAgICAgbWV0aG9kKGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpLCAnSW52YWxpZCBlbmNvZGluZzonLCBlbmNvZGluZyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2VuY29kaW5nJywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVuZ3RoJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz0nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLmxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2JpbmFyeS4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgc3RyaW5nOiB7XG4gICAgICAgICAgICBmcm9tOiAodmFsdWUpID0+IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2JpbmFyeS5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZycsXG4gICAgICAgICdiaW5hcnkubGVuZ3RoJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSB7eyNsaW1pdH19IGJ5dGVzJyxcbiAgICAgICAgJ2JpbmFyeS5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGJ5dGVzJyxcbiAgICAgICAgJ2JpbmFyeS5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGF0IGxlYXN0IHt7I2xpbWl0fX0gYnl0ZXMnXG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBWYWx1ZXMgPSByZXF1aXJlKCcuLi92YWx1ZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuaXNCb29sID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYm9vbGVhbicsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHNlbnNpdGl2ZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgZmFsc3k6IHtcbiAgICAgICAgICAgIGluaXQ6IG51bGwsXG4gICAgICAgICAgICBtYW5pZmVzdDogJ3ZhbHVlcydcbiAgICAgICAgfSxcblxuICAgICAgICB0cnV0aHk6IHtcbiAgICAgICAgICAgIGluaXQ6IG51bGwsXG4gICAgICAgICAgICBtYW5pZmVzdDogJ3ZhbHVlcydcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2UodmFsdWUsIHsgc2NoZW1hIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gc2NoZW1hLl9mbGFncy5zZW5zaXRpdmUgPyB2YWx1ZSA6IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5vcm1hbGl6ZWQgPT09ICd0cnVlJyA/IHRydWUgOiAobm9ybWFsaXplZCA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNjaGVtYS4kX3Rlcm1zLnRydXRoeSAmJiBzY2hlbWEuJF90ZXJtcy50cnV0aHkuaGFzKHZhbHVlLCBudWxsLCBudWxsLCAhc2NoZW1hLl9mbGFncy5zZW5zaXRpdmUpIHx8XG4gICAgICAgICAgICAgICAgKHNjaGVtYS4kX3Rlcm1zLmZhbHN5ICYmIHNjaGVtYS4kX3Rlcm1zLmZhbHN5Lmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgIXNjaGVtYS5fZmxhZ3Muc2Vuc2l0aXZlKSA/IGZhbHNlIDogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2Jvb2xlYW4uYmFzZScpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgdHJ1dGh5OiB7XG4gICAgICAgICAgICBtZXRob2QoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICd0cnV0aHknKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy50cnV0aHkgPSBvYmouJF90ZXJtcy50cnV0aHkgfHwgbmV3IFZhbHVlcygpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCB0cnV0aHkgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMudHJ1dGh5LmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmYWxzeToge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnZhbHVlcykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCAnZmFsc3knKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5mYWxzeSA9IG9iai4kX3Rlcm1zLmZhbHN5IHx8IG5ldyBWYWx1ZXMoKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgZmFsc3kgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuZmFsc3kuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNlbnNpdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3NlbnNpdGl2ZScsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgICBmcm9tOiBpbnRlcm5hbHMuaXNCb29sLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0Jvb2wsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy50cnV0aHkpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoudHJ1dGh5KC4uLmRlc2MudHJ1dGh5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MuZmFsc3kpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmouZmFsc3koLi4uZGVzYy5mYWxzeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2Jvb2xlYW4uYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBib29sZWFuJ1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5pc0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnZGF0ZScsXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogWydudW1iZXInLCAnc3RyaW5nJ10sXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaW50ZXJuYWxzLnBhcnNlKHZhbHVlLCBzY2hlbWEuX2ZsYWdzLmZvcm1hdCkgfHwgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJlxuICAgICAgICAgICAgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9ybWF0ID0gc2NoZW1hLl9mbGFncy5mb3JtYXQ7XG5cbiAgICAgICAgaWYgKCFwcmVmcy5jb252ZXJ0IHx8XG4gICAgICAgICAgICAhZm9ybWF0IHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdkYXRlLmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2RhdGUuZm9ybWF0JywgeyBmb3JtYXQgfSkgfTtcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBjb21wYXJlOiB7XG4gICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgZGF0ZSB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gZGF0ZSA9PT0gJ25vdycgPyBEYXRlLm5vdygpIDogZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLmdldFRpbWUoKSwgdG8sIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2RhdGUuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MuZGF0ZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2RhdGUnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZTogKGRhdGUpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUgPT09ICdub3cnID8gZGF0ZSA6IGludGVybmFscy5wYXJzZShkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiAoZGF0ZSkgPT4gZGF0ZSAhPT0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgaGF2ZSBhIHZhbGlkIGRhdGUgZm9ybWF0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChmb3JtYXQpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2lzbycsICdqYXZhc2NyaXB0JywgJ3VuaXgnXS5pbmNsdWRlcyhmb3JtYXQpLCAnVW5rbm93biBkYXRlIGZvcm1hdCcsIGZvcm1hdCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Zvcm1hdCcsIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3JlYXRlcjoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdncmVhdGVyJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgZGF0ZSB9LCBvcGVyYXRvcjogJz4nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzbzoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KCdpc28nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZXNzOiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlc3MnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGltZXN0YW1wOiB7XG4gICAgICAgICAgICBtZXRob2QodHlwZSA9ICdqYXZhc2NyaXB0Jykge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnamF2YXNjcmlwdCcsICd1bml4J10uaW5jbHVkZXModHlwZSksICdcInR5cGVcIiBtdXN0IGJlIG9uZSBvZiBcImphdmFzY3JpcHQsIHVuaXhcIicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgICBmcm9tOiBpbnRlcm5hbHMuaXNEYXRlLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzRGF0ZSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCB7IHByZWZzIH0pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZS5kYXRlKHZhbHVlLCBwcmVmcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2RhdGUuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBkYXRlJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBpbiB7bXNnKFwiZGF0ZS5mb3JtYXQuXCIgKyAjZm9ybWF0KSB8fCAjZm9ybWF0fSBmb3JtYXQnLFxuICAgICAgICAnZGF0ZS5ncmVhdGVyJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBncmVhdGVyIHRoYW4ge3s6I2xpbWl0fX0nLFxuICAgICAgICAnZGF0ZS5sZXNzJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBsZXNzIHRoYW4ge3s6I2xpbWl0fX0nLFxuICAgICAgICAnZGF0ZS5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7ezojbGltaXR9fScsXG4gICAgICAgICdkYXRlLm1pbic6ICd7eyNsYWJlbH19IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHt7OiNsaW1pdH19JyxcblxuICAgICAgICAvLyBNZXNzYWdlcyB1c2VkIGluIGRhdGUuZm9ybWF0XG5cbiAgICAgICAgJ2RhdGUuZm9ybWF0Lmlzbyc6ICdJU08gODYwMSBkYXRlJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0LmphdmFzY3JpcHQnOiAndGltZXN0YW1wIG9yIG51bWJlciBvZiBtaWxsaXNlY29uZHMnLFxuICAgICAgICAnZGF0ZS5mb3JtYXQudW5peCc6ICd0aW1lc3RhbXAgb3IgbnVtYmVyIG9mIHNlY29uZHMnXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMucGFyc2UgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICgvXlxccyokLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJU09cblxuICAgIGlmIChmb3JtYXQgPT09ICdpc28nKSB7XG4gICAgICAgIGlmICghQ29tbW9uLmlzSXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBudW1iZXIgc3RyaW5nXG5cbiAgICBjb25zdCBvcmlnaW5hbCA9IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIC9eWystXT9cXGQrKFxcLlxcZCspPyQvLnRlc3QodmFsdWUpKSB7XG5cbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBUaW1lc3RhbXBcblxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2phdmFzY3JpcHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUoMSAqIHZhbHVlKTsgICAgICAgIC8vIENhc3RpbmcgdG8gbnVtYmVyXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybWF0ID09PSAndW5peCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSgxMDAwICogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGxhaW5cblxuICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSh2YWx1ZSk7XG59O1xuXG5cbmludGVybmFscy5kYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmICghaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleXMuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHR5cGVvZjogJ2Z1bmN0aW9uJ1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBhcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID49IDAsICduIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnYXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5hcml0eScsIHsgbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdjbGFzcycpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKC9eXFxzKmNsYXNzXFxzLykudGVzdCh2YWx1ZS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLmNsYXNzJywgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW5Bcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID4gMCwgJ24gbXVzdCBiZSBhIHN0cmljdCBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluQXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLm1pbkFyaXR5JywgeyBuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heEFyaXR5OiB7XG4gICAgICAgICAgICBtZXRob2Qobikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKG4pICYmIG4gPj0gMCwgJ24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXhBcml0eScsIGFyZ3M6IHsgbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG4gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZnVuY3Rpb24ubWF4QXJpdHknLCB7IG4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2Z1bmN0aW9uLmFyaXR5JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGFuIGFyaXR5IG9mIHt7I259fScsXG4gICAgICAgICdmdW5jdGlvbi5jbGFzcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBjbGFzcycsXG4gICAgICAgICdmdW5jdGlvbi5tYXhBcml0eSc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSBhbiBhcml0eSBsZXNzZXIgb3IgZXF1YWwgdG8ge3sjbn19JyxcbiAgICAgICAgJ2Z1bmN0aW9uLm1pbkFyaXR5JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGFuIGFyaXR5IGdyZWF0ZXIgb3IgZXF1YWwgdG8ge3sjbn19J1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBcHBseVRvRGVmYXVsdHMgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hcHBseVRvRGVmYXVsdHMnKTtcbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgVG9wbyA9IHJlcXVpcmUoJ0BoYXBpL3RvcG8nKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgQ29tcGlsZSA9IHJlcXVpcmUoJy4uL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi4vcmVmJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHJlbmFtZURlZmF1bHRzOiB7XG4gICAgICAgIGFsaWFzOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBvbGQgdmFsdWUgaW4gcGxhY2VcbiAgICAgICAgbXVsdGlwbGU6IGZhbHNlLCAgICAgICAgICAgICAgICAvLyBBbGxvdyByZW5hbWluZyBtdWx0aXBsZSBrZXlzIGludG8gdGhlIHNhbWUgdGFyZ2V0XG4gICAgICAgIG92ZXJyaWRlOiBmYWxzZSAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIGFuIGV4aXN0aW5nIGtleVxuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdfa2V5cycsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgICAgdHlwZW9mOiAnb2JqZWN0J1xuICAgIH0sXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHVua25vd246IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGRlcGVuZGVuY2llczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIGtleXM6IHsgaW5pdDogbnVsbCwgbWFuaWZlc3Q6IHsgbWFwcGVkOiB7IGZyb206ICdzY2hlbWEnLCB0bzogJ2tleScgfSB9IH0sXG4gICAgICAgIHBhdHRlcm5zOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgcmVuYW1lczogeyBpbml0OiBudWxsIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIGtleXMpIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hLmtleXMoa2V5cyk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IsIHN0YXRlLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSBzY2hlbWEuJF9wcm9wZXJ0eSgndHlwZW9mJykgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdvYmplY3QuYmFzZScsIHsgdHlwZTogc2NoZW1hLiRfcHJvcGVydHkoJ3R5cGVvZicpIH0pIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTa2lwIGlmIHRoZXJlIGFyZSBubyBvdGhlciBydWxlcyB0byB0ZXN0XG5cbiAgICAgICAgaWYgKCFzY2hlbWEuJF90ZXJtcy5yZW5hbWVzICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMua2V5cyAmJiAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVsbCBhbGxvd3MgYW55IGtleXNcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmV4dGVybmFscykge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaGFsbG93IGNsb25lIHZhbHVlXG5cbiAgICAgICAgdmFsdWUgPSBpbnRlcm5hbHMuY2xvbmUodmFsdWUsIHByZWZzKTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICAgICAgLy8gUmVuYW1lIGtleXNcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMucmVuYW1lcyAmJlxuICAgICAgICAgICAgIWludGVybmFscy5yZW5hbWUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzLCBlcnJvcnMpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFueXRoaW5nIGFsbG93ZWRcblxuICAgICAgICBpZiAoIXNjaGVtYS4kX3Rlcm1zLmtleXMgJiYgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bGwgYWxsb3dzIGFueSBrZXlzXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMucGF0dGVybnMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5kZXBlbmRlbmNpZXMpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9ycyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lZCBrZXlzXG5cbiAgICAgICAgY29uc3QgdW5wcm9jZXNzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHZhbHVlKSk7XG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBzY2hlbWEuJF90ZXJtcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGtleV0sIGFuY2VzdG9ycywgY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoaWxkLnNjaGVtYS4kX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHByZWZzKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXN1bHQuZXJyb3JzIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQuc2NoZW1hLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID09PSB1bmRlZmluZWQgJiYgaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5rbm93biBrZXlzXG5cbiAgICAgICAgaWYgKHVucHJvY2Vzc2VkLnNpemUgfHxcbiAgICAgICAgICAgIHNjaGVtYS5fZmxhZ3MuX2hhc1BhdHRlcm5NYXRjaCkge1xuXG4gICAgICAgICAgICBjb25zdCBlYXJseSA9IGludGVybmFscy51bmtub3duKHNjaGVtYSwgdmFsdWUsIHVucHJvY2Vzc2VkLCBlcnJvcnMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBpZiAoZWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFybHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBkZXBlbmRlbmNpZXNcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiBzY2hlbWEuJF90ZXJtcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwLmtleSAmJlxuICAgICAgICAgICAgICAgICAgICBkZXAua2V5LnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsZWQgPSBpbnRlcm5hbHMuZGVwZW5kZW5jaWVzW2RlcC5yZWxdKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKGZhaWxlZC5jb2RlLCB2YWx1ZSwgZmFpbGVkLmNvbnRleHQsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXBvcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9ycyB9O1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGFuZDoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAnYW5kJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ2FuZCcsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhcHBlbmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXNzZXJ0OiB7XG4gICAgICAgICAgICBtZXRob2Qoc3ViamVjdCwgc2NoZW1hLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIVRlbXBsYXRlLmlzVGVtcGxhdGUoc3ViamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdCA9IENvbXBpbGUucmVmKHN1YmplY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChtZXNzYWdlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnLCAnTWVzc2FnZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLiRfY29tcGlsZShzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2Fzc2VydCcsIGFyZ3M6IHsgc3ViamVjdCwgc2NoZW1hLCBtZXNzYWdlIH0gfSk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yLCBwcmVmcywgc3RhdGUgfSwgeyBzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWJvdXQgPSBzdWJqZWN0LnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IFJlZi5pc1JlZihzdWJqZWN0KSA/IHN1YmplY3QuYWJzb2x1dGUoc3RhdGUpIDogW107XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS4kX21hdGNoKGFib3V0LCBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc10sIHNjaGVtYSksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdvYmplY3QuYXNzZXJ0JywgeyBzdWJqZWN0LCBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnc3ViamVjdCcsICdzY2hlbWEnLCAnbWVzc2FnZSddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpbnN0YW5jZToge1xuICAgICAgICAgICAgbWV0aG9kKGNvbnN0cnVjdG9yLCBuYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nLCAnY29uc3RydWN0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2luc3RhbmNlJywgYXJnczogeyBjb25zdHJ1Y3RvciwgbmFtZSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGNvbnN0cnVjdG9yLCBuYW1lIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0Lmluc3RhbmNlJywgeyB0eXBlOiBuYW1lLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2NvbnN0cnVjdG9yJywgJ25hbWUnXVxuICAgICAgICB9LFxuXG4gICAgICAgIGtleXM6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0JywgJ09iamVjdCBzY2hlbWEgbXVzdCBiZSBhIHZhbGlkIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSksICdPYmplY3Qgc2NoZW1hIGNhbm5vdCBiZSBhIGpvaSBzY2hlbWEnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGlmICghc2NoZW1hKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbGxcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCkgeyAgICAgICAgICAgICAvLyBBbGxvdyBub25lXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmtleXMgPSBuZXcgaW50ZXJuYWxzLktleXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmtleXMgPSBvYmouJF90ZXJtcy5rZXlzID8gb2JqLiRfdGVybXMua2V5cy5maWx0ZXIoKGNoaWxkKSA9PiAhc2NoZW1hLmhhc093blByb3BlcnR5KGNoaWxkLmtleSkpIDogbmV3IGludGVybmFscy5LZXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IG9iai4kX3Rlcm1zLmtleXMucHVzaCh7IGtleSwgc2NoZW1hOiB0aGlzLiRfY29tcGlsZShzY2hlbWFba2V5XSkgfSksIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz0nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24ubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBuYW5kOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4ucGVlcnMgLyosIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQocGVlcnMsICduYW5kJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ25hbmQnLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ29yJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ29yJywgbnVsbCwgcGVlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG94b3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ294b3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgbWV0aG9kKHBhdHRlcm4sIHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlZ0V4cCA9IHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy4kX2NvbXBpbGUocGF0dGVybiwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWEgIT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgcnVsZScpO1xuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnZmFsbHRocm91Z2gnLCAnbWF0Y2hlcyddKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc1JlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXBhdHRlcm4uZmxhZ3MuaW5jbHVkZXMoJ2cnKSAmJiAhcGF0dGVybi5mbGFncy5pbmNsdWRlcygneScpLCAncGF0dGVybiBzaG91bGQgbm90IHVzZSBnbG9iYWwgb3Igc3RpY2t5IG1vZGUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLiRfY29tcGlsZShzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5wYXR0ZXJucyA9IG9iai4kX3Rlcm1zLnBhdHRlcm5zIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHsgW2lzUmVnRXhwID8gJ3JlZ2V4JyA6ICdzY2hlbWEnXTogcGF0dGVybiwgcnVsZTogc2NoZW1hIH07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcubWF0Y2hlcyA9IHRoaXMuJF9jb21waWxlKG9wdGlvbnMubWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubWF0Y2hlcy50eXBlICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcubWF0Y2hlcyA9IGNvbmZpZy5tYXRjaGVzLiRfcm9vdC5hcnJheSgpLml0ZW1zKGNvbmZpZy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKGNvbmZpZy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfc2V0RmxhZygnX2hhc1BhdHRlcm5NYXRjaCcsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZhbGx0aHJvdWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5mYWxsdGhyb3VnaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucGF0dGVybnMucHVzaChjb25maWcpO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWY6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncmVmJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChSZWYuaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0LnJlZlR5cGUnLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ3JlZ2V4Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC5yZWdleCcsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuYW1lOiB7XG4gICAgICAgICAgICBtZXRob2QoZnJvbSwgdG8sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyB8fCBmcm9tIGluc3RhbmNlb2YgUmVnRXhwLCAnUmVuYW1lIG1pc3NpbmcgdGhlIGZyb20gYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHRvID09PSAnc3RyaW5nJyB8fCB0byBpbnN0YW5jZW9mIFRlbXBsYXRlLCAnSW52YWxpZCByZW5hbWUgdG8gYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodG8gIT09IGZyb20sICdDYW5ub3QgcmVuYW1lIGtleSB0byBzYW1lIG5hbWU6JywgZnJvbSk7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsaWFzJywgJ2lnbm9yZVVuZGVmaW5lZCcsICdvdmVycmlkZScsICdtdWx0aXBsZSddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlbmFtZXMgPSBvYmouJF90ZXJtcy5yZW5hbWVzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVuYW1lIG9mIG9iai4kX3Rlcm1zLnJlbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHJlbmFtZS5mcm9tICE9PSBmcm9tLCAnQ2Fubm90IHJlbmFtZSB0aGUgc2FtZSBrZXkgbXVsdGlwbGUgdGltZXMnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodG8gaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih0byk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVuYW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IEFwcGx5VG9EZWZhdWx0cyhpbnRlcm5hbHMucmVuYW1lRGVmYXVsdHMsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgbWV0aG9kKHR5cGUgPSAnYW55Jykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3NjaGVtYScsIGFyZ3M6IHsgdHlwZSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHR5cGUgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYSh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT09ICdhbnknIHx8IHZhbHVlLnR5cGUgPT09IHR5cGUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3Quc2NoZW1hJywgeyB0eXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVua25vd246IHtcbiAgICAgICAgICAgIG1ldGhvZChhbGxvdykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd1bmtub3duJywgYWxsb3cgIT09IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3aXRoOiB7XG4gICAgICAgICAgICBtZXRob2Qoa2V5LCBwZWVycywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3dpdGgnLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3aXRob3V0OiB7XG4gICAgICAgICAgICBtZXRob2Qoa2V5LCBwZWVycywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3dpdGhvdXQnLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB4b3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ3hvcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kZXBlbmRlbmN5KHRoaXMsICd4b3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb3ZlcnJpZGVzOiB7XG5cbiAgICAgICAgZGVmYXVsdCh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfcGFyZW50KCdkZWZhdWx0JywgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlYnVpbGQoc2NoZW1hKSB7XG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcG8gPSBuZXcgVG9wby5Tb3J0ZXIoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgICAgIENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0b3BvLmFkZChjaGlsZCwgeyBhZnRlcjogY2hpbGQuc2NoZW1hLiRfcm9vdFJlZmVyZW5jZXMoKSwgZ3JvdXA6IGNoaWxkLmtleSB9KSwgY2hpbGQua2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMua2V5cyA9IG5ldyBpbnRlcm5hbHMuS2V5cyguLi50b3BvLm5vZGVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLmtleXMoZGVzYy5rZXlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlbCwga2V5ID0gbnVsbCwgcGVlcnMsIG9wdGlvbnMgfSBvZiBkZXNjLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBpbnRlcm5hbHMuZGVwZW5kZW5jeShvYmosIHJlbCwga2V5LCBwZWVycywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5wYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZWdleCwgc2NoZW1hLCBydWxlLCBmYWxsdGhyb3VnaCwgbWF0Y2hlcyB9IG9mIGRlc2MucGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLnBhdHRlcm4ocmVnZXggfHwgc2NoZW1hLCBydWxlLCB7IGZhbGx0aHJvdWdoLCBtYXRjaGVzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MucmVuYW1lcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBmcm9tLCB0bywgb3B0aW9ucyB9IG9mIGRlc2MucmVuYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucmVuYW1lKGZyb20sIHRvLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ29iamVjdC5hbmQnOiAne3sjbGFiZWx9fSBjb250YWlucyB7eyNwcmVzZW50V2l0aExhYmVsc319IHdpdGhvdXQgaXRzIHJlcXVpcmVkIHBlZXJzIHt7I21pc3NpbmdXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0LmFzc2VydCc6ICd7eyNsYWJlbH19IGlzIGludmFsaWQgYmVjYXVzZSB7aWYoI3N1YmplY3Qua2V5LCBgXCJgICsgI3N1YmplY3Qua2V5ICsgYFwiIGZhaWxlZCB0byBgICsgKCNtZXNzYWdlIHx8IFwicGFzcyB0aGUgYXNzZXJ0aW9uIHRlc3RcIiksICNtZXNzYWdlIHx8IFwidGhlIGFzc2VydGlvbiBmYWlsZWRcIil9JyxcbiAgICAgICAgJ29iamVjdC5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBvZiB0eXBlIHt7I3R5cGV9fScsXG4gICAgICAgICdvYmplY3QuaW5zdGFuY2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHt7OiN0eXBlfX0nLFxuICAgICAgICAnb2JqZWN0Lmxlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSB7eyNsaW1pdH19IGtleXtpZigjbGltaXQgPT0gMSwgXCJcIiwgXCJzXCIpfScsXG4gICAgICAgICdvYmplY3QubWF4JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGtleXtpZigjbGltaXQgPT0gMSwgXCJcIiwgXCJzXCIpfScsXG4gICAgICAgICdvYmplY3QubWluJzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGF0IGxlYXN0IHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5taXNzaW5nJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBvZiB7eyNwZWVyc1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3QubmFuZCc6ICd7ezojbWFpbldpdGhMYWJlbH19IG11c3Qgbm90IGV4aXN0IHNpbXVsdGFuZW91c2x5IHdpdGgge3sjcGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0Lm94b3InOiAne3sjbGFiZWx9fSBjb250YWlucyBhIGNvbmZsaWN0IGJldHdlZW4gb3B0aW9uYWwgZXhjbHVzaXZlIHBlZXJzIHt7I3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgJ29iamVjdC5wYXR0ZXJuLm1hdGNoJzogJ3t7I2xhYmVsfX0ga2V5cyBmYWlsZWQgdG8gbWF0Y2ggcGF0dGVybiByZXF1aXJlbWVudHMnLFxuICAgICAgICAnb2JqZWN0LnJlZlR5cGUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgSm9pIHJlZmVyZW5jZScsXG4gICAgICAgICdvYmplY3QucmVnZXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgUmVnRXhwIG9iamVjdCcsXG4gICAgICAgICdvYmplY3QucmVuYW1lLm11bHRpcGxlJzogJ3t7I2xhYmVsfX0gY2Fubm90IHJlbmFtZSB7ezojZnJvbX19IGJlY2F1c2UgbXVsdGlwbGUgcmVuYW1lcyBhcmUgZGlzYWJsZWQgYW5kIGFub3RoZXIga2V5IHdhcyBhbHJlYWR5IHJlbmFtZWQgdG8ge3s6I3RvfX0nLFxuICAgICAgICAnb2JqZWN0LnJlbmFtZS5vdmVycmlkZSc6ICd7eyNsYWJlbH19IGNhbm5vdCByZW5hbWUge3s6I2Zyb219fSBiZWNhdXNlIG92ZXJyaWRlIGlzIGRpc2FibGVkIGFuZCB0YXJnZXQge3s6I3RvfX0gZXhpc3RzJyxcbiAgICAgICAgJ29iamVjdC5zY2hlbWEnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgSm9pIHNjaGVtYSBvZiB7eyN0eXBlfX0gdHlwZScsXG4gICAgICAgICdvYmplY3QudW5rbm93bic6ICd7eyNsYWJlbH19IGlzIG5vdCBhbGxvd2VkJyxcbiAgICAgICAgJ29iamVjdC53aXRoJzogJ3t7OiNtYWluV2l0aExhYmVsfX0gbWlzc2luZyByZXF1aXJlZCBwZWVyIHt7OiNwZWVyV2l0aExhYmVsfX0nLFxuICAgICAgICAnb2JqZWN0LndpdGhvdXQnOiAne3s6I21haW5XaXRoTGFiZWx9fSBjb25mbGljdCB3aXRoIGZvcmJpZGRlbiBwZWVyIHt7OiNwZWVyV2l0aExhYmVsfX0nLFxuICAgICAgICAnb2JqZWN0Lnhvcic6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGEgY29uZmxpY3QgYmV0d2VlbiBleGNsdXNpdmUgcGVlcnMge3sjcGVlcnNXaXRoTGFiZWxzfX0nXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuY2xvbmUgPSBmdW5jdGlvbiAodmFsdWUsIHByZWZzKSB7XG5cbiAgICAvLyBPYmplY3RcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChwcmVmcy5ub25FbnVtZXJhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIENsb25lKHZhbHVlLCB7IHNoYWxsb3c6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY2xvbmUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9uXG5cbiAgICBjb25zdCBjbG9uZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjbG9uZS5wcm90b3R5cGUgPSBDbG9uZSh2YWx1ZS5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZSwgJ25hbWUnLCB7IHZhbHVlOiB2YWx1ZS5uYW1lLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCAnbGVuZ3RoJywgeyB2YWx1ZTogdmFsdWUubGVuZ3RoLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihjbG9uZSwgdmFsdWUpO1xuICAgIHJldHVybiBjbG9uZTtcbn07XG5cblxuaW50ZXJuYWxzLmRlcGVuZGVuY3kgPSBmdW5jdGlvbiAoc2NoZW1hLCByZWwsIGtleSwgcGVlcnMsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydChrZXkgPT09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycsIHJlbCwgJ2tleSBtdXN0IGJlIGEgc3RyaW5ncycpO1xuXG4gICAgLy8gRXh0cmFjdCBvcHRpb25zIGZyb20gcGVlcnMgYXJyYXlcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gcGVlcnMubGVuZ3RoID4gMSAmJiB0eXBlb2YgcGVlcnNbcGVlcnMubGVuZ3RoIC0gMV0gPT09ICdvYmplY3QnID8gcGVlcnMucG9wKCkgOiB7fTtcbiAgICB9XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3NlcGFyYXRvciddKTtcblxuICAgIHBlZXJzID0gW10uY29uY2F0KHBlZXJzKTtcblxuICAgIC8vIENhc3QgcGVlciBwYXRoc1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gQ29tbW9uLmRlZmF1bHQob3B0aW9ucy5zZXBhcmF0b3IsICcuJyk7XG4gICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBlZXIgb2YgcGVlcnMpIHtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJywgcmVsLCAncGVlcnMgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgIHBhdGhzLnB1c2goQ29tcGlsZS5yZWYocGVlciwgeyBzZXBhcmF0b3IsIGFuY2VzdG9yOiAwLCBwcmVmaXg6IGZhbHNlIH0pKTtcbiAgICB9XG5cbiAgICAvLyBDYXN0IGtleVxuXG4gICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICBrZXkgPSBDb21waWxlLnJlZihrZXksIHsgc2VwYXJhdG9yLCBhbmNlc3RvcjogMCwgcHJlZml4OiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcnVsZVxuXG4gICAgY29uc3Qgb2JqID0gc2NoZW1hLmNsb25lKCk7XG4gICAgb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzID0gb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzIHx8IFtdO1xuICAgIG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcy5wdXNoKG5ldyBpbnRlcm5hbHMuRGVwZW5kZW5jeShyZWwsIGtleSwgcGF0aHMsIHBlZXJzKSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLmRlcGVuZGVuY2llcyA9IHtcblxuICAgIGFuZChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBjb25zdCBjb3VudCA9IGRlcC5wZWVycy5sZW5ndGg7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCAhPT0gY291bnQgJiZcbiAgICAgICAgICAgIHByZXNlbnQubGVuZ3RoICE9PSBjb3VudCkge1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdvYmplY3QuYW5kJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnRXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCksXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmcsXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgbWlzc2luZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5hbmQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbnQubGVuZ3RoICE9PSBkZXAucGVlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYWluID0gZGVwLnBhdGhzWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZXAucGF0aHMuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiAnb2JqZWN0Lm5hbmQnLFxuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgIG1haW4sXG4gICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIG1haW4pLFxuICAgICAgICAgICAgICAgIHBlZXJzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgdmFsdWVzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBvcihzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogJ29iamVjdC5taXNzaW5nJyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICBwZWVyczogZGVwLnBhdGhzLFxuICAgICAgICAgICAgICAgIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5wYXRocylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgb3hvcihzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByZXNlbnQubGVuZ3RoIHx8XG4gICAgICAgICAgICBwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZXh0ID0geyBwZWVyczogZGVwLnBhdGhzLCBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAucGF0aHMpIH07XG4gICAgICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3Qub3hvcicsIGNvbnRleHQgfTtcbiAgICB9LFxuXG4gICAgd2l0aChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnb2JqZWN0LndpdGgnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkZXAua2V5LmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAua2V5LmtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyOiBwZWVyLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJXaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwZWVyLmtleSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd2l0aG91dChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnb2JqZWN0LndpdGhvdXQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkZXAua2V5LmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAua2V5LmtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyOiBwZWVyLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJXaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwZWVyLmtleSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgeG9yKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgcGVlcnM6IGRlcC5wYXRocywgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLnBhdGhzKSB9O1xuICAgICAgICBpZiAocHJlc2VudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QubWlzc2luZycsIGNvbnRleHQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QueG9yJywgY29udGV4dCB9O1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmtleXNUb0xhYmVscyA9IGZ1bmN0aW9uIChzY2hlbWEsIGtleXMpIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgIHJldHVybiBrZXlzLm1hcCgoa2V5KSA9PiBzY2hlbWEuJF9tYXBMYWJlbHMoa2V5KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS4kX21hcExhYmVscyhrZXlzKTtcbn07XG5cblxuaW50ZXJuYWxzLnJlbmFtZSA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGVycm9ycykge1xuXG4gICAgY29uc3QgcmVuYW1lZCA9IHt9O1xuICAgIGZvciAoY29uc3QgcmVuYW1lIG9mIHNjaGVtYS4kX3Rlcm1zLnJlbmFtZXMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gdHlwZW9mIHJlbmFtZS5mcm9tICE9PSAnc3RyaW5nJztcblxuICAgICAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlbmFtZS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZVtyZW5hbWUuZnJvbV0gIT09IHVuZGVmaW5lZCB8fCAhcmVuYW1lLm9wdGlvbnMuaWdub3JlVW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHJlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyb20gaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbZnJvbV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICByZW5hbWUub3B0aW9ucy5pZ25vcmVVbmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gcmVuYW1lLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVuYW1lLmZyb20uZXhlYyhmcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7IGZyb20sIHRvOiByZW5hbWUudG8sIG1hdGNoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gbWF0Y2guZnJvbTtcbiAgICAgICAgICAgIGxldCB0byA9IG1hdGNoLnRvO1xuICAgICAgICAgICAgaWYgKHRvIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICB0byA9IHRvLnJlbmRlcih2YWx1ZSwgc3RhdGUsIHByZWZzLCBtYXRjaC5tYXRjaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlbmFtZS5vcHRpb25zLm11bHRpcGxlICYmXG4gICAgICAgICAgICAgICAgcmVuYW1lZFt0b10pIHtcblxuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QucmVuYW1lLm11bHRpcGxlJywgdmFsdWUsIHsgZnJvbSwgdG8sIHBhdHRlcm4gfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgdG8pICYmXG4gICAgICAgICAgICAgICAgIXJlbmFtZS5vcHRpb25zLm92ZXJyaWRlICYmXG4gICAgICAgICAgICAgICAgIXJlbmFtZWRbdG9dKSB7XG5cbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnJlbmFtZS5vdmVycmlkZScsIHZhbHVlLCB7IGZyb20sIHRvLCBwYXR0ZXJuIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZVtmcm9tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW3RvXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlW3RvXSA9IHZhbHVlW2Zyb21dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5hbWVkW3RvXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghcmVuYW1lLm9wdGlvbnMuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbZnJvbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuaW50ZXJuYWxzLnVua25vd24gPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgdW5wcm9jZXNzZWQsIGVycm9ycywgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBpZiAoc2NoZW1hLiRfdGVybXMucGF0dGVybnMpIHtcbiAgICAgICAgbGV0IGhhc01hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zLm1hcCgocGF0dGVybikgPT4ge1xuXG4gICAgICAgICAgICBpZiAocGF0dGVybi5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IFsuLi5zdGF0ZS5wYXRoLCBrZXldO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcGF0dGVybi5yZWdleC50ZXN0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5kZWJ1ZyhzdGF0ZSwgJ3J1bGUnLCBgcGF0dGVybi4ke2l9YCwgbWF0Y2ggPyAncGFzcycgOiAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF0dGVybi5zY2hlbWEuJF9tYXRjaChrZXksIHN0YXRlLm5lc3QocGF0dGVybi5zY2hlbWEsIGBwYXR0ZXJuLiR7aX1gKSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgeyBzY2hlbWE6IHBhdHRlcm4ucnVsZSwga2V5IH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhdHRlcm4ucnVsZS4kX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVzdWx0LmVycm9ycyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4ubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzW2ldLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghcGF0dGVybi5mYWxsdGhyb3VnaCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBwYXR0ZXJuIG1hdGNoZXMgcnVsZXNcblxuICAgICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RwbSA9IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zW2ldLm1hdGNoZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHN0YXRlLnBhdGgsIGFuY2VzdG9ycywgc3RwbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RwbS4kX3ZhbGlkYXRlKG1hdGNoLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IEVycm9ycy5kZXRhaWxzKHJlc3VsdC5lcnJvcnMsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ29iamVjdC5wYXR0ZXJuLm1hdGNoJywgdmFsdWUsIGRldGFpbHMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXBvcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1bnByb2Nlc3NlZC5zaXplIHx8XG4gICAgICAgICFzY2hlbWEuJF90ZXJtcy5rZXlzICYmICFzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucykgeyAgICAgLy8gSWYgbm8ga2V5cyBvciBwYXR0ZXJucyBzcGVjaWZpZWQsIHVua25vd24ga2V5cyBhbGxvd2VkXG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcmVmcy5zdHJpcFVua25vd24gJiYgIXNjaGVtYS5fZmxhZ3MudW5rbm93biB8fFxuICAgICAgICBwcmVmcy5za2lwRnVuY3Rpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgc3RyaXBVbmtub3duID0gcHJlZnMuc3RyaXBVbmtub3duID8gKHByZWZzLnN0cmlwVW5rbm93biA9PT0gdHJ1ZSA/IHRydWUgOiAhIXByZWZzLnN0cmlwVW5rbm93bi5vYmplY3RzKSA6IGZhbHNlO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZm9yYmlkVW5rbm93biA9ICFDb21tb24uZGVmYXVsdChzY2hlbWEuX2ZsYWdzLnVua25vd24sIHByZWZzLmFsbG93VW5rbm93bik7XG4gICAgaWYgKGZvcmJpZFVua25vd24pIHtcbiAgICAgICAgZm9yIChjb25zdCB1bnByb2Nlc3NlZEtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCB1bnByb2Nlc3NlZEtleV0sIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QudW5rbm93bicsIHZhbHVlW3VucHJvY2Vzc2VkS2V5XSwgeyBjaGlsZDogdW5wcm9jZXNzZWRLZXkgfSwgbG9jYWxTdGF0ZSwgcHJlZnMsIHsgZmxhZ3M6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXBvcnQgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkRlcGVuZGVuY3kgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWwsIGtleSwgcGVlcnMsIHBhdGhzKSB7XG5cbiAgICAgICAgdGhpcy5yZWwgPSByZWw7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnBlZXJzID0gcGVlcnM7XG4gICAgICAgIHRoaXMucGF0aHMgPSBwYXRocztcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBkZXNjID0ge1xuICAgICAgICAgICAgcmVsOiB0aGlzLnJlbCxcbiAgICAgICAgICAgIHBlZXJzOiB0aGlzLnBhdGhzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMua2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkZXNjLmtleSA9IHRoaXMua2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBlZXJzWzBdLnNlcGFyYXRvciAhPT0gJy4nKSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB7IHNlcGFyYXRvcjogdGhpcy5wZWVyc1swXS5zZXBhcmF0b3IgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLktleXMgPSBjbGFzcyBleHRlbmRzIEFycmF5IHtcblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNsaWNlKCk7XG5cbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGtleXMuc2V0KHJlc3VsdFtpXS5rZXksIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaXRlbS5rZXk7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBrZXlzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Bvc10gPSB7IGtleSwgc2NoZW1hOiByZXN1bHRbcG9zXS5zY2hlbWEuY29uY2F0KGl0ZW0uc2NoZW1hKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdsaW5rJyxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgc2NoZW1hQ2hhaW46IHRydWVcbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBsaW5rOiB7IGluaXQ6IG51bGwsIG1hbmlmZXN0OiAnc2luZ2xlJywgcmVnaXN0ZXI6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIHJlZikge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWEucmVmKHJlZik7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICBBc3NlcnQoc2NoZW1hLiRfdGVybXMubGluaywgJ1VuaW5pdGlhbGl6ZWQgbGluayBzY2hlbWEnKTtcblxuICAgICAgICBjb25zdCBsaW5rZWQgPSBpbnRlcm5hbHMuZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgY29uc3QgcmVmID0gc2NoZW1hLiRfdGVybXMubGlua1swXS5yZWY7XG4gICAgICAgIHJldHVybiBsaW5rZWQuJF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUubmVzdChsaW5rZWQsIGBsaW5rOiR7cmVmLmRpc3BsYXl9OiR7bGlua2VkLnR5cGV9YCksIHByZWZzKTtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIHJlZjoge1xuICAgICAgICAgICAgbWV0aG9kKHJlZikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLiRfdGVybXMubGluaywgJ0Nhbm5vdCByZWluaXRpYWxpemUgc2NoZW1hJyk7XG5cbiAgICAgICAgICAgICAgICByZWYgPSBDb21waWxlLnJlZihyZWYpO1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZi50eXBlID09PSAndmFsdWUnIHx8IHJlZi50eXBlID09PSAnbG9jYWwnLCAnSW52YWxpZCByZWZlcmVuY2UgdHlwZTonLCByZWYudHlwZSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZi50eXBlID09PSAnbG9jYWwnIHx8IHJlZi5hbmNlc3RvciA9PT0gJ3Jvb3QnIHx8IHJlZi5hbmNlc3RvciA+IDAsICdMaW5rIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubGluayA9IFt7IHJlZiB9XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVsYXRpdmUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgICAgIEFzc2VydCh0aGlzLiRfdGVybXMubGluaywgJ1VuaW5pdGlhbGl6ZWQgbGluayBzY2hlbWEnKTtcbiAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc291cmNlKSwgJ0ludmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuICAgICAgICAgICAgQXNzZXJ0KHNvdXJjZS50eXBlICE9PSAnbGluaycsICdDYW5ub3QgbWVyZ2UgdHlwZSBsaW5rIHdpdGggYW5vdGhlciBsaW5rJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgaWYgKCFvYmouJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zLnB1c2goeyBjb25jYXQ6IHNvdXJjZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KGRlc2MubGluaywgJ0ludmFsaWQgbGluayBkZXNjcmlwdGlvbiBtaXNzaW5nIGxpbmsnKTtcbiAgICAgICAgICAgIHJldHVybiBvYmoucmVmKGRlc2MubGluayk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGxldCBsaW5rZWQgPSBzdGF0ZS5tYWluc3RheS5saW5rcy5nZXQoc2NoZW1hKTtcbiAgICBpZiAobGlua2VkKSB7XG4gICAgICAgIHJldHVybiBsaW5rZWQuX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpLnNjaGVtYTtcbiAgICB9XG5cbiAgICBjb25zdCByZWYgPSBzY2hlbWEuJF90ZXJtcy5saW5rWzBdLnJlZjtcbiAgICBjb25zdCB7IHBlcnNwZWN0aXZlLCBwYXRoIH0gPSBpbnRlcm5hbHMucGVyc3BlY3RpdmUocmVmLCBzdGF0ZSk7XG4gICAgaW50ZXJuYWxzLmFzc2VydChwZXJzcGVjdGl2ZSwgJ3doaWNoIGlzIG91dHNpZGUgb2Ygc2NoZW1hIGJvdW5kYXJpZXMnLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGxpbmtlZCA9IHBhdGgubGVuZ3RoID8gcGVyc3BlY3RpdmUuJF9yZWFjaChwYXRoKSA6IHBlcnNwZWN0aXZlO1xuICAgIH1cbiAgICBjYXRjaCAoaWdub3JlRXJyKSB7XG4gICAgICAgIGludGVybmFscy5hc3NlcnQoZmFsc2UsICd0byBub24tZXhpc3Rpbmcgc2NoZW1hJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxzLmFzc2VydChsaW5rZWQudHlwZSAhPT0gJ2xpbmsnLCAnd2hpY2ggaXMgYW5vdGhlciBsaW5rJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICBpZiAoIXNjaGVtYS5fZmxhZ3MucmVsYXRpdmUpIHtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkubGlua3Muc2V0KHNjaGVtYSwgbGlua2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlua2VkLl9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKS5zY2hlbWE7XG59O1xuXG5cbmludGVybmFscy5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIChyZWYsIHN0YXRlKSB7XG5cbiAgICBpZiAocmVmLnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IHNjaGVtYSwga2V5IH0gb2Ygc3RhdGUuc2NoZW1hcykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZyb20gcGFyZW50IHRvIHJvb3RcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2NoZW1hLl9mbGFncy5pZCB8fCBrZXk7XG4gICAgICAgICAgICBpZiAoaWQgPT09IHJlZi5wYXRoWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IHNjaGVtYSwgcGF0aDogcmVmLnBhdGguc2xpY2UoMSkgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnNoYXJlZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2hhcmVkIG9mIHNjaGVtYS4kX3Rlcm1zLnNoYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkLl9mbGFncy5pZCA9PT0gcmVmLnBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBzaGFyZWQsIHBhdGg6IHJlZi5wYXRoLnNsaWNlKDEpIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogbnVsbCwgcGF0aDogbnVsbCB9O1xuICAgIH1cblxuICAgIGlmIChyZWYuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc3RhdGUuc2NoZW1hc1tzdGF0ZS5zY2hlbWFzLmxlbmd0aCAtIDFdLnNjaGVtYSwgcGF0aDogcmVmLnBhdGggfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc3RhdGUuc2NoZW1hc1tyZWYuYW5jZXN0b3JdICYmIHN0YXRlLnNjaGVtYXNbcmVmLmFuY2VzdG9yXS5zY2hlbWEsIHBhdGg6IHJlZi5wYXRoIH07XG59O1xuXG5cbmludGVybmFscy5hc3NlcnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBtZXNzYWdlLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBpZiAoY29uZGl0aW9uKSB7ICAgICAgICAgICAgICAgIC8vIE1hbnVhbCBjaGVjayB0byBhdm9pZCBnZW5lcmF0aW5nIGVycm9yIG1lc3NhZ2Ugb24gc3VjY2Vzc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgQXNzZXJ0KGZhbHNlLCBgXCIke0Vycm9ycy5sYWJlbChzY2hlbWEuX2ZsYWdzLCBzdGF0ZSwgcHJlZnMpfVwiIGNvbnRhaW5zIGxpbmsgcmVmZXJlbmNlIFwiJHtyZWYuZGlzcGxheX1cIiAke21lc3NhZ2V9YCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBudW1iZXJSeDogL15cXHMqWystXT8oPzooPzpcXGQrKD86XFwuXFxkKik/KXwoPzpcXC5cXGQrKSkoPzplKFsrLV0/XFxkKykpP1xccyokL2ksXG4gICAgcHJlY2lzaW9uUng6IC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC9cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdudW1iZXInLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICB1bnNhZmU6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogJ3N0cmluZycsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yIH0pIHtcblxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlLm1hdGNoKGludGVybmFscy5udW1iZXJSeCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogcGFyc2VGbG9hdCh2YWx1ZSkgfTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IDA7ICAgICAgICAgICAvLyAtMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3MudW5zYWZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9lL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdGVkID0gaW50ZXJuYWxzLm5vcm1hbGl6ZUV4cG9uZW50KGAke3Jlc3VsdC52YWx1ZSAvIE1hdGgucG93KDEwLCBtYXRjaGVzWzFdKX1lJHttYXRjaGVzWzFdfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RydWN0ZWQgIT09IGludGVybmFscy5ub3JtYWxpemVFeHBvbmVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBlcnJvcignbnVtYmVyLnVuc2FmZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gcmVzdWx0LnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmcubWF0Y2goL2UvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nICE9PSBpbnRlcm5hbHMubm9ybWFsaXplRGVjaW1hbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBlcnJvcignbnVtYmVyLnVuc2FmZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fFxuICAgICAgICAgICAgdmFsdWUgPT09IC1JbmZpbml0eSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignbnVtYmVyLmluZmluaXR5JykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQ29tbW9uLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ251bWJlci5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWUgfTtcblxuICAgICAgICBpZiAocHJlZnMuY29udmVydCkge1xuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHNjaGVtYS4kX2dldFJ1bGUoJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgcnVsZS5hcmdzLmxpbWl0KTsgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgY29uY2VwdHVhbGx5IGVxdWl2YWxlbnQgdG8gdXNpbmcgdG9GaXhlZCBidXQgaXQgc2hvdWxkIGJlIG11Y2ggZmFzdGVyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gTWF0aC5yb3VuZChyZXN1bHQudmFsdWUgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC52YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gMDsgICAgICAgICAgIC8vIC0wXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3MudW5zYWZlICYmXG4gICAgICAgICAgICAodmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCB2YWx1ZSA8IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSkge1xuXG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gZXJyb3IoJ251bWJlci51bnNhZmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY29tcGFyZToge1xuICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLCBsaW1pdCwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmlzTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIG51bWJlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3JlYXRlcjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZ3JlYXRlcicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPicgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW50ZWdlcjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdpbnRlZ2VyJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChNYXRoLnRydW5jKHZhbHVlKSAtIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLmludGVnZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZXNzOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZXNzJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbXVsdGlwbGU6IHtcbiAgICAgICAgICAgIG1ldGhvZChiYXNlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbXVsdGlwbGUnLCBhcmdzOiB7IGJhc2UgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBiYXNlIH0sIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAqICgxIC8gYmFzZSkgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLm11bHRpcGxlJywgeyBtdWx0aXBsZTogb3B0aW9ucy5hcmdzLmJhc2UsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiYXNlJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBuZWdhdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbignbmVnYXRpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwb3J0OiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ3BvcnQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIDw9IDY1NTM1KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIucG9ydCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvc2l0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduKCdwb3NpdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHByZWNpc2lvbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpLCAnbGltaXQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAncHJlY2lzaW9uJywgYXJnczogeyBsaW1pdCB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlcyA9IHZhbHVlLnRvU3RyaW5nKCkubWF0Y2goaW50ZXJuYWxzLnByZWNpc2lvblJ4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IE1hdGgubWF4KChwbGFjZXNbMV0gPyBwbGFjZXNbMV0ubGVuZ3RoIDogMCkgLSAocGxhY2VzWzJdID8gcGFyc2VJbnQocGxhY2VzWzJdLCAxMCkgOiAwKSwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlY2ltYWxzIDw9IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLnByZWNpc2lvbicsIHsgbGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBzaWduOiB7XG4gICAgICAgICAgICBtZXRob2Qoc2lnbikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnbmVnYXRpdmUnLCAncG9zaXRpdmUnXS5pbmNsdWRlcyhzaWduKSwgJ0ludmFsaWQgc2lnbicsIHNpZ24pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3NpZ24nLCBhcmdzOiB7IHNpZ24gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBzaWduIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChzaWduID09PSAnbmVnYXRpdmUnICYmIHZhbHVlIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICBzaWduID09PSAncG9zaXRpdmUnICYmIHZhbHVlID4gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcihgbnVtYmVyLiR7c2lnbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bnNhZmU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBlbmFibGVkID09PSAnYm9vbGVhbicsICdlbmFibGVkIG11c3QgYmUgYSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Vuc2FmZScsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgc3RyaW5nOiB7XG4gICAgICAgICAgICBmcm9tOiAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ251bWJlci5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICAgICdudW1iZXIuZ3JlYXRlcic6ICd7eyNsYWJlbH19IG11c3QgYmUgZ3JlYXRlciB0aGFuIHt7I2xpbWl0fX0nLFxuICAgICAgICAnbnVtYmVyLmluZmluaXR5JzogJ3t7I2xhYmVsfX0gY2Fubm90IGJlIGluZmluaXR5JyxcbiAgICAgICAgJ251bWJlci5pbnRlZ2VyJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgICAgJ251bWJlci5sZXNzJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBsZXNzIHRoYW4ge3sjbGltaXR9fScsXG4gICAgICAgICdudW1iZXIubWF4JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fScsXG4gICAgICAgICdudW1iZXIubWluJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fScsXG4gICAgICAgICdudW1iZXIubXVsdGlwbGUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgbXVsdGlwbGUgb2Yge3sjbXVsdGlwbGV9fScsXG4gICAgICAgICdudW1iZXIubmVnYXRpdmUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgbmVnYXRpdmUgbnVtYmVyJyxcbiAgICAgICAgJ251bWJlci5wb3J0JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIHBvcnQnLFxuICAgICAgICAnbnVtYmVyLnBvc2l0aXZlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicsXG4gICAgICAgICdudW1iZXIucHJlY2lzaW9uJzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIG5vIG1vcmUgdGhhbiB7eyNsaW1pdH19IGRlY2ltYWwgcGxhY2VzJyxcbiAgICAgICAgJ251bWJlci51bnNhZmUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgc2FmZSBudW1iZXInXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMubm9ybWFsaXplRXhwb25lbnQgPSBmdW5jdGlvbiAoc3RyKSB7XG5cbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC5yZXBsYWNlKC9FLywgJ2UnKVxuICAgICAgICAucmVwbGFjZSgvXFwuKFxcZCpbMS05XSk/MCtlLywgJy4kMWUnKVxuICAgICAgICAucmVwbGFjZSgvXFwuZS8sICdlJylcbiAgICAgICAgLnJlcGxhY2UoL2VcXCsvLCAnZScpXG4gICAgICAgIC5yZXBsYWNlKC9eXFwrLywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9eKC0/KTArKFsxLTldKS8sICckMSQyJyk7XG59O1xuXG5cbmludGVybmFscy5ub3JtYWxpemVEZWNpbWFsID0gZnVuY3Rpb24gKHN0cikge1xuXG4gICAgc3RyID0gc3RyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHBsdXMgc2lnbnNcbiAgICAgICAgLnJlcGxhY2UoL15cXCsvLCAnJylcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zIGlmIHRoZXJlIGlzIGEgZGVjaW1hbCBwb2ludCBhbmQgdW5lY2Vzc2FyeSBkZWNpbWFsIHBvaW50c1xuICAgICAgICAucmVwbGFjZSgvXFwuMCokLywgJycpXG4gICAgICAgIC8vIEFkZCBhIGludGVnZXIgMCBpZiB0aGUgbnVtYmVycyBzdGFydHMgd2l0aCBhIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgLnJlcGxhY2UoL14oLT8pXFwuKFteXFwuXSopJC8sICckMTAuJDInKVxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvc1xuICAgICAgICAucmVwbGFjZSgvXigtPykwKyhbMC05XSkvLCAnJDEkMicpO1xuXG4gICAgaWYgKHN0ci5pbmNsdWRlcygnLicpICYmXG4gICAgICAgIHN0ci5lbmRzV2l0aCgnMCcpKSB7XG5cbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLzArJC8sICcnKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyID09PSAnLTAnKSB7XG4gICAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleXMuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdvYmplY3QnLFxuXG4gICAgY2FzdDoge1xuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgIGZyb206ICh2YWx1ZSkgPT4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hcChPYmplY3QuZW50cmllcyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRG9tYWluID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvZG9tYWluJyk7XG5jb25zdCBFbWFpbCA9IHJlcXVpcmUoJ0BzaWRld2F5L2FkZHJlc3MvbGliL2VtYWlsJyk7XG5jb25zdCBJcCA9IHJlcXVpcmUoJ0BzaWRld2F5L2FkZHJlc3MvbGliL2lwJyk7XG5jb25zdCBFc2NhcGVSZWdleCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2VzY2FwZVJlZ2V4Jyk7XG5jb25zdCBUbGRzID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvdGxkcycpO1xuY29uc3QgVXJpID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvdXJpJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgdGxkczogVGxkcyBpbnN0YW5jZW9mIFNldCA/IHsgdGxkczogeyBhbGxvdzogVGxkcywgZGVueTogbnVsbCB9IH0gOiBmYWxzZSwgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIGJhc2U2NFJlZ2V4OiB7XG4gICAgICAgIC8vIHBhZGRpbmdSZXF1aXJlZFxuICAgICAgICB0cnVlOiB7XG4gICAgICAgICAgICAvLyB1cmxTYWZlXG4gICAgICAgICAgICB0cnVlOiAvXig/OltcXHdcXC1dezJ9W1xcd1xcLV17Mn0pKig/OltcXHdcXC1dezJ9PT18W1xcd1xcLV17M309KT8kLyxcbiAgICAgICAgICAgIGZhbHNlOiAvXig/OltBLVphLXowLTkrXFwvXXsyfVtBLVphLXowLTkrXFwvXXsyfSkqKD86W0EtWmEtejAtOStcXC9dezJ9PT18W0EtWmEtejAtOStcXC9dezN9PSk/JC9cbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2U6IHtcbiAgICAgICAgICAgIHRydWU6IC9eKD86W1xcd1xcLV17Mn1bXFx3XFwtXXsyfSkqKD86W1xcd1xcLV17Mn0oPT0pP3xbXFx3XFwtXXszfT0/KT8kLyxcbiAgICAgICAgICAgIGZhbHNlOiAvXig/OltBLVphLXowLTkrXFwvXXsyfVtBLVphLXowLTkrXFwvXXsyfSkqKD86W0EtWmEtejAtOStcXC9dezJ9KD09KT98W0EtWmEtejAtOStcXC9dezN9PT8pPyQvXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGFVcmlSZWdleDogL15kYXRhOltcXHcrLi1dK1xcL1tcXHcrLi1dKzsoKGNoYXJzZXQ9W1xcdy1dK3xiYXNlNjQpLCk/KC4qKSQvLFxuICAgIGhleFJlZ2V4OiAvXlthLWYwLTldKyQvaSxcbiAgICBpcFJlZ2V4OiBJcC5yZWdleCh7IGNpZHI6ICdmb3JiaWRkZW4nIH0pLnJlZ2V4LFxuICAgIGlzb0R1cmF0aW9uUmVnZXg6IC9eUCg/ISQpKFxcZCtZKT8oXFxkK00pPyhcXGQrVyk/KFxcZCtEKT8oVCg/PVxcZCkoXFxkK0gpPyhcXGQrTSk/KFxcZCtTKT8pPyQvLFxuXG4gICAgZ3VpZEJyYWNrZXRzOiB7XG4gICAgICAgICd7JzogJ30nLCAnWyc6ICddJywgJygnOiAnKScsICcnOiAnJ1xuICAgIH0sXG4gICAgZ3VpZFZlcnNpb25zOiB7XG4gICAgICAgIHV1aWR2MTogJzEnLFxuICAgICAgICB1dWlkdjI6ICcyJyxcbiAgICAgICAgdXVpZHYzOiAnMycsXG4gICAgICAgIHV1aWR2NDogJzQnLFxuICAgICAgICB1dWlkdjU6ICc1J1xuICAgIH0sXG4gICAgZ3VpZFNlcGFyYXRvcnM6IG5ldyBTZXQoW3VuZGVmaW5lZCwgdHJ1ZSwgZmFsc2UsICctJywgJzonXSksXG5cbiAgICBub3JtYWxpemF0aW9uRm9ybXM6IFsnTkZDJywgJ05GRCcsICdORktDJywgJ05GS0QnXVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ3N0cmluZycsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIGluc2Vuc2l0aXZlOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgIHRydW5jYXRlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICByZXBsYWNlbWVudHM6IHsgaW5pdDogbnVsbCB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiAnc3RyaW5nJyxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplID0gc2NoZW1hLiRfZ2V0UnVsZSgnbm9ybWFsaXplJyk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5ub3JtYWxpemUobm9ybWFsaXplLmFyZ3MuZm9ybSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNhc2luZyA9IHNjaGVtYS4kX2dldFJ1bGUoJ2Nhc2UnKTtcbiAgICAgICAgICAgIGlmIChjYXNpbmcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhc2luZy5hcmdzLmRpcmVjdGlvbiA9PT0gJ3VwcGVyJyA/IHZhbHVlLnRvTG9jYWxlVXBwZXJDYXNlKCkgOiB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0cmltID0gc2NoZW1hLiRfZ2V0UnVsZSgndHJpbScpO1xuICAgICAgICAgICAgaWYgKHRyaW0gJiZcbiAgICAgICAgICAgICAgICB0cmltLmFyZ3MuZW5hYmxlZCkge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlcGxhY2VtZW50IG9mIHNjaGVtYS4kX3Rlcm1zLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVwbGFjZW1lbnQucGF0dGVybiwgcmVwbGFjZW1lbnQucmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaGV4ID0gc2NoZW1hLiRfZ2V0UnVsZSgnaGV4Jyk7XG4gICAgICAgICAgICBpZiAoaGV4ICYmXG4gICAgICAgICAgICAgICAgaGV4LmFyZ3Mub3B0aW9ucy5ieXRlQWxpZ25lZCAmJlxuICAgICAgICAgICAgICAgIHZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gYDAke3ZhbHVlfWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuJF9nZXRSdWxlKCdpc29EYXRlJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc28gPSBpbnRlcm5hbHMuaXNvRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzbykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGlzbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLnRydW5jYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IHNjaGVtYS4kX2dldFJ1bGUoJ21heCcpO1xuICAgICAgICAgICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW1pdCA9IHJ1bGUuYXJncy5saW1pdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUobGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdCA9IGxpbWl0LnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUNvbW1vbi5saW1pdChsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LnJlZicsIGxpbWl0LCB7IHJlZjogcnVsZS5hcmdzLmxpbWl0LCBhcmc6ICdsaW1pdCcsIHJlYXNvbjogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyB9LCBzdGF0ZSwgcHJlZnMpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzdHJpbmcuYmFzZScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBtaW4gPSBzY2hlbWEuJF9nZXRSdWxlKCdtaW4nKTtcbiAgICAgICAgICAgIGlmIChtaW4gJiZcbiAgICAgICAgICAgICAgICBtaW4uYXJncy5saW1pdCA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3RyaW5nLmVtcHR5JykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGFscGhhbnVtOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2FscGhhbnVtJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICgvXlthLXpBLVowLTldKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmFscGhhbnVtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmFzZTY0OiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3BhZGRpbmdSZXF1aXJlZCcsICd1cmxTYWZlJ10pO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgdXJsU2FmZTogZmFsc2UsIHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSwgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09ICdib29sZWFuJywgJ3BhZGRpbmdSZXF1aXJlZCBtdXN0IGJlIGJvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMudXJsU2FmZSA9PT0gJ2Jvb2xlYW4nLCAndXJsU2FmZSBtdXN0IGJlIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdiYXNlNjQnLCBhcmdzOiB7IG9wdGlvbnMgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gaW50ZXJuYWxzLmJhc2U2NFJlZ2V4W29wdGlvbnMucGFkZGluZ1JlcXVpcmVkXVtvcHRpb25zLnVybFNhZmVdO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5iYXNlNjQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjYXNlOiB7XG4gICAgICAgICAgICBtZXRob2QoZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydsb3dlcicsICd1cHBlciddLmluY2x1ZGVzKGRpcmVjdGlvbiksICdJbnZhbGlkIGNhc2U6JywgZGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdjYXNlJywgYXJnczogeyBkaXJlY3Rpb24gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBkaXJlY3Rpb24gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2xvd2VyJyAmJiB2YWx1ZSA9PT0gdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09ICd1cHBlcicgJiYgdmFsdWUgPT09IHZhbHVlLnRvTG9jYWxlVXBwZXJDYXNlKCkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoYHN0cmluZy4ke2RpcmVjdGlvbn1jYXNlYCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWRpdENhcmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnY3JlZGl0Q2FyZCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgaSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgbXVsID0gMTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhciA9IHZhbHVlLmNoYXJBdChpKSAqIG11bDtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgKGNoYXIgLSAoY2hhciA+IDkpICogOSk7XG4gICAgICAgICAgICAgICAgICAgIG11bCA9IG11bCBeIDM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN1bSA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgc3VtICUgMTAgPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5jcmVkaXRDYXJkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YVVyaToge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydwYWRkaW5nUmVxdWlyZWQnXSk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyBwYWRkaW5nUmVxdWlyZWQ6IHRydWUsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID09PSAnYm9vbGVhbicsICdwYWRkaW5nUmVxdWlyZWQgbXVzdCBiZSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZGF0YVVyaScsIGFyZ3M6IHsgb3B0aW9ucyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlLm1hdGNoKGludGVybmFscy5kYXRhVXJpUmVnZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1syXSAhPT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NHJlZ2V4ID0gaW50ZXJuYWxzLmJhc2U2NFJlZ2V4W29wdGlvbnMucGFkZGluZ1JlcXVpcmVkXS5mYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2U2NHJlZ2V4LnRlc3QobWF0Y2hlc1szXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZGF0YVVyaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxsb3dGdWxseVF1YWxpZmllZCcsICdhbGxvd1VuaWNvZGUnLCAnbWF4RG9tYWluU2VnbWVudHMnLCAnbWluRG9tYWluU2VnbWVudHMnLCAndGxkcyddKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdkb21haW4nLCBhcmdzOiB7IG9wdGlvbnMgfSwgYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgYXJncywgeyBhZGRyZXNzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChEb21haW4uaXNWYWxpZCh2YWx1ZSwgYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZG9tYWluJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW1haWw6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxsb3dGdWxseVF1YWxpZmllZCcsICdhbGxvd1VuaWNvZGUnLCAnaWdub3JlTGVuZ3RoJywgJ21heERvbWFpblNlZ21lbnRzJywgJ21pbkRvbWFpblNlZ21lbnRzJywgJ211bHRpcGxlJywgJ3NlcGFyYXRvcicsICd0bGRzJ10pO1xuICAgICAgICAgICAgICAgIEFzc2VydChvcHRpb25zLm11bHRpcGxlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMubXVsdGlwbGUgPT09ICdib29sZWFuJywgJ211bHRpcGxlIG9wdGlvbiBtdXN0IGJlIGFuIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBpbnRlcm5hbHMuYWRkcmVzc09wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBcXFxccypbJHtvcHRpb25zLnNlcGFyYXRvciA/IEVzY2FwZVJlZ2V4KG9wdGlvbnMuc2VwYXJhdG9yKSA6ICcsJ31dXFxcXHMqYCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZW1haWwnLCBhcmdzOiB7IG9wdGlvbnMgfSwgcmVnZXgsIGFkZHJlc3MgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9LCB7IHJlZ2V4LCBhZGRyZXNzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVtYWlscyA9IG9wdGlvbnMubXVsdGlwbGUgPyB2YWx1ZS5zcGxpdChyZWdleCkgOiBbdmFsdWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbWFpbCBvZiBlbWFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFFbWFpbC5pc1ZhbGlkKGVtYWlsLCBhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZHMucHVzaChlbWFpbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWludmFsaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5lbWFpbCcsIHsgdmFsdWUsIGludmFsaWRzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGd1aWQ6IHtcbiAgICAgICAgICAgIGFsaWFzOiAndXVpZCcsXG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3ZlcnNpb24nLCAnc2VwYXJhdG9yJ10pO1xuXG4gICAgICAgICAgICAgICAgbGV0IHZlcnNpb25OdW1iZXJzID0gJyc7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25zID0gW10uY29uY2F0KG9wdGlvbnMudmVyc2lvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZlcnNpb25zLmxlbmd0aCA+PSAxLCAndmVyc2lvbiBtdXN0IGhhdmUgYXQgbGVhc3QgMSB2YWxpZCB2ZXJzaW9uIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJzaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJywgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSBpbnRlcm5hbHMuZ3VpZFZlcnNpb25zW3ZlcnNpb24udG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQodmVyc2lvbk51bWJlciwgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyhpbnRlcm5hbHMuZ3VpZFZlcnNpb25zKS5qb2luKCcsICcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCghc2V0Lmhhcyh2ZXJzaW9uTnVtYmVyKSwgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3Qgbm90IGJlIGEgZHVwbGljYXRlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb25OdW1iZXJzICs9IHZlcnNpb25OdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQuYWRkKHZlcnNpb25OdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KGludGVybmFscy5ndWlkU2VwYXJhdG9ycy5oYXMob3B0aW9ucy5zZXBhcmF0b3IpLCAnc2VwYXJhdG9yIG11c3QgYmUgb25lIG9mIHRydWUsIGZhbHNlLCBcIi1cIiwgb3IgXCI6XCInKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJ1s6LV0/JyA6XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VwYXJhdG9yID09PSB0cnVlID8gJ1s6LV0nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VwYXJhdG9yID09PSBmYWxzZSA/ICdbXT8nIDogYFxcXFwke29wdGlvbnMuc2VwYXJhdG9yfWA7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4oW1xcXFxbe1xcXFwoXT8pWzAtOUEtRl17OH0oJHtzZXBhcmF0b3J9KVswLTlBLUZdezR9XFxcXDI/WyR7dmVyc2lvbk51bWJlcnMgfHwgJzAtOUEtRid9XVswLTlBLUZdezN9XFxcXDI/WyR7dmVyc2lvbk51bWJlcnMgPyAnODlBQicgOiAnMC05QS1GJ31dWzAtOUEtRl17M31cXFxcMj9bMC05QS1GXXsxMn0oW1xcXFxdfVxcXFwpXT8pJGAsICdpJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZ3VpZCcsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgYXJncywgeyByZWdleCB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gcmVnZXguZXhlYyh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5ndWlkJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hpbmcgYnJhY2VzXG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmd1aWRCcmFja2V0c1tyZXN1bHRzWzFdXSAhPT0gcmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZ3VpZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoZXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYnl0ZUFsaWduZWQnXSk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyBieXRlQWxpZ25lZDogZmFsc2UsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMuYnl0ZUFsaWduZWQgPT09ICdib29sZWFuJywgJ2J5dGVBbGlnbmVkIG11c3QgYmUgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2hleCcsIGFyZ3M6IHsgb3B0aW9ucyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuaGV4UmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5oZXgnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlQWxpZ25lZCAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5oZXhBbGlnbicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBob3N0bmFtZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdob3N0bmFtZScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoRG9tYWluLmlzVmFsaWQodmFsdWUsIHsgbWluRG9tYWluU2VnbWVudHM6IDEgfSkgfHxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmlwUmVnZXgudGVzdCh2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5ob3N0bmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGluc2Vuc2l0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2luc2Vuc2l0aXZlJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXA6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnY2lkcicsICd2ZXJzaW9uJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBjaWRyLCB2ZXJzaW9ucywgcmVnZXggfSA9IElwLnJlZ2V4KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBvcHRpb25zLnZlcnNpb24gPyB2ZXJzaW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaXAnLCBhcmdzOiB7IG9wdGlvbnM6IHsgY2lkciwgdmVyc2lvbiB9IH0sIHJlZ2V4IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSwgeyByZWdleCB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5pcFZlcnNpb24nLCB7IHZhbHVlLCBjaWRyOiBvcHRpb25zLmNpZHIsIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbiB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmlwJywgeyB2YWx1ZSwgY2lkcjogb3B0aW9ucy5jaWRyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzb0RhdGU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnaXNvRGF0ZScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuaXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignc3RyaW5nLmlzb0RhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc29EdXJhdGlvbjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdpc29EdXJhdGlvbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmlzb0R1cmF0aW9uUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaXNvRHVyYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCwgZW5jb2RpbmcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMubGVuZ3RoKHRoaXMsICdsZW5ndGgnLCBsaW1pdCwgJz0nLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQsIGVuY29kaW5nIH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZW5jb2RpbmcgPyBCdWZmZXIgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUsIGVuY29kaW5nKSA6IHZhbHVlLmxlbmd0aDsgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUobGVuZ3RoLCBsaW1pdCwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSwgZW5jb2RpbmcgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2VuY29kaW5nJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIGxvd2VyY2FzZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FzZSgnbG93ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCwgZW5jb2RpbmcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMubGVuZ3RoKHRoaXMsICdtYXgnLCBsaW1pdCwgJzw9JywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnbGltaXQnLCAnZW5jb2RpbmcnXVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ21pbicsIGxpbWl0LCAnPj0nLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydsaW1pdCcsICdlbmNvZGluZyddXG4gICAgICAgIH0sXG5cbiAgICAgICAgbm9ybWFsaXplOiB7XG4gICAgICAgICAgICBtZXRob2QoZm9ybSA9ICdORkMnKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoaW50ZXJuYWxzLm5vcm1hbGl6YXRpb25Gb3Jtcy5pbmNsdWRlcyhmb3JtKSwgJ25vcm1hbGl6YXRpb24gZm9ybSBtdXN0IGJlIG9uZSBvZiAnICsgaW50ZXJuYWxzLm5vcm1hbGl6YXRpb25Gb3Jtcy5qb2luKCcsICcpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdub3JtYWxpemUnLCBhcmdzOiB7IGZvcm0gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9LCB7IGZvcm0gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2YWx1ZS5ub3JtYWxpemUoZm9ybSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignc3RyaW5nLm5vcm1hbGl6ZScsIHsgdmFsdWUsIGZvcm0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHBhdHRlcm46IHtcbiAgICAgICAgICAgIGFsaWFzOiAncmVnZXgnLFxuICAgICAgICAgICAgbWV0aG9kKHJlZ2V4LCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChyZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCwgJ3JlZ2V4IG11c3QgYmUgYSBSZWdFeHAnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXJlZ2V4LmZsYWdzLmluY2x1ZGVzKCdnJykgJiYgIXJlZ2V4LmZsYWdzLmluY2x1ZGVzKCd5JyksICdyZWdleCBzaG91bGQgbm90IHVzZSBnbG9iYWwgb3Igc3RpY2t5IG1vZGUnKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgbmFtZTogb3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnaW52ZXJ0JywgJ25hbWUnXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBbJ3N0cmluZy5wYXR0ZXJuJywgb3B0aW9ucy5pbnZlcnQgPyAnLmludmVydCcgOiAnJywgb3B0aW9ucy5uYW1lID8gJy5uYW1lJyA6ICcuYmFzZSddLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdwYXR0ZXJuJywgYXJnczogeyByZWdleCwgb3B0aW9ucyB9LCBlcnJvckNvZGUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgcmVnZXgsIG9wdGlvbnMgfSwgeyBlcnJvckNvZGUgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybk1hdGNoID0gcmVnZXgudGVzdCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybk1hdGNoIF4gb3B0aW9ucy5pbnZlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKGVycm9yQ29kZSwgeyBuYW1lOiBvcHRpb25zLm5hbWUsIHJlZ2V4LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ3JlZ2V4JywgJ29wdGlvbnMnXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVwbGFjZToge1xuICAgICAgICAgICAgbWV0aG9kKHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKEVzY2FwZVJlZ2V4KHBhdHRlcm4pLCAnZycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwLCAncGF0dGVybiBtdXN0IGJlIGEgUmVnRXhwJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ3N0cmluZycsICdyZXBsYWNlbWVudCBtdXN0IGJlIGEgU3RyaW5nJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5yZXBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5yZXBsYWNlbWVudHMucHVzaCh7IHBhdHRlcm4sIHJlcGxhY2VtZW50IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9rZW46IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgndG9rZW4nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKC9eXFx3KyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnRva2VuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJpbToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICd0cmltJywgYXJnczogeyBlbmFibGVkIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgZW5hYmxlZCB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IHZhbHVlLnRyaW0oKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnRyaW0nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJ1bmNhdGU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBlbmFibGVkID09PSAnYm9vbGVhbicsICdlbmFibGVkIG11c3QgYmUgYSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3RydW5jYXRlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBwZXJjYXNlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYXNlKCd1cHBlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVyaToge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhbGxvd1JlbGF0aXZlJywgJ2FsbG93UXVlcnlTcXVhcmVCcmFja2V0cycsICdkb21haW4nLCAncmVsYXRpdmVPbmx5JywgJ3NjaGVtZSddKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLmRvbWFpbiwgWydhbGxvd0Z1bGx5UXVhbGlmaWVkJywgJ2FsbG93VW5pY29kZScsICdtYXhEb21haW5TZWdtZW50cycsICdtaW5Eb21haW5TZWdtZW50cycsICd0bGRzJ10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVnZXgsIHNjaGVtZSB9ID0gVXJpLnJlZ2V4KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluID8gaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zKG9wdGlvbnMuZG9tYWluKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3VyaScsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCwgZG9tYWluLCBzY2hlbWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9LCB7IHJlZ2V4LCBkb21haW4sIHNjaGVtZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoWydodHRwOi8nLCAnaHR0cHM6LyddLmluY2x1ZGVzKHZhbHVlKSkgeyAgICAgICAgICAgIC8vIHNjaGVtZTovIGlzIHRlY2huaWNhbGx5IHZhbGlkIGJ1dCBtYWtlcyBubyBzZW5zZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZWQgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFvcHRpb25zLmFsbG93UmVsYXRpdmUgfHwgbWF0Y2hlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEb21haW4uaXNWYWxpZChtYXRjaGVkLCBkb21haW4pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZG9tYWluJywgeyB2YWx1ZTogbWF0Y2hlZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZU9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmlSZWxhdGl2ZU9ubHknKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmlDdXN0b21TY2hlbWUnLCB7IHNjaGVtZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcGF0dGVybiwgcmVwbGFjZW1lbnQgfSBvZiBkZXNjLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdzdHJpbmcuYWxwaGFudW0nOiAne3sjbGFiZWx9fSBtdXN0IG9ubHkgY29udGFpbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMnLFxuICAgICAgICAnc3RyaW5nLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgc3RyaW5nJyxcbiAgICAgICAgJ3N0cmluZy5iYXNlNjQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgYmFzZTY0IHN0cmluZycsXG4gICAgICAgICdzdHJpbmcuY3JlZGl0Q2FyZCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBjcmVkaXQgY2FyZCcsXG4gICAgICAgICdzdHJpbmcuZGF0YVVyaSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBkYXRhVXJpIHN0cmluZycsXG4gICAgICAgICdzdHJpbmcuZG9tYWluJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGEgdmFsaWQgZG9tYWluIG5hbWUnLFxuICAgICAgICAnc3RyaW5nLmVtYWlsJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGVtYWlsJyxcbiAgICAgICAgJ3N0cmluZy5lbXB0eSc6ICd7eyNsYWJlbH19IGlzIG5vdCBhbGxvd2VkIHRvIGJlIGVtcHR5JyxcbiAgICAgICAgJ3N0cmluZy5ndWlkJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIEdVSUQnLFxuICAgICAgICAnc3RyaW5nLmhleCc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMnLFxuICAgICAgICAnc3RyaW5nLmhleEFsaWduJzogJ3t7I2xhYmVsfX0gaGV4IGRlY29kZWQgcmVwcmVzZW50YXRpb24gbXVzdCBiZSBieXRlIGFsaWduZWQnLFxuICAgICAgICAnc3RyaW5nLmhvc3RuYW1lJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGhvc3RuYW1lJyxcbiAgICAgICAgJ3N0cmluZy5pcCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBpcCBhZGRyZXNzIHdpdGggYSB7eyNjaWRyfX0gQ0lEUicsXG4gICAgICAgICdzdHJpbmcuaXBWZXJzaW9uJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGlwIGFkZHJlc3Mgb2Ygb25lIG9mIHRoZSBmb2xsb3dpbmcgdmVyc2lvbnMge3sjdmVyc2lvbn19IHdpdGggYSB7eyNjaWRyfX0gQ0lEUicsXG4gICAgICAgICdzdHJpbmcuaXNvRGF0ZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgaW4gaXNvIGZvcm1hdCcsXG4gICAgICAgICdzdHJpbmcuaXNvRHVyYXRpb24nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgSVNPIDg2MDEgZHVyYXRpb24nLFxuICAgICAgICAnc3RyaW5nLmxlbmd0aCc6ICd7eyNsYWJlbH19IGxlbmd0aCBtdXN0IGJlIHt7I2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgJ3N0cmluZy5sb3dlcmNhc2UnOiAne3sjbGFiZWx9fSBtdXN0IG9ubHkgY29udGFpbiBsb3dlcmNhc2UgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcubWF4JzogJ3t7I2xhYmVsfX0gbGVuZ3RoIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgJ3N0cmluZy5taW4nOiAne3sjbGFiZWx9fSBsZW5ndGggbXVzdCBiZSBhdCBsZWFzdCB7eyNsaW1pdH19IGNoYXJhY3RlcnMgbG9uZycsXG4gICAgICAgICdzdHJpbmcubm9ybWFsaXplJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSB1bmljb2RlIG5vcm1hbGl6ZWQgaW4gdGhlIHt7I2Zvcm19fSBmb3JtJyxcbiAgICAgICAgJ3N0cmluZy50b2tlbic6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGFscGhhLW51bWVyaWMgYW5kIHVuZGVyc2NvcmUgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5iYXNlJzogJ3t7I2xhYmVsfX0gd2l0aCB2YWx1ZSB7OlsuXX0gZmFpbHMgdG8gbWF0Y2ggdGhlIHJlcXVpcmVkIHBhdHRlcm46IHt7I3JlZ2V4fX0nLFxuICAgICAgICAnc3RyaW5nLnBhdHRlcm4ubmFtZSc6ICd7eyNsYWJlbH19IHdpdGggdmFsdWUgezpbLl19IGZhaWxzIHRvIG1hdGNoIHRoZSB7eyNuYW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5pbnZlcnQuYmFzZSc6ICd7eyNsYWJlbH19IHdpdGggdmFsdWUgezpbLl19IG1hdGNoZXMgdGhlIGludmVydGVkIHBhdHRlcm46IHt7I3JlZ2V4fX0nLFxuICAgICAgICAnc3RyaW5nLnBhdHRlcm4uaW52ZXJ0Lm5hbWUnOiAne3sjbGFiZWx9fSB3aXRoIHZhbHVlIHs6Wy5dfSBtYXRjaGVzIHRoZSBpbnZlcnRlZCB7eyNuYW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcudHJpbSc6ICd7eyNsYWJlbH19IG11c3Qgbm90IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlJyxcbiAgICAgICAgJ3N0cmluZy51cmknOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgdXJpJyxcbiAgICAgICAgJ3N0cmluZy51cmlDdXN0b21TY2hlbWUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgdXJpIHdpdGggYSBzY2hlbWUgbWF0Y2hpbmcgdGhlIHt7I3NjaGVtZX19IHBhdHRlcm4nLFxuICAgICAgICAnc3RyaW5nLnVyaVJlbGF0aXZlT25seSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCByZWxhdGl2ZSB1cmknLFxuICAgICAgICAnc3RyaW5nLnVwcGVyY2FzZSc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIHVwcGVyY2FzZSBjaGFyYWN0ZXJzJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvLyBtaW5Eb21haW5TZWdtZW50c1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzKSAmJiBvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzID4gMCwgJ21pbkRvbWFpblNlZ21lbnRzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAvLyBtYXhEb21haW5TZWdtZW50c1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRpb25zLm1heERvbWFpblNlZ21lbnRzKSAmJiBvcHRpb25zLm1heERvbWFpblNlZ21lbnRzID4gMCwgJ21heERvbWFpblNlZ21lbnRzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAvLyB0bGRzXG5cbiAgICBpZiAob3B0aW9ucy50bGRzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50bGRzID09PSB0cnVlIHx8XG4gICAgICAgIG9wdGlvbnMudGxkcyA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgQXNzZXJ0KGludGVybmFscy50bGRzLCAnQnVpbHQtaW4gVExEIGxpc3QgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIGludGVybmFscy50bGRzKTtcbiAgICB9XG5cbiAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMudGxkcyA9PT0gJ29iamVjdCcsICd0bGRzIG11c3QgYmUgdHJ1ZSwgZmFsc2UsIG9yIGFuIG9iamVjdCcpO1xuXG4gICAgY29uc3QgZGVueSA9IG9wdGlvbnMudGxkcy5kZW55O1xuICAgIGlmIChkZW55KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlbnkpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyB0bGRzOiB7IGRlbnk6IG5ldyBTZXQoZGVueSkgfSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydChvcHRpb25zLnRsZHMuZGVueSBpbnN0YW5jZW9mIFNldCwgJ3RsZHMuZGVueSBtdXN0IGJlIGFuIGFycmF5LCBTZXQsIG9yIGJvb2xlYW4nKTtcbiAgICAgICAgQXNzZXJ0KCFvcHRpb25zLnRsZHMuYWxsb3csICdDYW5ub3Qgc3BlY2lmeSBib3RoIHRsZHMuYWxsb3cgYW5kIHRsZHMuZGVueSBsaXN0cycpO1xuICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGVUbGRzKG9wdGlvbnMudGxkcy5kZW55LCAndGxkcy5kZW55Jyk7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbG93ID0gb3B0aW9ucy50bGRzLmFsbG93O1xuICAgIGlmICghYWxsb3cpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93ID09PSB0cnVlKSB7XG4gICAgICAgIEFzc2VydChpbnRlcm5hbHMudGxkcywgJ0J1aWx0LWluIFRMRCBsaXN0IGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBpbnRlcm5hbHMudGxkcyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWxsb3cpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHRsZHM6IHsgYWxsb3c6IG5ldyBTZXQoYWxsb3cpIH0gfSk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KG9wdGlvbnMudGxkcy5hbGxvdyBpbnN0YW5jZW9mIFNldCwgJ3RsZHMuYWxsb3cgbXVzdCBiZSBhbiBhcnJheSwgU2V0LCBvciBib29sZWFuJyk7XG4gICAgaW50ZXJuYWxzLnZhbGlkYXRlVGxkcyhvcHRpb25zLnRsZHMuYWxsb3csICd0bGRzLmFsbG93Jyk7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZVRsZHMgPSBmdW5jdGlvbiAoc2V0LCBzb3VyY2UpIHtcblxuICAgIGZvciAoY29uc3QgdGxkIG9mIHNldCkge1xuICAgICAgICBBc3NlcnQoRG9tYWluLmlzVmFsaWQodGxkLCB7IG1pbkRvbWFpblNlZ21lbnRzOiAxLCBtYXhEb21haW5TZWdtZW50czogMSB9KSwgYCR7c291cmNlfSBtdXN0IGNvbnRhaW4gdmFsaWQgdG9wIGxldmVsIGRvbWFpbiBuYW1lc2ApO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmlzb0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIGlmICghQ29tbW9uLmlzSXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKC8uKlQuKlsrLV1cXGRcXGQkLy50ZXN0KHZhbHVlKSkgeyAgICAgICAgICAgICAvLyBBZGQgbWlzc2luZyB0cmFpbGluZyB6ZXJvcyB0byB0aW1lc2hpZnRcbiAgICAgICAgdmFsdWUgKz0gJzAwJztcbiAgICB9XG5cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbn07XG5cblxuaW50ZXJuYWxzLmxlbmd0aCA9IGZ1bmN0aW9uIChzY2hlbWEsIG5hbWUsIGxpbWl0LCBvcGVyYXRvciwgZW5jb2RpbmcpIHtcblxuICAgIEFzc2VydCghZW5jb2RpbmcgfHwgQnVmZmVyICYmIEJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSwgJ0ludmFsaWQgZW5jb2Rpbmc6JywgZW5jb2RpbmcpOyAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuXG4gICAgcmV0dXJuIHNjaGVtYS4kX2FkZFJ1bGUoeyBuYW1lLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0LCBlbmNvZGluZyB9LCBvcGVyYXRvciB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5NYXAgPSBjbGFzcyBleHRlbmRzIE1hcCB7XG5cbiAgICBzbGljZSgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5NYXAodGhpcyk7XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ3N5bWJvbCcsXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIG1hcDogeyBpbml0OiBuZXcgaW50ZXJuYWxzLk1hcCgpIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yIH0pIHtcblxuICAgICAgICAgICAgY29uc3QgbG9va3VwID0gc2NoZW1hLiRfdGVybXMubWFwLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsb29rdXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy5vbmx5IHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ3N5bWJvbC5tYXAnLCB7IG1hcDogc2NoZW1hLiRfdGVybXMubWFwIH0pIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3ltYm9sLmJhc2UnKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG4gICAgICAgIG1hcDoge1xuICAgICAgICAgICAgbWV0aG9kKGl0ZXJhYmxlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlcmFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIWl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0gJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZXJhYmxlID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0LmVudHJpZXMoaXRlcmFibGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChpdGVyYWJsZSAmJiBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdLCAnSXRlcmFibGUgbXVzdCBiZSBhbiBpdGVyYWJsZSBvciBvYmplY3QnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChlbnRyeSAmJiBlbnRyeVtTeW1ib2wuaXRlcmF0b3JdLCAnRW50cnkgbXVzdCBiZSBhbiBpdGVyYWJsZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyeTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGtleSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGtleSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Yga2V5ICE9PSAnc3ltYm9sJywgJ0tleSBtdXN0IG5vdCBiZSBvZiB0eXBlIG9iamVjdCwgZnVuY3Rpb24sIG9yIFN5bWJvbCcpO1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJywgJ1ZhbHVlIG11c3QgYmUgYSBTeW1ib2wnKTtcblxuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5tYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmoudmFsaWQoLi4uc3ltYm9scyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MubWFwKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLm1hcChkZXNjLm1hcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ3N5bWJvbC5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHN5bWJvbCcsXG4gICAgICAgICdzeW1ib2wubWFwJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBvbmUgb2Yge3sjbWFwfX0nXG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgSWdub3JlID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvaWdub3JlJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgU3RhdGUgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHJlc3VsdDogU3ltYm9sKCdyZXN1bHQnKVxufTtcblxuXG5leHBvcnRzLmVudHJ5ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBsZXQgc2V0dGluZ3MgPSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKHByZWZzKSB7XG4gICAgICAgIEFzc2VydChwcmVmcy53YXJuaW5ncyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIHdhcm5pbmdzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBBc3NlcnQocHJlZnMuYXJ0aWZhY3RzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgYXJ0aWZhY3RzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBzZXR0aW5ncyA9IENvbW1vbi5wcmVmZXJlbmNlcyhDb21tb24uZGVmYXVsdHMsIHByZWZzKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuZW50cnkodmFsdWUsIHNjaGVtYSwgc2V0dGluZ3MpO1xuICAgIEFzc2VydCghcmVzdWx0Lm1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgsICdTY2hlbWEgd2l0aCBleHRlcm5hbCBydWxlcyBtdXN0IHVzZSB2YWxpZGF0ZUFzeW5jKCknKTtcbiAgICBjb25zdCBvdXRjb21lID0geyB2YWx1ZTogcmVzdWx0LnZhbHVlIH07XG5cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIG91dGNvbWUuZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS53YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgb3V0Y29tZS53YXJuaW5nID0gRXJyb3JzLmRldGFpbHMocmVzdWx0Lm1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lm1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgIG91dGNvbWUuZGVidWcgPSByZXN1bHQubWFpbnN0YXkuZGVidWc7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS5hcnRpZmFjdHMpIHtcbiAgICAgICAgb3V0Y29tZS5hcnRpZmFjdHMgPSByZXN1bHQubWFpbnN0YXkuYXJ0aWZhY3RzO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRjb21lO1xufTtcblxuXG5leHBvcnRzLmVudHJ5QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGxldCBzZXR0aW5ncyA9IENvbW1vbi5kZWZhdWx0cztcbiAgICBpZiAocHJlZnMpIHtcbiAgICAgICAgc2V0dGluZ3MgPSBDb21tb24ucHJlZmVyZW5jZXMoQ29tbW9uLmRlZmF1bHRzLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLmVudHJ5KHZhbHVlLCBzY2hlbWEsIHNldHRpbmdzKTtcbiAgICBjb25zdCBtYWluc3RheSA9IHJlc3VsdC5tYWluc3RheTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIGlmIChtYWluc3RheS5kZWJ1Zykge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJvb3QgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgeyBtZXRob2QsIHBhdGgsIGxhYmVsIH0gb2YgbWFpbnN0YXkuZXh0ZXJuYWxzKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHJvb3Q7XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgbGV0IHBhcmVudDtcblxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IFJlYWNoKHJvb3QsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50W2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgbWV0aG9kKG5vZGUsIHsgcHJlZnMgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9PT0gbm9kZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50W2tleV0gPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb290ID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZXJyb3JzLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlICs9IGAgKCR7bGFiZWx9KWA7ICAgICAgIC8vIENoYW5nZSBtZXNzYWdlIHRvIGluY2x1ZGUgcGF0aFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHJvb3Q7XG4gICAgfVxuXG4gICAgaWYgKCFzZXR0aW5ncy53YXJuaW5ncyAmJlxuICAgICAgICAhc2V0dGluZ3MuZGVidWcgJiZcbiAgICAgICAgIXNldHRpbmdzLmFydGlmYWN0cykge1xuXG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0Y29tZSA9IHsgdmFsdWU6IHJlc3VsdC52YWx1ZSB9O1xuICAgIGlmIChtYWluc3RheS53YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgb3V0Y29tZS53YXJuaW5nID0gRXJyb3JzLmRldGFpbHMobWFpbnN0YXkud2FybmluZ3MpO1xuICAgIH1cblxuICAgIGlmIChtYWluc3RheS5kZWJ1Zykge1xuICAgICAgICBvdXRjb21lLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgfVxuXG4gICAgaWYgKG1haW5zdGF5LmFydGlmYWN0cykge1xuICAgICAgICBvdXRjb21lLmFydGlmYWN0cyA9IG1haW5zdGF5LmFydGlmYWN0cztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Y29tZTtcbn07XG5cblxuaW50ZXJuYWxzLmVudHJ5ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICAvLyBQcmVwYXJlIHN0YXRlXG5cbiAgICBjb25zdCB7IHRyYWNlciwgY2xlYW51cCB9ID0gaW50ZXJuYWxzLnRyYWNlcihzY2hlbWEsIHByZWZzKTtcbiAgICBjb25zdCBkZWJ1ZyA9IHByZWZzLmRlYnVnID8gW10gOiBudWxsO1xuICAgIGNvbnN0IGxpbmtzID0gc2NoZW1hLl9pZHMuX3NjaGVtYUNoYWluID8gbmV3IE1hcCgpIDogbnVsbDtcbiAgICBjb25zdCBtYWluc3RheSA9IHsgZXh0ZXJuYWxzOiBbXSwgd2FybmluZ3M6IFtdLCB0cmFjZXIsIGRlYnVnLCBsaW5rcyB9O1xuICAgIGNvbnN0IHNjaGVtYXMgPSBzY2hlbWEuX2lkcy5fc2NoZW1hQ2hhaW4gPyBbeyBzY2hlbWEgfV0gOiBudWxsO1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKFtdLCBbXSwgeyBtYWluc3RheSwgc2NoZW1hcyB9KTtcblxuICAgIC8vIFZhbGlkYXRlIHZhbHVlXG5cbiAgICBjb25zdCByZXN1bHQgPSBleHBvcnRzLnZhbGlkYXRlKHZhbHVlLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICAvLyBQcm9jZXNzIHZhbHVlIGFuZCBlcnJvcnNcblxuICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgIHNjaGVtYS4kX3Jvb3QudW50cmFjZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yID0gRXJyb3JzLnByb2Nlc3MocmVzdWx0LmVycm9ycywgdmFsdWUsIHByZWZzKTtcbiAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LnZhbHVlLCBlcnJvciwgbWFpbnN0YXkgfTtcbn07XG5cblxuaW50ZXJuYWxzLnRyYWNlciA9IGZ1bmN0aW9uIChzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBpZiAoc2NoZW1hLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgIHJldHVybiB7IHRyYWNlcjogc2NoZW1hLiRfcm9vdC5fdHJhY2VyLl9yZWdpc3RlcihzY2hlbWEpIH07XG4gICAgfVxuXG4gICAgaWYgKHByZWZzLmRlYnVnKSB7XG4gICAgICAgIEFzc2VydChzY2hlbWEuJF9yb290LnRyYWNlLCAnRGVidWcgbW9kZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybiB7IHRyYWNlcjogc2NoZW1hLiRfcm9vdC50cmFjZSgpLl9yZWdpc3RlcihzY2hlbWEpLCBjbGVhbnVwOiB0cnVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHJhY2VyOiBpbnRlcm5hbHMuaWdub3JlIH07XG59O1xuXG5cbmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgc3RhdGUsIHByZWZzLCBvdmVycmlkZXMgPSB7fSkge1xuXG4gICAgaWYgKHNjaGVtYS4kX3Rlcm1zLndoZW5zKSB7XG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYS5fZ2VuZXJhdGUodmFsdWUsIHN0YXRlLCBwcmVmcykuc2NoZW1hO1xuICAgIH1cblxuICAgIC8vIFNldHVwIHN0YXRlIGFuZCBzZXR0aW5nc1xuXG4gICAgaWYgKHNjaGVtYS5fcHJlZmVyZW5jZXMpIHtcbiAgICAgICAgcHJlZnMgPSBpbnRlcm5hbHMucHJlZnMoc2NoZW1hLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGVcblxuICAgIGlmIChzY2hlbWEuX2NhY2hlICYmXG4gICAgICAgIHByZWZzLmNhY2hlKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9jYWNoZS5nZXQodmFsdWUpO1xuICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZGVidWcoc3RhdGUsICd2YWxpZGF0ZScsICdjYWNoZWQnLCAhIXJlc3VsdCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIZWxwZXJzXG5cbiAgICBjb25zdCBjcmVhdGVFcnJvciA9IChjb2RlLCBsb2NhbCwgbG9jYWxTdGF0ZSkgPT4gc2NoZW1hLiRfY3JlYXRlRXJyb3IoY29kZSwgdmFsdWUsIGxvY2FsLCBsb2NhbFN0YXRlIHx8IHN0YXRlLCBwcmVmcyk7XG4gICAgY29uc3QgaGVscGVycyA9IHtcbiAgICAgICAgb3JpZ2luYWw6IHZhbHVlLFxuICAgICAgICBwcmVmcyxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yLFxuICAgICAgICBlcnJvcnNBcnJheTogaW50ZXJuYWxzLmVycm9yc0FycmF5LFxuICAgICAgICB3YXJuOiAoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpID0+IHN0YXRlLm1haW5zdGF5Lndhcm5pbmdzLnB1c2goY3JlYXRlRXJyb3IoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpKSxcbiAgICAgICAgbWVzc2FnZTogKG1lc3NhZ2VzLCBsb2NhbCkgPT4gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2N1c3RvbScsIHZhbHVlLCBsb2NhbCwgc3RhdGUsIHByZWZzLCB7IG1lc3NhZ2VzIH0pXG4gICAgfTtcblxuICAgIC8vIFByZXBhcmVcblxuICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5lbnRyeShzY2hlbWEsIHN0YXRlKTtcblxuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmaW5pdGlvbjtcbiAgICBpZiAoZGVmLnByZXBhcmUgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcmVmcy5jb252ZXJ0KSB7XG5cbiAgICAgICAgY29uc3QgcHJlcGFyZWQgPSBkZWYucHJlcGFyZSh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChwcmVwYXJlZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAncHJlcGFyZScsIHZhbHVlLCBwcmVwYXJlZC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZShwcmVwYXJlZC52YWx1ZSwgW10uY29uY2F0KHByZXBhcmVkLmVycm9ycyksIGhlbHBlcnMpOyAgICAgICAgIC8vIFByZXBhcmUgZXJyb3IgYWx3YXlzIGFib3J0cyBlYXJseVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHByZXBhcmVkLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHlwZSBjb2VyY2lvblxuXG4gICAgaWYgKGRlZi5jb2VyY2UgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcmVmcy5jb252ZXJ0ICYmXG4gICAgICAgICghZGVmLmNvZXJjZS5mcm9tIHx8IGRlZi5jb2VyY2UuZnJvbS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSkge1xuXG4gICAgICAgIGNvbnN0IGNvZXJjZWQgPSBkZWYuY29lcmNlLm1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChjb2VyY2VkKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdjb2VyY2VkJywgdmFsdWUsIGNvZXJjZWQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvZXJjZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZShjb2VyY2VkLnZhbHVlLCBbXS5jb25jYXQoY29lcmNlZC5lcnJvcnMpLCBoZWxwZXJzKTsgICAgICAgICAgIC8vIENvZXJjZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtcHR5IHZhbHVlXG5cbiAgICBjb25zdCBlbXB0eSA9IHNjaGVtYS5fZmxhZ3MuZW1wdHk7XG4gICAgaWYgKGVtcHR5ICYmXG4gICAgICAgIGVtcHR5LiRfbWF0Y2goaW50ZXJuYWxzLnRyaW0odmFsdWUsIHNjaGVtYSksIHN0YXRlLm5lc3QoZW1wdHkpLCBDb21tb24uZGVmYXVsdHMpKSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZW1wdHknLCB2YWx1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gUHJlc2VuY2UgcmVxdWlyZW1lbnRzIChyZXF1aXJlZCwgb3B0aW9uYWwsIGZvcmJpZGRlbilcblxuICAgIGNvbnN0IHByZXNlbmNlID0gb3ZlcnJpZGVzLnByZXNlbmNlIHx8IHNjaGVtYS5fZmxhZ3MucHJlc2VuY2UgfHwgKHNjaGVtYS5fZmxhZ3MuX2VuZGVkU3dpdGNoID8gbnVsbCA6IHByZWZzLnByZXNlbmNlKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgW3NjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkucmVxdWlyZWQnLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbmNlID09PSAnb3B0aW9uYWwnKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy5kZWZhdWx0ICE9PSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIG51bGwsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdkZWZhdWx0JywgdmFsdWUsIHt9KTtcbiAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LnVua25vd24nLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgIH1cblxuICAgIC8vIEFsbG93ZWQgdmFsdWVzXG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGlmIChzY2hlbWEuX3ZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5fdmFsaWRzLmdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBzY2hlbWEuX2ZsYWdzLmluc2Vuc2l0aXZlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAocHJlZnMuY29udmVydCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ3ZhbGlkcycsIHZhbHVlLCBtYXRjaC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmZpbHRlcihzY2hlbWEsIHN0YXRlLCAndmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm9ubHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkub25seScsIHZhbHVlLCB7IHZhbGlkczogc2NoZW1hLl92YWxpZHMudmFsdWVzKHsgZGlzcGxheTogdHJ1ZSB9KSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBbcmVwb3J0XSwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZW5pZWQgdmFsdWVzXG5cbiAgICBpZiAoc2NoZW1hLl9pbnZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5faW52YWxpZHMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYS5fZmxhZ3MuaW5zZW5zaXRpdmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5maWx0ZXIoc2NoZW1hLCBzdGF0ZSwgJ2ludmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LmludmFsaWQnLCB2YWx1ZSwgeyBpbnZhbGlkczogc2NoZW1hLl9pbnZhbGlkcy52YWx1ZXMoeyBkaXNwbGF5OiB0cnVlIH0pIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtyZXBvcnRdLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJhc2UgdHlwZVxuXG4gICAgaWYgKGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBjb25zdCBiYXNlID0gZGVmLnZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Jhc2UnLCB2YWx1ZSwgYmFzZS52YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2UudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChiYXNlLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiYXNlLmVycm9ycykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goYmFzZS5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpOyAgICAgICAgICAvLyBCYXNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLmJhc2UuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTsgICAgICAgICAgLy8gQmFzZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGVzdHNcblxuICAgIGlmICghc2NoZW1hLl9ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnJ1bGVzKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xufTtcblxuXG5pbnRlcm5hbHMucnVsZXMgPSBmdW5jdGlvbiAodmFsdWUsIGVycm9ycywgaGVscGVycykge1xuXG4gICAgY29uc3QgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBzY2hlbWEuX3J1bGVzKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBzY2hlbWEuX2RlZmluaXRpb24ucnVsZXNbcnVsZS5tZXRob2RdO1xuXG4gICAgICAgIC8vIFNraXAgcnVsZXMgdGhhdCBhcmUgYWxzbyBhcHBsaWVkIGluIGNvZXJjZSBzdGVwXG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24uY29udmVydCAmJlxuICAgICAgICAgICAgcHJlZnMuY29udmVydCkge1xuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIubG9nKHNjaGVtYSwgc3RhdGUsICdydWxlJywgcnVsZS5uYW1lLCAnZnVsbCcpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNvbHZlIHJlZmVyZW5jZXNcblxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICBsZXQgYXJncyA9IHJ1bGUuYXJncztcbiAgICAgICAgaWYgKHJ1bGUuX3Jlc29sdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcmdzID0gT2JqZWN0LmFzc2lnbih7fSwgYXJncyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWxsb3cgY29weVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcnVsZS5fcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZGVmaW5pdGlvbi5hcmdzQnlOYW1lLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhcmdzW2tleV0ucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gcmVzb2x2ZXIubm9ybWFsaXplID8gcmVzb2x2ZXIubm9ybWFsaXplKHJlc29sdmVkKSA6IHJlc29sdmVkO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZCA9IENvbW1vbi52YWxpZGF0ZUFyZyhub3JtYWxpemVkLCBudWxsLCByZXNvbHZlcik7XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5yZWYnLCByZXNvbHZlZCwgeyBhcmc6IGtleSwgcmVmOiBhcmdzW2tleV0sIHJlYXNvbjogaW52YWxpZCB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzW2tleV0gPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCBydWxlXG5cbiAgICAgICAgcmV0ID0gcmV0IHx8IGRlZmluaXRpb24udmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHJ1bGUpOyAgICAgICAgICAgLy8gVXNlIHJldCBpZiBhbHJlYWR5IHNldCB0byByZWZlcmVuY2UgZXJyb3JcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMucnVsZShyZXQsIHJ1bGUpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIHJ1bGUubmFtZSwgJ2Vycm9yJyk7XG5cbiAgICAgICAgICAgIGlmIChydWxlLndhcm4pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYWluc3RheS53YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIHJlc3VsdC5lcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5sb2coc2NoZW1hLCBzdGF0ZSwgJ3J1bGUnLCBydWxlLm5hbWUsICdwYXNzJyk7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdydWxlJywgdmFsdWUsIHJlc3VsdC52YWx1ZSwgcnVsZS5uYW1lKTtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbn07XG5cblxuaW50ZXJuYWxzLnJ1bGUgPSBmdW5jdGlvbiAocmV0LCBydWxlKSB7XG5cbiAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCkge1xuICAgICAgICBpbnRlcm5hbHMuZXJyb3IocmV0LCBydWxlKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBbcmV0XSwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXQpICYmXG4gICAgICAgIHJldFtDb21tb24uc3ltYm9scy5lcnJvcnNdKSB7XG5cbiAgICAgICAgcmV0LmZvckVhY2goKHJlcG9ydCkgPT4gaW50ZXJuYWxzLmVycm9yKHJlcG9ydCwgcnVsZSkpO1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IHJldCwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcnM6IG51bGwsIHZhbHVlOiByZXQgfTtcbn07XG5cblxuaW50ZXJuYWxzLmVycm9yID0gZnVuY3Rpb24gKHJlcG9ydCwgcnVsZSkge1xuXG4gICAgaWYgKHJ1bGUubWVzc2FnZSkge1xuICAgICAgICByZXBvcnQuX3NldFRlbXBsYXRlKHJ1bGUubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcG9ydDtcbn07XG5cblxuaW50ZXJuYWxzLmZpbmFsaXplID0gZnVuY3Rpb24gKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpIHtcblxuICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuXG4gICAgLy8gRmFpbG92ZXIgdmFsdWVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZhaWxvdmVyID0gaW50ZXJuYWxzLmRlZmF1bHQoJ2ZhaWxvdmVyJywgdW5kZWZpbmVkLCBlcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICBpZiAoZmFpbG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZmFpbG92ZXInLCB2YWx1ZSwgZmFpbG92ZXIpO1xuICAgICAgICAgICAgdmFsdWUgPSBmYWlsb3ZlcjtcbiAgICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXJyb3Igb3ZlcnJpZGVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoICYmXG4gICAgICAgIHNjaGVtYS5fZmxhZ3MuZXJyb3IpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5fZmxhZ3MuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9ycyA9IHNjaGVtYS5fZmxhZ3MuZXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gW2Vycm9yc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3Igb2YgZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcnMuUmVwb3J0LCAnZXJyb3IoKSBtdXN0IHJldHVybiBhbiBFcnJvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IFtzY2hlbWEuX2ZsYWdzLmVycm9yXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHRcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRlZCA9IGludGVybmFscy5kZWZhdWx0KCdkZWZhdWx0JywgdmFsdWUsIGVycm9ycywgaGVscGVycyk7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2RlZmF1bHQnLCB2YWx1ZSwgZGVmYXVsdGVkKTtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0ZWQ7XG4gICAgfVxuXG4gICAgLy8gQ2FzdFxuXG4gICAgaWYgKHNjaGVtYS5fZmxhZ3MuY2FzdCAmJlxuICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgY29uc3QgY2FzdGVyID0gc2NoZW1hLl9kZWZpbml0aW9uLmNhc3Rbc2NoZW1hLl9mbGFncy5jYXN0XTtcbiAgICAgICAgaWYgKGNhc3Rlci5mcm9tKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgY2FzdGVkID0gY2FzdGVyLnRvKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Nhc3QnLCB2YWx1ZSwgY2FzdGVkLCBzY2hlbWEuX2ZsYWdzLmNhc3QpO1xuICAgICAgICAgICAgdmFsdWUgPSBjYXN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHRlcm5hbHNcblxuICAgIGlmIChzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMgJiZcbiAgICAgICAgcHJlZnMuZXh0ZXJuYWxzICYmXG4gICAgICAgIHByZWZzLl9leHRlcm5hbHMgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlZCBmb3IgbWF0Y2hpbmdcblxuICAgICAgICBmb3IgKGNvbnN0IHsgbWV0aG9kIH0gb2Ygc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5leHRlcm5hbHMucHVzaCh7IG1ldGhvZCwgcGF0aDogc3RhdGUucGF0aCwgbGFiZWw6IEVycm9ycy5sYWJlbChzY2hlbWEuX2ZsYWdzLCBzdGF0ZSwgcHJlZnMpIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzdWx0XG5cbiAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlLCBlcnJvcnM6IGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiBudWxsIH07XG5cbiAgICBpZiAoc2NoZW1hLl9mbGFncy5yZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gc2NoZW1hLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcgPyB1bmRlZmluZWQgOiAvKiByYXcgKi8gaGVscGVycy5vcmlnaW5hbDtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCBzY2hlbWEuX2ZsYWdzLnJlc3VsdCwgdmFsdWUsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIHN0YXRlLnNoYWRvdyh2YWx1ZSwgc2NoZW1hLl9mbGFncy5yZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIENhY2hlXG5cbiAgICBpZiAoc2NoZW1hLl9jYWNoZSAmJlxuICAgICAgICBwcmVmcy5jYWNoZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgIXNjaGVtYS5fcmVmcy5sZW5ndGgpIHtcblxuICAgICAgICBzY2hlbWEuX2NhY2hlLnNldChoZWxwZXJzLm9yaWdpbmFsLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIEFydGlmYWN0c1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXJlc3VsdC5lcnJvcnMgJiZcbiAgICAgICAgc2NoZW1hLl9mbGFncy5hcnRpZmFjdCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzID0gc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMuaGFzKHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QpKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMuc2V0KHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmFydGlmYWN0cy5nZXQoc2NoZW1hLl9mbGFncy5hcnRpZmFjdCkucHVzaChzdGF0ZS5wYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5pbnRlcm5hbHMucHJlZnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBwcmVmcykge1xuXG4gICAgY29uc3QgaXNEZWZhdWx0T3B0aW9ucyA9IHByZWZzID09PSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKGlzRGVmYXVsdE9wdGlvbnMgJiZcbiAgICAgICAgc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc10pIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc107XG4gICAgfVxuXG4gICAgcHJlZnMgPSBDb21tb24ucHJlZmVyZW5jZXMocHJlZnMsIHNjaGVtYS5fcHJlZmVyZW5jZXMpO1xuICAgIGlmIChpc0RlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHNjaGVtYS5fcHJlZmVyZW5jZXNbQ29tbW9uLnN5bWJvbHMucHJlZnNdID0gcHJlZnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZzO1xufTtcblxuXG5pbnRlcm5hbHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbGFnLCB2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKSB7XG5cbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuICAgIGNvbnN0IHNvdXJjZSA9IHNjaGVtYS5fZmxhZ3NbZmxhZ107XG4gICAgaWYgKHByZWZzLm5vRGVmYXVsdHMgfHxcbiAgICAgICAgc291cmNlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIGZsYWcsICdmdWxsJyk7XG5cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBzb3VyY2UubGVuZ3RoID8gW0Nsb25lKHN0YXRlLmFuY2VzdG9yc1swXSksIGhlbHBlcnNdIDogW107XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoYGFueS4ke2ZsYWd9YCwgbnVsbCwgeyBlcnJvcjogZXJyIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZVtDb21tb24uc3ltYm9scy5saXRlcmFsXSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpdGVyYWw7XG4gICAgfVxuXG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUoc291cmNlKSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIENsb25lKHNvdXJjZSk7XG59O1xuXG5cbmludGVybmFscy50cmltID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEpIHtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmltID0gc2NoZW1hLiRfZ2V0UnVsZSgndHJpbScpO1xuICAgIGlmICghdHJpbSB8fFxuICAgICAgICAhdHJpbS5hcmdzLmVuYWJsZWQpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbn07XG5cblxuaW50ZXJuYWxzLmlnbm9yZSA9IHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRlYnVnOiBJZ25vcmUsXG4gICAgZW50cnk6IElnbm9yZSxcbiAgICBmaWx0ZXI6IElnbm9yZSxcbiAgICBsb2c6IElnbm9yZSxcbiAgICByZXNvbHZlOiBJZ25vcmUsXG4gICAgdmFsdWU6IElnbm9yZVxufTtcblxuXG5pbnRlcm5hbHMuZXJyb3JzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBlcnJvcnNbQ29tbW9uLnN5bWJvbHMuZXJyb3JzXSA9IHRydWU7XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuVmFsdWVzID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IodmFsdWVzLCByZWZzKSB7XG5cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gbmV3IFNldCh2YWx1ZXMpO1xuICAgICAgICB0aGlzLl9yZWZzID0gbmV3IFNldChyZWZzKTtcbiAgICAgICAgdGhpcy5fbG93ZXJjYXNlID0gaW50ZXJuYWxzLmxvd2VyY2FzZXModmFsdWVzKTtcblxuICAgICAgICB0aGlzLl9vdmVycmlkZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5zaXplICsgdGhpcy5fcmVmcy5zaXplO1xuICAgIH1cblxuICAgIGFkZCh2YWx1ZSwgcmVmcykge1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZVxuXG4gICAgICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWZzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWZzLmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVmcykgeyAgICAgICAgICAgICAgICAgICAgIC8vIFNraXBwZWQgaW4gYSBtZXJnZVxuICAgICAgICAgICAgICAgICAgICByZWZzLnJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbHVlXG5cbiAgICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMuYWRkKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb3dlcmNhc2Uuc2V0KHZhbHVlLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgcmVtb3ZlKSB7XG5cbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBpbnRlcm5hbHMuVmFsdWVzKCk7XG5cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLmNsb25lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBbLi4uc291cmNlLl92YWx1ZXMsIC4uLnNvdXJjZS5fcmVmc10pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFsuLi5yZW1vdmUuX3ZhbHVlcywgLi4ucmVtb3ZlLl9yZWZzXSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmUoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0Lmxlbmd0aCA/IHRhcmdldCA6IG51bGw7XG4gICAgfVxuXG4gICAgcmVtb3ZlKHZhbHVlKSB7XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlXG5cbiAgICAgICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWx1ZVxuXG4gICAgICAgIHRoaXMuX3ZhbHVlcy5kZWxldGUodmFsdWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9sb3dlcmNhc2UuZGVsZXRlKHZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGluc2Vuc2l0aXZlKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXQodmFsdWUsIHN0YXRlLCBwcmVmcywgaW5zZW5zaXRpdmUpO1xuICAgIH1cblxuICAgIGdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbXBsZSBtYXRjaFxuXG4gICAgICAgIGlmICh0aGlzLl92YWx1ZXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhc2UgaW5zZW5zaXRpdmUgc3RyaW5nIG1hdGNoXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX2xvd2VyY2FzZS5nZXQodmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogZm91bmQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fcmVmcy5zaXplICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9iamVjdHNcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChEZWVwRXF1YWwoaXRlbSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlc1xuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgdGhpcy5fcmVmcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVmLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBpbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9ICFyZWYuaW4gfHwgdHlwZW9mIHJlc29sdmVkICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICA/IFtyZXNvbHZlZF1cbiAgICAgICAgICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KHJlc29sdmVkKSA/IHJlc29sdmVkIDogT2JqZWN0LmtleXMocmVzb2x2ZWQpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNlbnNpdGl2ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLCByZWYgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChEZWVwRXF1YWwoaXRlbSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0sIHJlZiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG92ZXJyaWRlKCkge1xuXG4gICAgICAgIHRoaXMuX292ZXJyaWRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YWx1ZXMob3B0aW9ucykge1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmXG4gICAgICAgICAgICBvcHRpb25zLmRpc3BsYXkpIHtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBbLi4udGhpcy5fdmFsdWVzLCAuLi50aGlzLl9yZWZzXSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oWy4uLnRoaXMuX3ZhbHVlcywgLi4udGhpcy5fcmVmc10pO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBpbnRlcm5hbHMuVmFsdWVzKHRoaXMuX3ZhbHVlcywgdGhpcy5fcmVmcyk7XG4gICAgICAgIHNldC5fb3ZlcnJpZGUgPSB0aGlzLl9vdmVycmlkZTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgQXNzZXJ0KCFzb3VyY2UuX292ZXJyaWRlLCAnQ2Fubm90IGNvbmNhdCBvdmVycmlkZSBzZXQgb2YgdmFsdWVzJyk7XG5cbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IGludGVybmFscy5WYWx1ZXMoWy4uLnRoaXMuX3ZhbHVlcywgLi4uc291cmNlLl92YWx1ZXNdLCBbLi4udGhpcy5fcmVmcywgLi4uc291cmNlLl9yZWZzXSk7XG4gICAgICAgIHNldC5fb3ZlcnJpZGUgPSB0aGlzLl9vdmVycmlkZTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnB1c2goeyBvdmVycmlkZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fdmFsdWVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnB1c2godmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHsgdmFsdWUgfSA6IHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fcmVmcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKHZhbHVlLmRlc2NyaWJlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuVmFsdWVzLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy52YWx1ZXNdID0gdHJ1ZTtcblxuXG4vLyBBbGlhc2VzXG5cbmludGVybmFscy5WYWx1ZXMucHJvdG90eXBlLnNsaWNlID0gaW50ZXJuYWxzLlZhbHVlcy5wcm90b3R5cGUuY2xvbmU7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMubG93ZXJjYXNlcyA9IGZ1bmN0aW9uIChmcm9tKSB7XG5cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG5cbiAgICBpZiAoZnJvbSkge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGZyb20pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbWFwLnNldCh2YWx1ZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xufTtcbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxuaW1wb3J0IHsgSGFuZGxlciwgQVBJR2F0ZXdheUV2ZW50LCBBUElHYXRld2F5UHJveHlSZXN1bHQgfSBmcm9tIFwiYXdzLWxhbWJkYVwiO1xuLy8gaW1wb3J0IGpvaSBmcm9tIFwiam9pXCI7XG5pbXBvcnQgbWlkZHkgZnJvbSBcIkBtaWRkeS9jb3JlXCI7XG5pbXBvcnQgbWlkZGxld2FyZSBmcm9tIFwiLi92YWxpZGF0aW9uXCI7XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVyOiBIYW5kbGVyID0gKFxuICBldmVudDogQVBJR2F0ZXdheUV2ZW50LFxuKTogUHJvbWlzZTxBUElHYXRld2F5UHJveHlSZXN1bHQ+ID0+IHtcbiAgY29uc3QgbmFtZSA9IGV2ZW50LnF1ZXJ5U3RyaW5nUGFyYW1ldGVycz8ubmFtZSBhcyBzdHJpbmc7XG4gIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShcbiAgICAgIHtcbiAgICAgICAgbWVzc2FnZTogYEhlbGxvICR7bmFtZX0hYCxcbiAgICAgIH0sXG4gICAgICBudWxsLFxuICAgICAgMixcbiAgICApLFxuICB9O1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBoZWxsbyA9IG1pZGR5KGhhbmRsZXIpLnVzZShtaWRkbGV3YXJlKCkpO1xuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5pbXBvcnQgeyBBUElHYXRld2F5RXZlbnQsIEFQSUdhdGV3YXlQcm94eVJlc3VsdCB9IGZyb20gXCJhd3MtbGFtYmRhXCI7XG5pbXBvcnQgbWlkZHkgZnJvbSBcIkBtaWRkeS9jb3JlXCI7XG5pbXBvcnQgSm9pIGZyb20gXCJqb2lcIjtcbmltcG9ydCBCb29tIGZyb20gXCJAaGFwaS9ib29tXCI7XG5cbmNvbnN0IHNjaGVtYSA9IEpvaS5vYmplY3Qoe1xuICBuYW1lOiBKb2kuc3RyaW5nKCkuYWxwaGFudW0oKS5yZXF1aXJlZCgpLFxufSk7XG5cbmNvbnN0IG1pZGRsZXdhcmUgPSAoKTogbWlkZHkuTWlkZGxld2FyZU9iajxcbiAgQVBJR2F0ZXdheUV2ZW50LFxuICBBUElHYXRld2F5UHJveHlSZXN1bHRcbj4gPT4ge1xuICBjb25zdCBiZWZvcmU6IG1pZGR5Lk1pZGRsZXdhcmVGbjxcbiAgICBBUElHYXRld2F5RXZlbnQsXG4gICAgQVBJR2F0ZXdheVByb3h5UmVzdWx0XG4gID4gPSBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSByZXF1ZXN0LmV2ZW50LnF1ZXJ5U3RyaW5nUGFyYW1ldGVycz8ubmFtZTtcbiAgICBjb25zdCBjYW5kaWRhdGUgPSBzY2hlbWEudmFsaWRhdGUoeyBuYW1lIH0pO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FuZGlkYXRlLCBcImVycm9yXCIpKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IEJvb20uYmFkUmVxdWVzdChcbiAgICAgICAgXCJJbnZhbGlkIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ciwgaXQgc2hvdWxkIGJlIG5hbWU9c29tZV9uYW1lXCIsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm4sIG5vLXVzZWxlc3MtcmV0dXJuXG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYmVmb3JlLFxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWlkZGxld2FyZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImV2ZW50c1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTsiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbm1vZHVsZS5leHBvcnRzID0gdm9pZCAwO1xudmFyIF9ldmVudHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZGVmYXVsdExhbWJkYUhhbmRsZXIgPSAoKT0+e307XG5jb25zdCBkZWZhdWx0UGx1Z2luID0ge1xuICAgIHRpbWVvdXRFYXJseUluTWlsbGlzOiA1LFxuICAgIHRpbWVvdXRFYXJseVJlc3BvbnNlOiAoKT0+e1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbWVvdXQnKTtcbiAgICB9XG59O1xuY29uc3QgbWlkZHkgPSAobGFtYmRhSGFuZGxlciA9IGRlZmF1bHRMYW1iZGFIYW5kbGVyLCBwbHVnaW4gPSB7fSk9PntcbiAgICBpZiAodHlwZW9mIGxhbWJkYUhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGx1Z2luID0gbGFtYmRhSGFuZGxlcjtcbiAgICAgICAgbGFtYmRhSGFuZGxlciA9IGRlZmF1bHRMYW1iZGFIYW5kbGVyO1xuICAgIH1cbiAgICBwbHVnaW4gPSB7XG4gICAgICAgIC4uLmRlZmF1bHRQbHVnaW4sXG4gICAgICAgIC4uLnBsdWdpblxuICAgIH07XG4gICAgcGx1Z2luLnRpbWVvdXRFYXJseSA9IHBsdWdpbi50aW1lb3V0RWFybHlJbk1pbGxpcyA+IDA7XG4gICAgcGx1Z2luLmJlZm9yZVByZWZldGNoPy4oKTtcbiAgICBjb25zdCBiZWZvcmVNaWRkbGV3YXJlcyA9IFtdO1xuICAgIGNvbnN0IGFmdGVyTWlkZGxld2FyZXMgPSBbXTtcbiAgICBjb25zdCBvbkVycm9yTWlkZGxld2FyZXMgPSBbXTtcbiAgICBjb25zdCBtaWRkeTEgPSAoZXZlbnQgPSB7fSwgY29udGV4dCA9IHt9KT0+e1xuICAgICAgICBwbHVnaW4ucmVxdWVzdFN0YXJ0Py4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaW50ZXJuYWw6IHBsdWdpbi5pbnRlcm5hbCA/PyB7fVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcnVuUmVxdWVzdChyZXF1ZXN0LCBbXG4gICAgICAgICAgICAuLi5iZWZvcmVNaWRkbGV3YXJlc1xuICAgICAgICBdLCBsYW1iZGFIYW5kbGVyLCBbXG4gICAgICAgICAgICAuLi5hZnRlck1pZGRsZXdhcmVzXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIC4uLm9uRXJyb3JNaWRkbGV3YXJlc1xuICAgICAgICBdLCBwbHVnaW4pO1xuICAgIH07XG4gICAgbWlkZHkxLnVzZSA9IChtaWRkbGV3YXJlcyk9PntcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1pZGRsZXdhcmVzKSkge1xuICAgICAgICAgICAgbWlkZGxld2FyZXMgPSBbXG4gICAgICAgICAgICAgICAgbWlkZGxld2FyZXNcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIG1pZGRsZXdhcmVzKXtcbiAgICAgICAgICAgIGNvbnN0IHsgYmVmb3JlICwgYWZ0ZXIgLCBvbkVycm9yICB9ID0gbWlkZGxld2FyZTtcbiAgICAgICAgICAgIGlmICghYmVmb3JlICYmICFhZnRlciAmJiAhb25FcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlkZGxld2FyZSBtdXN0IGJlIGFuIG9iamVjdCBjb250YWluaW5nIGF0IGxlYXN0IG9uZSBrZXkgYW1vbmcgXCJiZWZvcmVcIiwgXCJhZnRlclwiLCBcIm9uRXJyb3JcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlZm9yZSkgbWlkZHkxLmJlZm9yZShiZWZvcmUpO1xuICAgICAgICAgICAgaWYgKGFmdGVyKSBtaWRkeTEuYWZ0ZXIoYWZ0ZXIpO1xuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIG1pZGR5MS5vbkVycm9yKG9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaWRkeTE7XG4gICAgfTtcbiAgICBtaWRkeTEuYmVmb3JlID0gKGJlZm9yZU1pZGRsZXdhcmUpPT57XG4gICAgICAgIGJlZm9yZU1pZGRsZXdhcmVzLnB1c2goYmVmb3JlTWlkZGxld2FyZSk7XG4gICAgICAgIHJldHVybiBtaWRkeTE7XG4gICAgfTtcbiAgICBtaWRkeTEuYWZ0ZXIgPSAoYWZ0ZXJNaWRkbGV3YXJlKT0+e1xuICAgICAgICBhZnRlck1pZGRsZXdhcmVzLnVuc2hpZnQoYWZ0ZXJNaWRkbGV3YXJlKTtcbiAgICAgICAgcmV0dXJuIG1pZGR5MTtcbiAgICB9O1xuICAgIG1pZGR5MS5vbkVycm9yID0gKG9uRXJyb3JNaWRkbGV3YXJlKT0+e1xuICAgICAgICBvbkVycm9yTWlkZGxld2FyZXMudW5zaGlmdChvbkVycm9yTWlkZGxld2FyZSk7XG4gICAgICAgIHJldHVybiBtaWRkeTE7XG4gICAgfTtcbiAgICBtaWRkeTEuaGFuZGxlciA9IChyZXBsYWNlTGFtYmRhSGFuZGxlcik9PntcbiAgICAgICAgbGFtYmRhSGFuZGxlciA9IHJlcGxhY2VMYW1iZGFIYW5kbGVyO1xuICAgICAgICByZXR1cm4gbWlkZHkxO1xuICAgIH07XG4gICAgcmV0dXJuIG1pZGR5MTtcbn07XG5jb25zdCBydW5SZXF1ZXN0ID0gYXN5bmMgKHJlcXVlc3QsIGJlZm9yZU1pZGRsZXdhcmVzLCBsYW1iZGFIYW5kbGVyLCBhZnRlck1pZGRsZXdhcmVzLCBvbkVycm9yTWlkZGxld2FyZXMsIHBsdWdpbik9PntcbiAgICBjb25zdCB0aW1lb3V0RWFybHkgPSBwbHVnaW4udGltZW91dEVhcmx5ICYmIHJlcXVlc3QuY29udGV4dC5nZXRSZW1haW5pbmdUaW1lSW5NaWxsaXM7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcnVuTWlkZGxld2FyZXMocmVxdWVzdCwgYmVmb3JlTWlkZGxld2FyZXMsIHBsdWdpbik7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdC5yZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBsdWdpbi5iZWZvcmVIYW5kbGVyPy4oKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJBYm9ydCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0QWJvcnQ7XG4gICAgICAgICAgICBpZiAodGltZW91dEVhcmx5KSB0aW1lb3V0QWJvcnQgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICBsYW1iZGFIYW5kbGVyKHJlcXVlc3QuZXZlbnQsIHJlcXVlc3QuY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGhhbmRsZXJBYm9ydC5zaWduYWxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0RWFybHkgPyBzZXRUaW1lb3V0UHJvbWlzZShyZXF1ZXN0LmNvbnRleHQuZ2V0UmVtYWluaW5nVGltZUluTWlsbGlzKCkgLSBwbHVnaW4udGltZW91dEVhcmx5SW5NaWxsaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiB0aW1lb3V0QWJvcnQuc2lnbmFsXG4gICAgICAgICAgICAgICAgfSkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyQWJvcnQuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbi50aW1lb3V0RWFybHlSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIH0pIDogUHJvbWlzZS5yYWNlKFtdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAodGltZW91dEVhcmx5KSB0aW1lb3V0QWJvcnQuYWJvcnQoKTtcbiAgICAgICAgICAgIHBsdWdpbi5hZnRlckhhbmRsZXI/LigpO1xuICAgICAgICAgICAgYXdhaXQgcnVuTWlkZGxld2FyZXMocmVxdWVzdCwgYWZ0ZXJNaWRkbGV3YXJlcywgcGx1Z2luKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmVxdWVzdC5lcnJvciA9IGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NaWRkbGV3YXJlcyhyZXF1ZXN0LCBvbkVycm9yTWlkZGxld2FyZXMsIHBsdWdpbik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGUub3JpZ2luYWxFcnJvciA9IHJlcXVlc3QuZXJyb3I7XG4gICAgICAgICAgICByZXF1ZXN0LmVycm9yID0gZTtcbiAgICAgICAgICAgIHRocm93IHJlcXVlc3QuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0LnJlc3BvbnNlID09PSAndW5kZWZpbmVkJykgdGhyb3cgcmVxdWVzdC5lcnJvcjtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIGF3YWl0IHBsdWdpbi5yZXF1ZXN0RW5kPy4ocmVxdWVzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0LnJlc3BvbnNlO1xufTtcbmNvbnN0IHJ1bk1pZGRsZXdhcmVzID0gYXN5bmMgKHJlcXVlc3QsIG1pZGRsZXdhcmVzLCBwbHVnaW4pPT57XG4gICAgZm9yIChjb25zdCBuZXh0TWlkZGxld2FyZSBvZiBtaWRkbGV3YXJlcyl7XG4gICAgICAgIHBsdWdpbi5iZWZvcmVNaWRkbGV3YXJlPy4obmV4dE1pZGRsZXdhcmUubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG5leHRNaWRkbGV3YXJlKHJlcXVlc3QpO1xuICAgICAgICBwbHVnaW4uYWZ0ZXJNaWRkbGV3YXJlPy4obmV4dE1pZGRsZXdhcmUubmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZSA9IHJlcztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBwb2x5ZmlsbEFib3J0Q29udHJvbGxlciA9ICgpPT57XG4gICAgaWYgKHByb2Nlc3MudmVyc2lvbiA8ICd2MTUuMC4wJykge1xuICAgICAgICBjbGFzcyBBYm9ydFNpZ25hbCB7XG4gICAgICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tvYmplY3QgQWJvcnRTaWduYWxdJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Fib3J0U2lnbmFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIub24obmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50KHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyTmFtZSA9IGBvbiR7dHlwZX1gO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1toYW5kbGVyTmFtZV0gPT09ICdmdW5jdGlvbicpIHRoaXNbaGFuZGxlck5hbWVdKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KHR5cGUsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBuZXcgX2V2ZW50cy5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uYWJvcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzcyBBYm9ydENvbnRyb2xsZXIge1xuICAgICAgICAgICAgYWJvcnQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbC5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbC5kaXNwYXRjaEV2ZW50KCdhYm9ydCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbb2JqZWN0IEFib3J0Q29udHJvbGxlcl0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQWJvcnRDb250cm9sbGVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYWwgPSBuZXcgQWJvcnRTaWduYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gQWJvcnRDb250cm9sbGVyO1xuICAgIH1cbn07XG5nbG9iYWwuQWJvcnRDb250cm9sbGVyID0gcG9seWZpbGxBYm9ydENvbnRyb2xsZXIoKTtcbmNvbnN0IHBvbHlmaWxsU2V0VGltZW91dFByb21pc2UgPSAoKT0+e1xuICAgIHJldHVybiAobXMsIHsgc2lnbmFsICB9KT0+e1xuICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpPT57XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgfSwgbXMpO1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5jb25zdCBzZXRUaW1lb3V0UHJvbWlzZSA9IHBvbHlmaWxsU2V0VGltZW91dFByb21pc2UoKTtcbnZhciBfZGVmYXVsdCA9IG1pZGR5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9